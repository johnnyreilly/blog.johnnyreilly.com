"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[13692],{27896:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>a,toc:()=>p});var i=s(85893),r=s(11151);const n={slug:"typescript-5-importsnotusedasvalues-error-eslint-consistent-type-imports",title:"TypeScript 5: importsNotUsedAsValues replaced by ESLint consistent-type-imports",authors:"johnnyreilly",tags:["typescript","javascript","ESLint"],image:"./title-image.png",description:'TypeScript deprecated tsconfig.json option "importsNotUsedAsValues": "error" in 5. You can make type imports explicit with CommonJS if you use ESLint consistent-type-imports.',hide_table_of_contents:!1},o=void 0,a={permalink:"/typescript-5-importsnotusedasvalues-error-eslint-consistent-type-imports",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-05-09-typescript-5-importsnotusedasvalues-error-eslint-consistent-type-imports/index.md",source:"@site/blog/2023-05-09-typescript-5-importsnotusedasvalues-error-eslint-consistent-type-imports/index.md",title:"TypeScript 5: importsNotUsedAsValues replaced by ESLint consistent-type-imports",description:'TypeScript deprecated tsconfig.json option "importsNotUsedAsValues": "error" in 5. You can make type imports explicit with CommonJS if you use ESLint consistent-type-imports.',date:"2023-05-09T00:00:00.000Z",formattedDate:"May 9, 2023",tags:[{label:"typescript",permalink:"/tags/typescript"},{label:"javascript",permalink:"/tags/javascript"},{label:"ESLint",permalink:"/tags/es-lint"}],readingTime:6.14,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"typescript-5-importsnotusedasvalues-error-eslint-consistent-type-imports",title:"TypeScript 5: importsNotUsedAsValues replaced by ESLint consistent-type-imports",authors:"johnnyreilly",tags:["typescript","javascript","ESLint"],image:"./title-image.png",description:'TypeScript deprecated tsconfig.json option "importsNotUsedAsValues": "error" in 5. You can make type imports explicit with CommonJS if you use ESLint consistent-type-imports.',hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Static Web Apps CLI and Node.js 18: could not connect to API",permalink:"/static-web-apps-cli-node-18-could-not-connect-to-api"},nextItem:{title:"Migrating Azure Functions from JSDoc JavaScript to TypeScript",permalink:"/migrating-azure-functions-from-jsdoc-javascript-to-typescript"}},l={image:s(84320).Z,authorsImageUrls:[void 0]},p=[{value:"What <code>&quot;importsNotUsedAsValues&quot;: &quot;error&quot;</code> provided",id:"what-importsnotusedasvalues-error-provided",level:2},{value:"TypeScript 5 deprecates <code>importsNotUsedAsValues</code>",id:"typescript-5-deprecates-importsnotusedasvalues",level:2},{value:"ESLint and <code>@typescript-eslint/consistent-type-imports</code> to the rescue",id:"eslint-and-typescript-eslintconsistent-type-imports-to-the-rescue",level:2},{value:"<code>no-import-type-side-effects</code>",id:"no-import-type-side-effects",level:2},{value:"Make VS Code prefer type imports",id:"make-vs-code-prefer-type-imports",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["I really like type imports that are unambiguous. For this reason, I've made use of the ",(0,i.jsx)(t.code,{children:'"importsNotUsedAsValues": "error"'})," option in ",(0,i.jsx)(t.code,{children:"tsconfig.json"})," for a while now. This option has been deprecated in TypeScript 5.0.0, and will be removed in TypeScript 5.5.0. This post will look at what you can do instead."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"title image reading &quot;TypeScript 5: importsNotUsedAsValues replaced by ESLint consistent-type-imports&quot; with the ESLint and TypeScript logo",src:s(41239).Z+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,i.jsxs)(t.h2,{id:"what-importsnotusedasvalues-error-provided",children:["What ",(0,i.jsx)(t.code,{children:'"importsNotUsedAsValues": "error"'})," provided"]}),"\n",(0,i.jsxs)(t.p,{children:["Prior to TypeScript 5.0, if you wanted to make your type imports explicit, you could use the ",(0,i.jsx)(t.code,{children:'"importsNotUsedAsValues": "error"'})," option in ",(0,i.jsx)(t.code,{children:"tsconfig.json"}),". This would mean that you would need to use ",(0,i.jsx)(t.code,{children:"import type"})," for type imports, and ",(0,i.jsx)(t.code,{children:"import"})," for value imports. Consider the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { ResourceGraphClient } from '@azure/arm-resourcegraph';\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In my code I was only using ",(0,i.jsx)(t.code,{children:"ResourceGraphClient"})," as a type, so I would need to change it to:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import type { ResourceGraphClient } from '@azure/arm-resourcegraph';\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"or"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { type ResourceGraphClient } from '@azure/arm-resourcegraph';\n"})}),"\n",(0,i.jsx)(t.p,{children:"And if I rebelled, the TypeScript compiler would complain:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'.ts(1371)"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"screenshot of VS Code displaying the error message",src:s(60096).Z+"",width:"1634",height:"136",loading:"lazy"})}),"\n",(0,i.jsxs)(t.h2,{id:"typescript-5-deprecates-importsnotusedasvalues",children:["TypeScript 5 deprecates ",(0,i.jsx)(t.code,{children:"importsNotUsedAsValues"})]}),"\n",(0,i.jsx)(t.p,{children:"However, when I upgraded to TypeScript 5, I started seeing the following error:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"Option 'importsNotUsedAsValues' is deprecated and will stop functioning in TypeScript 5.5. Specify compilerOption '\"ignoreDeprecations\": \"5.0\"' to silence this error. Use 'verbatimModuleSyntax' instead."})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"screenshot of VS Code displaying the error message",src:s(16124).Z+"",width:"1996",height:"288",loading:"lazy"})}),"\n",(0,i.jsxs)(t.p,{children:["The error was the result of ",(0,i.jsx)(t.a,{href:"https://github.com/microsoft/TypeScript/pull/52203",children:"this pull request"}),". The message made me think I just needed to migrate to ",(0,i.jsx)(t.code,{children:"verbatimModuleSyntax"}),", like so:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",metastring:'title="tsconfig.json"',children:'-    "importsNotUsedAsValues": "error",\n+    "verbatimModuleSyntax": true,\n'})}),"\n",(0,i.jsx)(t.p,{children:"However, when I did so, my terminal became a sea of errors:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"src/telemetry.ts:7:13 - error TS1286: ESM syntax is not allowed in a CommonJS module when 'verbatimModuleSyntax' is enabled.\n\nimport * as task from './task.json';\n            ~~~~\n\nsrc/telemetry.ts:9:1 - error TS1287: A top-level 'export' modifier cannot be used on value declarations in a CommonJS module when 'verbatimModuleSyntax' is enabled.\n\nexport async function sendTelemetry({\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It turns out that in ",(0,i.jsx)(t.code,{children:"verbatimModuleSyntax"}),", you can't write ESM syntax in files that will emit as CommonJS - which is exactly what my codebase is doing. ",(0,i.jsx)(t.a,{href:"https://github.com/andrewbranch",children:"Andrew Branch"}),", who is part of the TypeScript team, sent me an explanation from a draft of some new TypeScript docs:"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["In TypeScript 5.0, a new compiler option called ",(0,i.jsx)(t.code,{children:"verbatimModuleSyntax"})," was introduced to help TypeScript authors know exactly how their ",(0,i.jsx)(t.code,{children:"import"})," and ",(0,i.jsx)(t.code,{children:"export"})," statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (",(0,i.jsx)(t.code,{children:'import fs = require("fs")'})," and ",(0,i.jsx)(t.code,{children:"export = {}"}),"). This setting is particularly recommended for Node projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["It further turns out that ",(0,i.jsx)(t.code,{children:"importsNotUsedAsValues"})," was never intended to be used in in the way that I did; effectively as a linting mechanism. Andrew ",(0,i.jsx)(t.a,{href:"https://github.com/microsoft/TypeScript/pull/52203#issuecomment-1476574601",children:"said this on the topic"}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"importsNotUsedAsValues"})," was made to serve the opposite purpose you (and basically everyone) were using it for. By default, TypeScript elides unneeded import statements from JS emit even without marking them as ",(0,i.jsx)(t.code,{children:"type"})," imports. ",(0,i.jsx)(t.code,{children:"importsNotUsedAsValues"})," was created as a way to escape that behavior, not (primarily) to make it more explicit. ",(0,i.jsx)(t.code,{children:"verbatimModuleSyntax"})," allows you to escape the elision behavior, and takes the explicitness of what your imports mean a step further by making you write CJS-style imports when emitting to CJS. So in my book, all the important cases that ",(0,i.jsx)(t.code,{children:"importsNotUsedAsValues"})," (and ",(0,i.jsx)(t.code,{children:"preserveValueImports"}),") covered, plus more, are covered by ",(0,i.jsx)(t.code,{children:"verbatimModuleSyntax"}),", which is way more explainable. It\u2019s mostly a matter of reducing complexity for the sake of explanation."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Until the world has finished migrating to ES Modules (which will be a while), I'm going to need to stick with CommonJS as my emit target, whilst still planning to write ES Module imports in my code. But I really like being explicit about my imports. So what can I do?"}),"\n",(0,i.jsxs)(t.h2,{id:"eslint-and-typescript-eslintconsistent-type-imports-to-the-rescue",children:["ESLint and ",(0,i.jsx)(t.code,{children:"@typescript-eslint/consistent-type-imports"})," to the rescue"]}),"\n",(0,i.jsxs)(t.p,{children:["I mentioned that I was using ",(0,i.jsx)(t.code,{children:"importsNotUsedAsValues"})," essentially as a linting mechanism. And it transpires that the answer to my need lives in ESLint itself. There's a rule named ",(0,i.jsx)(t.a,{href:"https://typescript-eslint.io/rules/consistent-type-imports/",children:(0,i.jsx)(t.code,{children:"@typescript-eslint/consistent-type-imports"})})," which tackles exactly this. If you're using ",(0,i.jsx)(t.a,{href:"https://eslint.org/",children:"ESLint"})," and ",(0,i.jsx)(t.a,{href:"https://typescript-eslint.io/",children:"typescript-eslint"}),", you can add this rule to your ",(0,i.jsx)(t.code,{children:".eslintrc.js"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",metastring:'title="eslintrc.js"',children:"module.exports = {\n  // ...\n  rules: {\n    // ...\n    '@typescript-eslint/consistent-type-imports': 'error', // the replacement of \"importsNotUsedAsValues\": \"error\"\n  },\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"Or if you prefer to have the type imports inline, you can use:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",metastring:'title="eslintrc.js"',children:"module.exports = {\n  // ...\n  rules: {\n    // ...\n    '@typescript-eslint/consistent-type-imports': [\n      'error',\n      {\n        fixStyle: 'inline-type-imports',\n      },\n    ], // the replacement of \"importsNotUsedAsValues\": \"error\"\n  },\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"With this in place, we're back to where we were before; just with a different engine:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["All imports in the declaration are only used as types. Use ",(0,i.jsx)(t.code,{children:"import type"}),".eslint@typescript-eslint/consistent-type-imports"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"screenshot of VS Code displaying the error message",src:s(57819).Z+"",width:"1662",height:"142",loading:"lazy"})}),"\n",(0,i.jsxs)(t.p,{children:["And we even have the ability to auto-fix the errors as well now. Thanks ",(0,i.jsx)(t.code,{children:"typescript-eslint"}),"!"]}),"\n",(0,i.jsx)(t.h2,{id:"no-import-type-side-effects",children:(0,i.jsx)(t.code,{children:"no-import-type-side-effects"})}),"\n",(0,i.jsxs)(t.p,{children:["We are not quite done. There's another typescript-eslint rule that we can use to help us. ",(0,i.jsx)(t.a,{href:"https://typescript-eslint.io/rules/no-import-type-side-effects/",children:(0,i.jsx)(t.code,{children:"no-import-type-side-effects"})})," is a rule that will warn you if you have any side effects in your type imports. What does that mean? Well, consider the following code:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { type A, type B } from 'mod';\n\n// is transpiled to\nimport {} from 'mod';\n\n// which is the same as\nimport 'mod';\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You may not want a runtime import at all. You can do that by using a ",(0,i.jsx)(t.strong,{children:"top-level"})," ",(0,i.jsx)(t.code,{children:"type"})," qualifier for imports when it only imports specifiers with an inline ",(0,i.jsx)(t.code,{children:"type"})," qualifier:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import type { A, B } from 'mod';\n\n// is transpiled to.... nothing! Hence no side effects\n"})}),"\n",(0,i.jsxs)(t.p,{children:["So if side effects is something you're concerned about, consider this rule as well. Note that whether ",(0,i.jsx)(t.code,{children:"import { type A } from 'mod'"})," transpiles to a side-effect import or gets completely removed depends on your ",(0,i.jsx)(t.code,{children:"tsc"})," options, or what transpiler you\u2019re using. But ",(0,i.jsx)(t.code,{children:"import type"})," statements ",(0,i.jsx)(t.em,{children:"always"})," get removed."]}),"\n",(0,i.jsx)(t.h2,{id:"make-vs-code-prefer-type-imports",children:"Make VS Code prefer type imports"}),"\n",(0,i.jsxs)(t.p,{children:["One of the delightful features of TypeScript in VS Code is TypeScript generated auto-imports. Thanks in large part to the work of ",(0,i.jsx)(t.a,{href:"https://github.com/andrewbranch",children:"Andrew Branch"})," on the TypeScript team, the editor will often generate the ",(0,i.jsx)(t.code,{children:"import"})," that you need when you're coding. However, it will generally create value imports; ",(0,i.jsx)(t.em,{children:"not"})," type imports. So it might auto add this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { ResourceGraphClient } from '@azure/arm-resourcegraph';\n"})}),"\n",(0,i.jsx)(t.p,{children:"Not this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import type { ResourceGraphClient } from '@azure/arm-resourcegraph';\n"})}),"\n",(0,i.jsxs)(t.p,{children:['As of TypeScript 5.3, this is now an editor-specific option. In Visual Studio Code, it can be enabled in the settings UI under "TypeScript \u203a Preferences: Prefer Type Only Auto Imports", or as the JSON configuration option ',(0,i.jsx)(t.code,{children:"typescript.preferences.preferTypeOnlyAutoImports"}),". You can read about this in the ",(0,i.jsx)(t.a,{href:"https://devblogs.microsoft.com/typescript/announcing-typescript-5-3/#settings-to-prefer-type-auto-imports",children:"TypeScript 5.3 release notes"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Turn it on - it'll make you happy!"}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"Thanks to Andrew Branch for reviewing this post, and massively improving it! Any mistakes are mine, not his."})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},84320:(e,t,s)=>{s.d(t,{Z:()=>i});const i=s.p+"assets/images/title-image-be1079a13c4ed4213afb6c3bc59929f8.png"},57819:(e,t,s)=>{s.d(t,{Z:()=>i});const i=s.p+"assets/images/screenshot-consistent-type-imports-error-59b29a8f0f9abd25698909d03e1804a1.png"},16124:(e,t,s)=>{s.d(t,{Z:()=>i});const i=s.p+"assets/images/screenshot-importsnotusedasvalues-deprecated-e487158e065f86b9861edd1b79f934a1.png"},60096:(e,t,s)=>{s.d(t,{Z:()=>i});const i=s.p+"assets/images/screenshot-importsnotusedasvalues-error-fcc2dbd3e13f8b925176a36b1775e0ec.png"},41239:(e,t,s)=>{s.d(t,{Z:()=>i});const i=s.p+"assets/images/title-image-be1079a13c4ed4213afb6c3bc59929f8.png"},11151:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>o});var i=s(67294);const r={},n=i.createContext(r);function o(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);