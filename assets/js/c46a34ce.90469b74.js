"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[15588],{1032:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/use-generated-client-68121118d8862aee3faf83860aeb6de9.gif"},28349:e=>{e.exports=JSON.parse('{"permalink":"/dotnet-openapi-and-openapi-ts","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2026-01-02-dotnet-openapi-and-openapi-ts/index.md","source":"@site/blog/2026-01-02-dotnet-openapi-and-openapi-ts/index.md","title":"Full-stack static typing with OpenAPI TypeScript and Microsoft.AspNetCore.OpenApi","description":"This post will show you how to write full stack applications with static typing from back to front using OpenAPI, TypeScript and .NET.","date":"2026-01-02T00:00:00.000Z","tags":[{"inline":false,"label":"Swagger","permalink":"/tags/swagger","description":"The Swagger API documentation framework - now known as OpenAPI."},{"inline":false,"label":"C#","permalink":"/tags/csharp","description":"The C# programming language."},{"inline":false,"label":"Azure","permalink":"/tags/azure","description":"The Microsoft cloud platform."},{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."}],"readingTime":12.72,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"dotnet-openapi-and-openapi-ts","title":"Full-stack static typing with OpenAPI TypeScript and Microsoft.AspNetCore.OpenApi","authors":"johnnyreilly","tags":["swagger","c#","azure","typescript"],"image":"./use-generated-client.gif","hide_table_of_contents":false,"description":"This post will show you how to write full stack applications with static typing from back to front using OpenAPI, TypeScript and .NET."},"unlisted":false,"nextItem":{"title":"Yargs: statically typed builder commands","permalink":"/yargs-statically-typed-builder-commands"}}')},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(96540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}},37335:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/use-generated-client-68121118d8862aee3faf83860aeb6de9.gif"},54085:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var r=t(28349),a=t(74848),s=t(28453);const i={slug:"dotnet-openapi-and-openapi-ts",title:"Full-stack static typing with OpenAPI TypeScript and Microsoft.AspNetCore.OpenApi",authors:"johnnyreilly",tags:["swagger","c#","azure","typescript"],image:"./use-generated-client.gif",hide_table_of_contents:!1,description:"This post will show you how to write full stack applications with static typing from back to front using OpenAPI, TypeScript and .NET."},o=void 0,c={image:t(37335).A,authorsImageUrls:[void 0]},p=[{value:"What will we do?",id:"what-will-we-do",level:2},{value:"Create an API",id:"create-an-api",level:2},{value:"Create our client",id:"create-our-client",level:2},{value:"Generate our OpenAPI client",id:"generate-our-openapi-client",level:2},{value:"Adjusting <code>Microsoft.AspNetCore.OpenApi</code> surfaced types",id:"adjusting-microsoftaspnetcoreopenapi-surfaced-types",level:2},{value:"Consume our generated API client",id:"consume-our-generated-api-client",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["I've long believed in the benefits of static typing. Static typing helps you catch errors early, improves code navigation and makes refactoring easier. In recent years I've been using TypeScript on the front end and C# on the back end to get these benefits. I wrote previously about how to do this with ",(0,a.jsx)(n.a,{href:"/generate-typescript-and-csharp-clients-with-nswag",children:"NSwag"})," and I thought it was probably worth returning to the topic. How would I do the same thing now?"]}),"\n",(0,a.jsxs)(n.p,{children:["NSwag is still great, but it produces OpenAPI 3.0 specifications. However, Microsoft have been working on their own OpenAPI tooling for .NET. The ",(0,a.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-10.0",children:(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"})})," package provides functionality to generate OpenAPI specifications from ASP.NET Core Web APIs and it supports OpenAPI 3.1. This difference turns out to be significant when it comes to handling nullability."]}),"\n",(0,a.jsxs)(n.p,{children:["There was a change to ",(0,a.jsx)(n.a,{href:"https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0",children:"how nullablity is represented in OpenAPI 3.1 compared to 3.0"}),". Whether that change is the cause or not I'm not sure, but the OpenAPI specifications produced by ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"})," seem to surface nullability better than I've found with NSwag or Swashbuckle. If something is ",(0,a.jsx)(n.strong,{children:"not"})," defined as nullable in the C# model, it is ",(0,a.jsx)(n.strong,{children:"not"})," marked as nullable in the OpenAPI spec. This means that when we generate TypeScript clients from the OpenAPI spec, we get better nullability support in TypeScript too. Previously I'd find I'd do a lot of null checks or assertions in TypeScript even when the C# model didn't allow nulls. Now, with OpenAPI 3.1 and ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"}),", I find that much less often."]}),"\n",(0,a.jsxs)(n.p,{children:['The client that NSwag generates is also still very useful. But it is somewhat "heavy" in that it creates a lot of code, and it is runtime code, so it adds to my bundle size and my execution time. The alternative I\'m going to show you here is to use ',(0,a.jsxs)(n.a,{href:"https://openapi-ts.dev/",children:["OpenAPI TypeScript / ",(0,a.jsx)(n.code,{children:"openapi-ts"})]}),". This is a lightweight TypeScript client generator for OpenAPI 3.x specifications. Most of the work it does is in the form of TypeScript type definitions. Given that type definitions are erased at runtime, the resulting client code is very lightweight. It also has good support for OpenAPI 3.1."]}),"\n",(0,a.jsx)(n.h2,{id:"what-will-we-do",children:"What will we do?"}),"\n",(0,a.jsxs)(n.p,{children:["So in this post we're going to do exactly what I did in my 2021 post, but this time using ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"})," to generate the OpenAPI spec and ",(0,a.jsx)(n.code,{children:"openapi-ts"})," to generate the TypeScript client."]}),"\n",(0,a.jsx)(n.p,{children:"We will:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Create a .NET app which exposes an OpenAPI endpoint with ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Create a script which, when run, creates a TypeScript client with ",(0,a.jsx)(n.code,{children:"openapi-ts"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Consume the API using the generated client in a simple TypeScript application."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["If you're going to do this, you will need both ",(0,a.jsx)(n.a,{href:"https://nodejs.org/",children:"Node.js"})," and the ",(0,a.jsx)(n.a,{href:"https://dotnet.microsoft.com/",children:".NET SDK"})," installed."]}),"\n",(0,a.jsx)(n.h2,{id:"create-an-api",children:"Create an API"}),"\n",(0,a.jsx)(n.p,{children:"We'll now create an API which exposes an Open API endpoint:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"dotnet new webapi -o server\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The above command creates a new .NET Web API project in a folder called ",(0,a.jsx)(n.code,{children:"server"}),". Pretty much all the code we care about is in ",(0,a.jsx)(n.code,{children:"Program.cs"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'var builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\n// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.MapOpenApi();\n}\n\napp.UseHttpsRedirection();\n\nvar summaries = new[]\n{\n    "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"\n};\n\napp.MapGet("/weatherforecast", () =>\n{\n    var forecast =  Enumerable.Range(1, 5).Select(index =>\n        new WeatherForecast\n        (\n            DateOnly.FromDateTime(DateTime.Now.AddDays(index)),\n            Random.Shared.Next(-20, 55),\n            summaries[Random.Shared.Next(summaries.Length)]\n        ))\n        .ToArray();\n    return forecast;\n})\n.WithName("GetWeatherForecast");\n\napp.Run();\n\nrecord WeatherForecast(DateOnly Date, int TemperatureC, string? Summary)\n{\n    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This is simply exposing a single endpoint, ",(0,a.jsx)(n.code,{children:"/weatherforecast"})," which returns some (fake) weather data. If we run our API with:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:'dotnet run --urls="http://localhost:5000"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We can then navigate to ",(0,a.jsx)(n.code,{children:"http://localhost:5000/weatherforecast"})," and see the JSON output:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "date": "2025-12-30",\n    "temperatureC": 11,\n    "summary": "Sweltering",\n    "temperatureF": 51\n  },\n  {\n    "date": "2025-12-31",\n    "temperatureC": 4,\n    "summary": "Cool",\n    "temperatureF": 39\n  },\n  {\n    "date": "2026-01-01",\n    "temperatureC": -19,\n    "summary": "Cool",\n    "temperatureF": -2\n  },\n  {\n    "date": "2026-01-02",\n    "temperatureC": -8,\n    "summary": "Warm",\n    "temperatureF": 18\n  },\n  {\n    "date": "2026-01-03",\n    "temperatureC": -16,\n    "summary": "Sweltering",\n    "temperatureF": 4\n  }\n]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["And we can see the OpenAPI endpoint at ",(0,a.jsx)(n.code,{children:"http://localhost:5000/openapi/v1.json"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "openapi": "3.1.1",\n  "info": {\n    "title": "server | v1",\n    "version": "1.0.0"\n  },\n  "servers": [\n    {\n      "url": "http://localhost:5000/"\n    }\n  ],\n  "paths": {\n    "/weatherforecast": {\n      "get": {\n        "tags": ["server"],\n        "operationId": "GetWeatherForecast",\n        "responses": {\n          "200": {\n            "description": "OK",\n            "content": {\n              "application/json": {\n                "schema": {\n                  "type": "array",\n                  "items": {\n                    "$ref": "#/components/schemas/WeatherForecast"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  "components": {\n    "schemas": {\n      "WeatherForecast": {\n        "required": ["date", "temperatureC", "summary"],\n        "type": "object",\n        "properties": {\n          "date": {\n            "type": "string",\n            "format": "date"\n          },\n          "temperatureC": {\n            "pattern": "^-?(?:0|[1-9]\\\\d*)$",\n            "type": ["integer", "string"],\n            "format": "int32"\n          },\n          "summary": {\n            "type": ["null", "string"]\n          },\n          "temperatureF": {\n            "pattern": "^-?(?:0|[1-9]\\\\d*)$",\n            "type": ["integer", "string"],\n            "format": "int32"\n          }\n        }\n      }\n    }\n  },\n  "tags": [\n    {\n      "name": "server"\n    }\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This is great! (Actually, there's some problems with the ",(0,a.jsx)(n.code,{children:"temperatureC"})," and ",(0,a.jsx)(n.code,{children:"temperatureF"})," properties being marked as both ",(0,a.jsx)(n.code,{children:"integer"})," and ",(0,a.jsx)(n.code,{children:"string"})," but we'll ignore that for now.)"]}),"\n",(0,a.jsx)(n.h2,{id:"create-our-client",children:"Create our client"}),"\n",(0,a.jsx)(n.p,{children:"We'll now create a web app with which to consume our API:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"npm create vite@latest client -- --template react-ts\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This creates a React + TypeScript app in a folder called ",(0,a.jsx)(n.code,{children:"client"}),". We'll now follow the ",(0,a.jsxs)(n.a,{href:"https://openapi-ts.dev/introduction#setup",children:[(0,a.jsx)(n.code,{children:"openapi-ts"})," setup"]})," instructions to add ",(0,a.jsx)(n.code,{children:"openapi-ts"})," to our project:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"cd client\nnpm i -D openapi-typescript typescript\n"})}),"\n",(0,a.jsxs)(n.p,{children:["And we'll update the ",(0,a.jsx)(n.code,{children:"tsconfig.app.json"})," to include the recommended settings:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "noUncheckedIndexedAccess": true\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To make local development easier, we'll also add a proxy to our ",(0,a.jsx)(n.code,{children:"vite.config.ts"})," so that API request is proxied to our .NET API:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\n// https://vite.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n\n  server: {\n    proxy: {\n      '/weatherforecast': {\n        target: 'http://127.0.0.1:5000',\n        changeOrigin: true,\n        autoRewrite: true,\n      },\n    },\n  },\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now we no longer need to deal with CORS during development, and our local development setup more closely resembles production. Incidentally, we could put all our API requests behind the proxy if we wanted to by using a standard prefix like ",(0,a.jsx)(n.code,{children:"/api"}),", but for this demo we'll just proxy the one endpoint."]}),"\n",(0,a.jsx)(n.p,{children:"We have a front end app ready to consume our API. But we need to generate an OpenAPI client first."}),"\n",(0,a.jsx)(n.h2,{id:"generate-our-openapi-client",children:"Generate our OpenAPI client"}),"\n",(0,a.jsxs)(n.p,{children:["We'll add an ",(0,a.jsx)(n.code,{children:"npm script"})," to our ",(0,a.jsx)(n.code,{children:"package.json"})," in the ",(0,a.jsx)(n.code,{children:"client"})," folder to generate our OpenAPI client using ",(0,a.jsx)(n.code,{children:"openapi-ts"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'  "scripts": {\n    // ... other scripts ...\n    "generate-client": "openapi-typescript http://localhost:5000/openapi/v1.json --output src/GeneratedClient.ts --root-types --root-types-no-schema-prefix"\n  }\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This, when run, will generate a TypeScript client in ",(0,a.jsx)(n.code,{children:"src/GeneratedClient.ts"})," based on the OpenAPI spec exposed by our .NET API. It will also include the \"root types\" so we can import them in our code easily. To generate the client, we need to ensure our API is running. So we'll jump back up to the root of our .NET / React project and we'll add a ",(0,a.jsx)(n.code,{children:"package.json"}),". We'll add the following two dependencies:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"npm install --save-dev start-server-and-test concurrently\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then we'll add scripts to handle running client and server together, and to generate the client:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "name": "openapi-ts-test",\n  "version": "1.0.0",\n  "license": "ISC",\n  "scripts": {\n    "start": "concurrently -n \\"FE,BE\\" -c \\"bgBlue.bold,bgMagenta.bold\\" \\"npm run dev:client\\" \\"npm run dev:server\\"",\n    "dev:client": "cd client && npm run dev",\n    "dev:server": "cd server && dotnet run --urls=\\"http://localhost:5000\\"",\n    "generate-client": "start-server-and-test dev:server http-get://localhost:5000/openapi/v1.json generate-client:make",\n    "generate-client:make": "cd client && npm run generate-client"\n  },\n  "devDependencies": {\n    "concurrently": "^9.2.1",\n    "start-server-and-test": "^2.1.3"\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Running ",(0,a.jsx)(n.code,{children:"npm run generate-client"})," in the root of our project will now:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Start the server API on ",(0,a.jsx)(n.code,{children:"http://localhost:5000"})]}),"\n",(0,a.jsxs)(n.li,{children:["Wait for the OpenAPI endpoint to be available using ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/start-server-and-test",children:(0,a.jsx)(n.code,{children:"start-server-and-test"})})]}),"\n",(0,a.jsxs)(n.li,{children:["Run the ",(0,a.jsx)(n.code,{children:"generate-client"})," script in the ",(0,a.jsx)(n.code,{children:"client"})," folder to generate the TypeScript client."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Here's what our generated client looks like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\nexport interface paths {\n  '/weatherforecast': {\n    parameters: {\n      query?: never;\n      header?: never;\n      path?: never;\n      cookie?: never;\n    };\n    get: operations['GetWeatherForecast'];\n    put?: never;\n    post?: never;\n    delete?: never;\n    options?: never;\n    head?: never;\n    patch?: never;\n    trace?: never;\n  };\n}\nexport type webhooks = Record<string, never>;\nexport interface components {\n  schemas: {\n    WeatherForecast: {\n      /** Format: date */\n      date: string;\n      /** Format: int32 */\n      temperatureC: number | string;\n      summary: null | string;\n      /** Format: int32 */\n      temperatureF?: number | string;\n    };\n  };\n  responses: never;\n  parameters: never;\n  requestBodies: never;\n  headers: never;\n  pathItems: never;\n}\nexport type WeatherForecast = components['schemas']['WeatherForecast'];\nexport type $defs = Record<string, never>;\nexport interface operations {\n  GetWeatherForecast: {\n    parameters: {\n      query?: never;\n      header?: never;\n      path?: never;\n      cookie?: never;\n    };\n    requestBody?: never;\n    responses: {\n      /** @description OK */\n      200: {\n        headers: {\n          [name: string]: unknown;\n        };\n        content: {\n          'application/json': components['schemas']['WeatherForecast'][];\n        };\n      };\n    };\n  };\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can see our ",(0,a.jsx)(n.code,{children:"/weatherforecast"})," endpoint is represented in the ",(0,a.jsx)(n.code,{children:"paths"})," section and the ",(0,a.jsx)(n.code,{children:"WeatherForecast"})," model is represented in the ",(0,a.jsx)(n.code,{children:"components.schemas"})," section."]}),"\n",(0,a.jsxs)(n.h2,{id:"adjusting-microsoftaspnetcoreopenapi-surfaced-types",children:["Adjusting ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"})," surfaced types"]}),"\n",(0,a.jsxs)(n.p,{children:["I mentioned earlier that the ",(0,a.jsx)(n.code,{children:"temperatureC"})," and ",(0,a.jsx)(n.code,{children:"temperatureF"})," properties were marked as both ",(0,a.jsx)(n.code,{children:"integer"})," and ",(0,a.jsx)(n.code,{children:"string"})," in the OpenAPI spec. This is because ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"})," is being ... interesting ... about number types. If we look at the types created in our client we see:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"    WeatherForecast: {\n      /** Format: date */\n      date: string;\n      /** Format: int32 */\n      temperatureC: number | string;\n      summary: null | string;\n      /** Format: int32 */\n      temperatureF?: number | string;\n    };\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note how ",(0,a.jsx)(n.code,{children:"temperatureC"})," and ",(0,a.jsx)(n.code,{children:"temperatureF"})," are both ",(0,a.jsx)(n.code,{children:"number | string"}),". This isn't what we're after; we want them to be just ",(0,a.jsx)(n.code,{children:"number"})," to reflect the C# ",(0,a.jsx)(n.code,{children:"int"})," model. To fix this, we can create 2 ",(0,a.jsx)(n.code,{children:"IOpenApiSchemaTransformer"})," implementations to fix up the ",(0,a.jsx)(n.code,{children:"number | string"})," types to just ",(0,a.jsx)(n.code,{children:"number"})," types. One to handle integer style numbers (",(0,a.jsx)(n.code,{children:"IntegerSchemaTransformer"}),") and one to handle numbers with decimal places (",(0,a.jsx)(n.code,{children:"NumberSchemaTransformer"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using Microsoft.AspNetCore.OpenApi;\nusing Microsoft.OpenApi;\n\nnamespace Server.OpenApi;\n\n/// <summary>\n/// Transforms OpenAPI schema for integer types to ensure they are represented\n/// with proper type and format, removing unwanted pattern and string type alternatives.\n/// This affects integer types like int, long, short, etc.\n/// </summary>\npublic sealed class IntegerSchemaTransformer : IOpenApiSchemaTransformer\n{\n    public Task TransformAsync(\n        OpenApiSchema schema,\n        OpenApiSchemaTransformerContext context,\n        CancellationToken cancellationToken)\n    {\n        var type = context.JsonTypeInfo.Type;\n\n        // Handle nullable integers\n        var actualType = Nullable.GetUnderlyingType(type) ?? type;\n\n        // Check if this is an integer type\n        if (actualType == typeof(int) ||\n            actualType == typeof(long) ||\n            actualType == typeof(short) ||\n            actualType == typeof(byte) ||\n            actualType == typeof(sbyte) ||\n            actualType == typeof(uint) ||\n            actualType == typeof(ulong) ||\n            actualType == typeof(ushort))\n        {\n            // Set type to integer only (not ["integer", "string"])\n            schema.Type = JsonSchemaType.Integer;\n\n            // Clear any pattern that might have been added\n            schema.Pattern = null;\n\n            // Set appropriate format based on the actual type\n            schema.Format = actualType switch\n            {\n                // based on https://spec.openapis.org/oas/v3.1.1.html#data-types\n                Type t when t == typeof(int) => "int32",\n                Type t when t == typeof(uint) => "int32",\n                Type t when t == typeof(long) => "int64",\n                Type t when t == typeof(ulong) => "int64",\n                Type t when t == typeof(short) => "int32",\n                Type t when t == typeof(ushort) => "int32",\n                Type t when t == typeof(byte) => "int32",\n                Type t when t == typeof(sbyte) => "int32",\n                _ => "int32"\n            };\n\n            // Clear any enum values that might have been set\n            schema.Enum?.Clear();\n        }\n\n        return Task.CompletedTask;\n    }\n}\n\n/// <summary>\n/// Transforms OpenAPI schema for number types to ensure they are represented\n/// with proper type and format, removing unwanted pattern and string type alternatives.\n/// This affects floating-point types like double, float, and decimal.\n/// </summary>\npublic sealed class NumberSchemaTransformer : IOpenApiSchemaTransformer\n{\n    public Task TransformAsync(\n        OpenApiSchema schema,\n        OpenApiSchemaTransformerContext context,\n        CancellationToken cancellationToken)\n    {\n        var type = context.JsonTypeInfo.Type;\n\n        // Handle nullable numbers\n        var actualType = Nullable.GetUnderlyingType(type) ?? type;\n\n        // Check if this is an integer type\n        if (actualType == typeof(double) ||\n            actualType == typeof(decimal) ||\n            actualType == typeof(float))\n        {\n            // Set type to integer only (not ["number", "string"])\n            schema.Type = JsonSchemaType.Number;\n\n            // Clear any pattern that might have been added\n            schema.Pattern = null;\n\n            // Set appropriate format based on the actual type\n            schema.Format = actualType switch\n            {\n                // based on https://spec.openapis.org/oas/v3.1.1.html#data-types\n                Type t when t == typeof(double) => "double",\n                Type t when t == typeof(decimal) => "double",\n                Type t when t == typeof(float) => "float",\n                _ => "double"\n            };\n\n            // Clear any enum values that might have been set\n            schema.Enum?.Clear();\n        }\n\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["And the ",(0,a.jsx)(n.code,{children:"Program.cs"})," is updated to register these transformers:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"builder.Services.AddOpenApi(options =>\n{\n    options.AddSchemaTransformer<Server.OpenApi.IntegerSchemaTransformer>();\n    options.AddSchemaTransformer<Server.OpenApi.NumberSchemaTransformer>();\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With this in place, when we next run ",(0,a.jsx)(n.code,{children:"npm run generate-client"})," from the root of our project, we find that our generated client now has the correct types for ",(0,a.jsx)(n.code,{children:"temperatureC"})," and ",(0,a.jsx)(n.code,{children:"temperatureF"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"    WeatherForecast: {\n      /** Format: date */\n      date: string;\n      /** Format: int32 */\n      temperatureC: number;\n      summary: null | string;\n      /** Format: int32 */\n      temperatureF?: number;\n    };\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/dotnet/aspnetcore/issues/64920",children:"I've inquired whether the default behaviour makes the most sense here."})}),"\n",(0,a.jsx)(n.h2,{id:"consume-our-generated-api-client",children:"Consume our generated API client"}),"\n",(0,a.jsxs)(n.p,{children:["Now we want to make use of our generated client in our React app. First we're going to install ",(0,a.jsx)(n.code,{children:"openapi-fetch"})," to help with making requests:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"npm i openapi-fetch\n"})}),"\n",(0,a.jsxs)(n.p,{children:["(A quick note, ",(0,a.jsx)(n.code,{children:"openapi-fetch"})," is not strictly necessary here, but it makes things easier. It provides a fetch-based HTTP client which works well with ",(0,a.jsx)(n.code,{children:"openapi-ts"})," generated clients. It's worth saying that there are plans to deprecate ",(0,a.jsxs)(n.a,{href:"https://github.com/openapi-ts/openapi-typescript/discussions/2559",children:[(0,a.jsx)(n.code,{children:"openapi-fetch"})," which you can read about here"]}),". As of right now though, it's still a useful library to use alongside ",(0,a.jsx)(n.code,{children:"openapi-ts"}),".)"]}),"\n",(0,a.jsxs)(n.p,{children:["Now let's start our client and server with ",(0,a.jsx)(n.code,{children:"npm run start"}),". We'll then replace the contents of ",(0,a.jsx)(n.code,{children:"App.tsx"})," with:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useEffect, useState } from 'react';\nimport './App.css';\nimport createClient from 'openapi-fetch';\nimport type { paths, WeatherForecast } from './GeneratedClient'; // generated by openapi-typescript\n\nconst client = createClient<paths>();\n\nfunction App() {\n  const [weather, setWeather] = useState<WeatherForecast[] | null>();\n  useEffect(() => {\n    async function loadWeather() {\n      const { data, error } = await client.GET('/weatherforecast');\n      if (data) {\n        setWeather(data);\n      } else if (error) {\n        console.error('Failed to load weather:', error);\n      }\n    }\n    loadWeather();\n  }, [setWeather]);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        {weather ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Date</th>\n                <th>Summary</th>\n                <th>Centigrade</th>\n                <th>Fahrenheit</th>\n              </tr>\n            </thead>\n            <tbody>\n              {weather.map(({ date, summary, temperatureC, temperatureF }) => (\n                <tr key={date}>\n                  <td>{new Date(date).toLocaleDateString()}</td>\n                  <td>{summary}</td>\n                  <td>{temperatureC}</td>\n                  <td>{temperatureF}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        ) : (\n          <p>Loading weather...</p>\n        )}\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let's break down what's happening here:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["We import the generated types from ",(0,a.jsx)(n.code,{children:"GeneratedClient.ts"})]}),"\n",(0,a.jsxs)(n.li,{children:["We create an ",(0,a.jsx)(n.code,{children:"openapi-fetch"})," client using those types."]}),"\n",(0,a.jsxs)(n.li,{children:["In a ",(0,a.jsx)(n.code,{children:"useEffect"})," hook, we call the ",(0,a.jsx)(n.code,{children:"/weatherforecast"})," endpoint using the generated client."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"From a users perspective, when we run the app we see: (I've reused the GIF from my previous post here as the experience is the same.)"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"load data from server",src:t(1032).A+"",width:"600",height:"354",loading:"lazy"})}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(n.p,{children:["In this post we've seen how to create a .NET Web API which exposes an OpenAPI endpoint using ",(0,a.jsx)(n.code,{children:"Microsoft.AspNetCore.OpenApi"}),". We've then seen how to generate a TypeScript client from that OpenAPI spec using ",(0,a.jsx)(n.code,{children:"openapi-ts"}),". Finally, we've seen how to consume that generated client in a React + TypeScript application."]}),"\n",(0,a.jsx)(n.p,{children:"What's significant here is that we have static typing all the way from back end to front end. The C# models we defined in our .NET API are represented in the OpenAPI spec, and those same models are represented in TypeScript types in our front end application. This means that if we change a model on the back end, we can regenerate the TypeScript client and get type safety on the front end too. I'm using C#, but you could be using something else entirely on the back end, as long as it can produce an OpenAPI spec."}),"\n",(0,a.jsx)(n.p,{children:"There was a little adjustment needed to get the number types working correctly, but overall this was a pretty straightforward process. If you're building full stack applications with TypeScript on the front end and .NET on the back end, I recommend giving this approach a try!"})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);