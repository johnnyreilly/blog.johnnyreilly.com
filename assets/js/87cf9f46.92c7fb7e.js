"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[40184],{64824:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var a=t(74848),o=t(28453);const i={slug:"output-connection-strings-and-keys-from-azure-bicep",title:"Output connection strings and keys from Azure Bicep",authors:"johnnyreilly",tags:["bicep","azure"],image:"./title-image.png",hide_table_of_contents:!1,description:"Learn how to acquire connection strings and access keys in Azure with Bicep using the `listKeys` helper, and optionally consume them in Azure Pipelines."},s=void 0,r={permalink:"/output-connection-strings-and-keys-from-azure-bicep",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2021-07-07-output-connection-strings-and-keys-from-azure-bicep/index.md",source:"@site/blog/2021-07-07-output-connection-strings-and-keys-from-azure-bicep/index.md",title:"Output connection strings and keys from Azure Bicep",description:"Learn how to acquire connection strings and access keys in Azure with Bicep using the `listKeys` helper, and optionally consume them in Azure Pipelines.",date:"2021-07-07T00:00:00.000Z",tags:[{inline:!1,label:"Bicep",permalink:"/tags/bicep",description:"The Bicep language for Azure Resource Manager templates."},{inline:!1,label:"Azure",permalink:"/tags/azure",description:"The Microsoft cloud platform."}],readingTime:6.38,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"output-connection-strings-and-keys-from-azure-bicep",title:"Output connection strings and keys from Azure Bicep",authors:"johnnyreilly",tags:["bicep","azure"],image:"./title-image.png",hide_table_of_contents:!1,description:"Learn how to acquire connection strings and access keys in Azure with Bicep using the `listKeys` helper, and optionally consume them in Azure Pipelines."},unlisted:!1,prevItem:{title:"webpack? esbuild? Why not both?",permalink:"/webpack-esbuild-why-not-both"},nextItem:{title:"C# 9 in-process Azure Functions",permalink:"/c-sharp-9-azure-functions-in-process"}},c={image:t(29914).A,authorsImageUrls:[void 0]},u=[{value:"Event Hub connection string",id:"event-hub-connection-string",level:2},{value:"Storage Account connection string",id:"storage-account-connection-string",level:2},{value:"From Bicep to Azure Pipelines",id:"from-bicep-to-azure-pipelines",level:2}];function l(e){const n={a:"a",code:"code",del:"del",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["If we're provisioning resources in Azure with Bicep, we may have a need to acquire the connection strings and keys of our newly deployed infrastructure. For example, the connection strings of an event hub or the access keys of a storage account. Perhaps we'd like to use them to run an end-to-end test, perhaps we'd like to store these secrets somewhere for later consumption. This post shows how to do that using Bicep and the ",(0,a.jsx)(n.code,{children:"listKeys"})," helper. Optionally it shows how we could consume this in Azure Pipelines."]}),"\n",(0,a.jsxs)(n.p,{children:["Please note that exporting keys / connection strings etc from Bicep / ARM templates is generally considered to be a less secure approach. This is because these values will be visible inside the deployments section of the Azure Portal. Anyone who has access to this will be able to see them. An alternative approach would be permissioning our pipeline to access the resources directly. You can read about that approach ",(0,a.jsx)(n.a,{href:"/permissioning-azure-pipelines-bicep-role-assignments",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, if you're just thinking about how to configure your Azure Container Apps / Azure Static Web Apps / Azure Function Apps etc with connection strings and keys there is another way. You can perform configuration directly within Bicep, without ever exposing secrets. ",(0,a.jsx)(n.a,{href:"/configure-azure-connection-strings-keys-in-azure-bicep",children:"Read about that approach here"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"image which contains the blog title",src:t(54447).A+"",width:"750",height:"250",loading:"eager",fetchpriority:"high"})}),"\n",(0,a.jsx)(n.h2,{id:"event-hub-connection-string",children:"Event Hub connection string"}),"\n",(0,a.jsx)(n.p,{children:"First of all, let's provision an Azure Event Hub. This involves deploying an event hub namespace, an event hub in that namespace and an authorization rule. The following Bicep will do this for us:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bicep",children:"// Create an event hub namespace\n\nvar eventHubNamespaceName = 'evhns-demo'\n\nresource eventHubNamespace 'Microsoft.EventHub/namespaces@2021-01-01-preview' = {\n  name: eventHubNamespaceName\n  location: resourceGroup().location\n  sku: {\n    name: 'Standard'\n    tier: 'Standard'\n    capacity: 1\n  }\n  properties: {\n    zoneRedundant: true\n  }\n}\n\n// Create an event hub inside the namespace\n\nvar eventHubName = 'evh-demo'\n\nresource eventHubNamespaceName_eventHubName 'Microsoft.EventHub/namespaces/eventhubs@2021-01-01-preview' = {\n  parent: eventHubNamespace\n  name: eventHubName\n  properties: {\n    messageRetentionInDays: 7\n    partitionCount: 1\n  }\n}\n\n// Grant Listen and Send on our event hub\n\nresource eventHubNamespaceName_eventHubName_ListenSend 'Microsoft.EventHub/namespaces/eventhubs/authorizationRules@2021-01-01-preview' = {\n  parent: eventHubNamespaceName_eventHubName\n  name: 'ListenSend'\n  properties: {\n    rights: [\n      'Listen'\n      'Send'\n    ]\n  }\n  dependsOn: [\n    eventHubNamespace\n  ]\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"When this is deployed to Azure, it will result in creating something like this:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"screenshot of event hub connection strings in the Azure Portal",src:t(47195).A+"",width:"2358",height:"1460",loading:"lazy"})}),"\n",(0,a.jsx)(n.p,{children:"As we can see, there are connection strings available which can be used to access the event hub. How do we get a connection string that we can play with? It's easily achieved by appending the following to our Bicep:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bicep",children:"// Determine our connection string\n\nvar eventHubNamespaceConnectionString = listKeys(eventHubNamespaceName_eventHubName_ListenSend.id, eventHubNamespaceName_eventHubName_ListenSend.apiVersion).primaryConnectionString\n\n// Output our variables\n\noutput eventHubNamespaceConnectionString string = eventHubNamespaceConnectionString\noutput eventHubName string = eventHubName\n"})}),"\n",(0,a.jsxs)(n.p,{children:["What we're doing here is using the ",(0,a.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/bicep-functions-resource#list",children:(0,a.jsx)(n.code,{children:"listKeys"})})," helper on our authorization rule and retrieving the handy ",(0,a.jsx)(n.code,{children:"primaryConnectionString"}),", which is then exposed as an output variable."]}),"\n",(0,a.jsx)(n.h2,{id:"storage-account-connection-string",children:"Storage Account connection string"}),"\n",(0,a.jsx)(n.p,{children:"We'd like to obtain a connection string for a storage account also. Let's put together a Bicep file that creates a storage account and a container therein. (Incidentally, it's fairly common to have a storage account provisioned alongside an event hub to facilitate reading from an event hub.)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bicep",children:"// Create a storage account\n\nvar storageAccountName = 'stdemo'\n\nresource eventHubNamespaceName_storageAccount 'Microsoft.Storage/storageAccounts@2021-02-01' = {\n  name: storageAccountName\n  location: resourceGroup().location\n  sku: {\n    name: 'Standard_LRS'\n    tier: 'Standard'\n  }\n  kind: 'StorageV2'\n  properties: {\n    networkAcls: {\n      bypass: 'AzureServices'\n      defaultAction: 'Allow'\n    }\n    accessTier: 'Hot'\n    allowBlobPublicAccess: false\n    minimumTlsVersion: 'TLS1_2'\n    allowSharedKeyAccess: true\n  }\n}\n\n// create a container inside that storage account\n\nvar blobContainerName = 'test-container'\n\nresource storageAccountName_default_containerName 'Microsoft.Storage/storageAccounts/blobServices/containers@2021-02-01' = {\n  name: '${storageAccountName}/default/${blobContainerName}'\n  dependsOn: [\n    eventHubNamespaceName_storageAccount\n  ]\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"When this is deployed to Azure, it will result in creating something like this:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"screenshot of storage account access keys in the Azure Portal",src:t(44628).A+"",width:"2358",height:"1460",loading:"lazy"})}),"\n",(0,a.jsx)(n.p,{children:"Again we can see, there are connection strings available in the Azure Portal, which can be used to access the storage account. However, things aren't quite as simple as previously; in that there doesn't seem to be a way to directly acquire a connection string. What we can do, is acquire a key; and construct ourselves a connection string with that. Here's how:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bicep",children:"// Determine our connection string\n\nvar blobStorageConnectionString = 'DefaultEndpointsProtocol=https;AccountName=${eventHubNamespaceName_storageAccount.name};EndpointSuffix=${environment().suffixes.storage};AccountKey=${listKeys(eventHubNamespaceName_storageAccount.id, eventHubNamespaceName_storageAccount.apiVersion).keys[0].value}'\n\n// Output our variable\n\noutput blobStorageConnectionString string = blobStorageConnectionString\noutput blobContainerName string = blobContainerName\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you just wanted to know how to acquire connection strings from Bicep then you can stop now; we're done! But if you're curious on how the Bicep might connect to ",(0,a.jsx)(n.del,{children:"the shoulder"})," Azure Pipelines... Read on."]}),"\n",(0,a.jsx)(n.h2,{id:"from-bicep-to-azure-pipelines",children:"From Bicep to Azure Pipelines"}),"\n",(0,a.jsx)(n.p,{children:"If we put together our snippets above into a single Bicep file it would look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bicep",children:"// Create an event hub namespace\n\nvar eventHubNamespaceName = 'evhns-demo'\n\nresource eventHubNamespace 'Microsoft.EventHub/namespaces@2021-01-01-preview' = {\n  name: eventHubNamespaceName\n  location: resourceGroup().location\n  sku: {\n    name: 'Standard'\n    tier: 'Standard'\n    capacity: 1\n  }\n  properties: {\n    zoneRedundant: true\n  }\n}\n\n// Create an event hub inside the namespace\n\nvar eventHubName = 'evh-demo'\n\nresource eventHubNamespaceName_eventHubName 'Microsoft.EventHub/namespaces/eventhubs@2021-01-01-preview' = {\n  parent: eventHubNamespace\n  name: eventHubName\n  properties: {\n    messageRetentionInDays: 7\n    partitionCount: 1\n  }\n}\n\n// Grant Listen and Send on our event hub\n\nresource eventHubNamespaceName_eventHubName_ListenSend 'Microsoft.EventHub/namespaces/eventhubs/authorizationRules@2021-01-01-preview' = {\n  parent: eventHubNamespaceName_eventHubName\n  name: 'ListenSend'\n  properties: {\n    rights: [\n      'Listen'\n      'Send'\n    ]\n  }\n  dependsOn: [\n    eventHubNamespace\n  ]\n}\n\n// Create a storage account\n\nvar storageAccountName = 'stdemo'\n\nresource eventHubNamespaceName_storageAccount 'Microsoft.Storage/storageAccounts@2021-02-01' = {\n  name: storageAccountName\n  location: resourceGroup().location\n  sku: {\n    name: 'Standard_LRS'\n    tier: 'Standard'\n  }\n  kind: 'StorageV2'\n  properties: {\n    networkAcls: {\n      bypass: 'AzureServices'\n      defaultAction: 'Allow'\n    }\n    accessTier: 'Hot'\n    allowBlobPublicAccess: false\n    minimumTlsVersion: 'TLS1_2'\n    allowSharedKeyAccess: true\n  }\n}\n\n// create a container inside that storage account\n\nvar blobContainerName = 'test-container'\n\nresource storageAccountName_default_containerName 'Microsoft.Storage/storageAccounts/blobServices/containers@2021-02-01' = {\n  name: '${storageAccountName}/default/${blobContainerName}'\n  dependsOn: [\n    eventHubNamespaceName_storageAccount\n  ]\n}\n\n// Determine our connection strings\n\nvar blobStorageConnectionString       = 'DefaultEndpointsProtocol=https;AccountName=${eventHubNamespaceName_storageAccount.name};EndpointSuffix=${environment().suffixes.storage};AccountKey=${listKeys(eventHubNamespaceName_storageAccount.id, eventHubNamespaceName_storageAccount.apiVersion).keys[0].value}'\nvar eventHubNamespaceConnectionString = listKeys(eventHubNamespaceName_eventHubName_ListenSend.id, eventHubNamespaceName_eventHubName_ListenSend.apiVersion).primaryConnectionString\n\n// Output our variables\n\noutput blobStorageConnectionString string = blobStorageConnectionString\noutput blobContainerName string = blobContainerName\noutput eventHubNamespaceConnectionString string = eventHubNamespaceConnectionString\noutput eventHubName string = eventHubName\n"})}),"\n",(0,a.jsx)(n.p,{children:"This might be consumed in an Azure Pipeline that looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yml",children:"- bash: az bicep build --file infra/our-test-app/main.bicep\n  displayName: 'Compile Bicep to ARM'\n\n- task: AzureResourceManagerTemplateDeployment@3\n  name: DeploySharedInfra\n  displayName: Deploy Shared ARM Template\n  inputs:\n    deploymentScope: Resource Group\n    azureResourceManagerConnection: ${{ parameters.serviceConnection }}\n    subscriptionId: $(subscriptionId)\n    action: Create Or Update Resource Group\n    resourceGroupName: $(azureResourceGroup)\n    location: $(location)\n    templateLocation: Linked artifact\n    csmFile: 'infra/our-test-app/main.json' # created by bash script\n    deploymentMode: Incremental\n    deploymentOutputs: deployOutputs\n\n- task: PowerShell@2\n  name: 'SetOutputVariables'\n  displayName: 'Set Output Variables'\n  inputs:\n    targetType: inline\n    script: |\n      $armOutputObj = '$(deployOutputs)' | ConvertFrom-Json\n      $armOutputObj.PSObject.Properties | ForEach-Object {\n        $keyname = $_.Name\n        $value = $_.Value.value\n\n        # Creates a standard pipeline variable\n        Write-Output \"##vso[task.setvariable variable=$keyName;]$value\"\n\n        # Creates an output variable\n        Write-Output \"##vso[task.setvariable variable=$keyName;issecret=true;isOutput=true]$value\"\n\n        # Display keys in pipeline\n        Write-Output \"output variable: $keyName\"\n      }\n    pwsh: true\n"})}),"\n",(0,a.jsx)(n.p,{children:"Above we can see:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the Bicep get compiled to ARM"}),"\n",(0,a.jsxs)(n.li,{children:["the ARM is deployed to Azure, with ",(0,a.jsx)(n.code,{children:"deploymentOutputs"})," being passed out at the end"]}),"\n",(0,a.jsx)(n.li,{children:"the outputs are turned into secret output variables inside the pipeline (the names of which are printed to the console)"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["With the above in place, we now have all of our variables in place; ",(0,a.jsx)(n.code,{children:"blobStorageConnectionString"}),", ",(0,a.jsx)(n.code,{children:"blobContainerName"}),", ",(0,a.jsx)(n.code,{children:"eventHubNamespaceConnectionString"})," and ",(0,a.jsx)(n.code,{children:"eventHubName"}),". These could now be consumed in whatever way is useful. Consider the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yml",children:"- task: UseDotNet@2\n  displayName: 'Install .NET Core SDK 3.1.x'\n  inputs:\n    packageType: 'sdk'\n    version: 3.1.x\n\n- task: DotNetCoreCLI@2\n  displayName: 'dotnet run eventhub test'\n  inputs:\n    command: 'run'\n    arguments: 'eventhub test --eventHubNamespaceConnectionString \"$(eventHubNamespaceConnectionString)\" --eventHubName \"$(eventHubName)\" --blobStorageConnectionString \"$(blobStorageConnectionString)\" --blobContainerName \"$(blobContainerName)\"'\n    workingDirectory: '$(Build.SourcesDirectory)/OurTestApp'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here we run a .NET application and pass it our connection strings. Please note, there's nothing .NET specific about what we're doing above - it could be any kind of application, bash script or similar that consumes our connection strings. The significant thing is that we can acquire connection strings in an automated fashion, for use in whichever manner pleases us."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},29914:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/title-image-674ca0e9fcf44f133fd835cefe4888e2.png"},47195:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/event-hub-connection-string-c332b535fe5ae987d0b5095cbc7e08de.webp"},44628:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/storage-account-access-keys-eb71c62a744303169c7c0679f95bd9e5.png"},54447:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/title-image-674ca0e9fcf44f133fd835cefe4888e2.png"},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(96540);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);