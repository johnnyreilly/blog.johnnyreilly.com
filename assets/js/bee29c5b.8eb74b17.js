"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[70184],{21977:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var n=t(74848),l=t(28453);const o={slug:"jquery-validation-globalize-hits-10",title:"jQuery Validation Globalize hits 1.0",authors:"johnnyreilly",tags:["globalize","jquery"],hide_table_of_contents:!1,description:"jQuery Validation Globalize plugin now supports Globalize 1.x, with minor code changes. Users can customize date parsing format."},i=void 0,r={permalink:"/jquery-validation-globalize-hits-10",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2015-10-05-jquery-validation-globalize-hits-10/index.md",source:"@site/blog/2015-10-05-jquery-validation-globalize-hits-10/index.md",title:"jQuery Validation Globalize hits 1.0",description:"jQuery Validation Globalize plugin now supports Globalize 1.x, with minor code changes. Users can customize date parsing format.",date:"2015-10-05T00:00:00.000Z",tags:[{label:"globalize",permalink:"/tags/globalize"},{label:"jquery",permalink:"/tags/jquery"}],readingTime:2.87,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"jquery-validation-globalize-hits-10",title:"jQuery Validation Globalize hits 1.0",authors:"johnnyreilly",tags:["globalize","jquery"],hide_table_of_contents:!1,description:"jQuery Validation Globalize plugin now supports Globalize 1.x, with minor code changes. Users can customize date parsing format."},unlisted:!1,prevItem:{title:"The Names Have Been Changed...",permalink:"/the-names-have-been-changed"},nextItem:{title:"Definitely Typed Shouldn't Exist",permalink:"/authoring-npm-modules-with-typescript"}},s={authorsImageUrls:[void 0]},d=[];function h(e){const a={a:"a",code:"code",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(a.p,{children:["This is just a quick post - the tl;dr is this: jQuery Validation Globalize has been ported to Globalize 1.x. Yay! In one of those twists of fate I'm not actually using this plugin in my day job anymore but I thought it might be useful to other people. So here you go. You can read more about this plugin in an ",(0,n.jsx)(a.a,{href:"/globalize-and-jquery-validate",children:"older post"})," and you can see a demo of it in action ",(0,n.jsx)(a.a,{href:"http://johnnyreilly.github.io/jQuery.Validation.Unobtrusive.Native/AdvancedDemo/Globalize.html",children:"here"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["The code did not change drastically - essentially it was just a question of swapping ",(0,n.jsx)(a.code,{children:"parseFloat"})," for ",(0,n.jsx)(a.code,{children:"parseNumber"})," and ",(0,n.jsx)(a.code,{children:"parseDate"})," for a slightly different ",(0,n.jsx)(a.code,{children:"parseDate"}),". So, we went from this:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",children:"(function ($, Globalize) {\n  // Clone original methods we want to call into\n  var originalMethods = {\n    min: $.validator.methods.min,\n    max: $.validator.methods.max,\n    range: $.validator.methods.range,\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize\n\n  $.validator.methods.number = function (value, element) {\n    var val = Globalize.parseFloat(value);\n    return this.optional(element) || $.isNumeric(val);\n  };\n\n  // Tell the validator that we want dates parsed using Globalize\n\n  $.validator.methods.date = function (value, element) {\n    var val = Globalize.parseDate(value);\n    return this.optional(element) || val instanceof Date;\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize,\n  // then call into original implementation with parsed value\n\n  $.validator.methods.min = function (value, element, param) {\n    var val = Globalize.parseFloat(value);\n    return originalMethods.min.call(this, val, element, param);\n  };\n\n  $.validator.methods.max = function (value, element, param) {\n    var val = Globalize.parseFloat(value);\n    return originalMethods.max.call(this, val, element, param);\n  };\n\n  $.validator.methods.range = function (value, element, param) {\n    var val = Globalize.parseFloat(value);\n    return originalMethods.range.call(this, val, element, param);\n  };\n})(jQuery, Globalize);\n"})}),"\n",(0,n.jsx)(a.p,{children:"To this:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",children:"(function ($, Globalize) {\n  // Clone original methods we want to call into\n  var originalMethods = {\n    min: $.validator.methods.min,\n    max: $.validator.methods.max,\n    range: $.validator.methods.range,\n  };\n\n  // Globalize options - initially just the date format used for parsing\n  // Users can customise this to suit them\n  $.validator.methods.dateGlobalizeOptions = {\n    dateParseFormat: { skeleton: 'yMd' },\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize\n  $.validator.methods.number = function (value, element) {\n    var val = Globalize.parseNumber(value);\n    return this.optional(element) || $.isNumeric(val);\n  };\n\n  // Tell the validator that we want dates parsed using Globalize\n  $.validator.methods.date = function (value, element) {\n    var val = Globalize.parseDate(\n      value,\n      $.validator.methods.dateGlobalizeOptions.dateParseFormat,\n    );\n    return this.optional(element) || val instanceof Date;\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize,\n  // then call into original implementation with parsed value\n\n  $.validator.methods.min = function (value, element, param) {\n    var val = Globalize.parseNumber(value);\n    return originalMethods.min.call(this, val, element, param);\n  };\n\n  $.validator.methods.max = function (value, element, param) {\n    var val = Globalize.parseNumber(value);\n    return originalMethods.max.call(this, val, element, param);\n  };\n\n  $.validator.methods.range = function (value, element, param) {\n    var val = Globalize.parseNumber(value);\n    return originalMethods.range.call(this, val, element, param);\n  };\n})(jQuery, Globalize);\n"})}),"\n",(0,n.jsxs)(a.p,{children:["All of which is pretty self-explanatory. The only thing I'd like to draw out is that Globalize 0.1.x didn't force you to specify a date parsing format and, as I recall, would attempt various methods of parsing. For that reason jQuery Validation Globalize 1.0 exposes a ",(0,n.jsx)(a.code,{children:"$.validator.methods.dateGlobalizeOptions"})," which allows you to specify the data parsing format you want to use. This means, should you be using a different format than the out of the box one then you can tweak it like so:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",children:"$.validator.methods.dateGlobalizeOptions.dateParseFormat = // your data parsing format goes here...\n"})}),"\n",(0,n.jsx)(a.p,{children:"Theoretically, this functionality could be tweaked to allow the user to specify multiple possible date parsing formats to attempt. I'm not certain if that's a good idea though, so it remains unimplemented for now."})]})}function u(e={}){const{wrapper:a}={...(0,l.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>i,x:()=>r});var n=t(96540);const l={},o=n.createContext(l);function i(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);