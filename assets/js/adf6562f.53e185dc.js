"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[41387],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),l=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=l(e.components);return a.createElement(p.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(t),m=r,g=u["".concat(p,".").concat(m)]||u[m]||d[m]||i;return t?a.createElement(g,o(o({ref:n},c),{},{components:t})):a.createElement(g,o({ref:n},c))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},95613:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>c});t(67294);var a=t(3905);function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r.apply(this,arguments)}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}const o={title:"Azure Container Apps: dapr pubsub",authors:"johnnyreilly",tags:["Azure Container Apps","dapr","publish & subscribe","Bicep","GitHub Actions","GitHub container registry","devcontainer","debug"],image:"./title-image.png",hide_table_of_contents:!1},s=void 0,p={permalink:"/2022/06/21/azure-container-apps-pubsub",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2022-06-21-azure-container-apps-pubsub/index.md",source:"@site/blog/2022-06-21-azure-container-apps-pubsub/index.md",title:"Azure Container Apps: dapr pubsub",description:"This post shows how to build and deploy two Azure Container Apps using Bicep and GitHub Actions. These apps will communicate using dapr's publish & subscribe (pubsub) building block.",date:"2022-06-21T00:00:00.000Z",formattedDate:"June 21, 2022",tags:[{label:"Azure Container Apps",permalink:"/tags/azure-container-apps"},{label:"dapr",permalink:"/tags/dapr"},{label:"publish & subscribe",permalink:"/tags/publish-subscribe"},{label:"Bicep",permalink:"/tags/bicep"},{label:"GitHub Actions",permalink:"/tags/git-hub-actions"},{label:"GitHub container registry",permalink:"/tags/git-hub-container-registry"},{label:"devcontainer",permalink:"/tags/devcontainer"},{label:"debug",permalink:"/tags/debug"}],readingTime:20.72,hasTruncateMarker:!1,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{title:"Azure Container Apps: dapr pubsub",authors:"johnnyreilly",tags:["Azure Container Apps","dapr","publish & subscribe","Bicep","GitHub Actions","GitHub container registry","devcontainer","debug"],image:"./title-image.png",hide_table_of_contents:!1},prevItem:{title:"Azure Static Web Apps: Failed to deploy the Azure Functions",permalink:"/2022/07/07/static-web-apps-failed-to-deploy-the-azure-functions"},nextItem:{title:"TypeScript 4.7 and ECMAScript Module Support",permalink:"/2022/06/07/typescript-4-7-and-ecmascript-module-support"}},l={image:t(48150).Z,authorsImageUrls:[void 0]},c=[{value:"You got mail: service invocation",id:"you-got-mail-service-invocation",level:2},{value:".NET meet mailgun",id:"net-meet-mailgun",level:3},{value:"Webservice gets a form",id:"webservice-gets-a-form",level:3},{value:"Secrets in Bicep",id:"secrets-in-bicep",level:3},{value:"You got mail: pubsub!",id:"you-got-mail-pubsub",level:2},{value:"Publishing with dapr-client",id:"publishing-with-dapr-client",level:3},{value:"Subscribing",id:"subscribing",level:3},{value:"Components",id:"components",level:3},{value:"<code>pubsub.yaml</code>",id:"pubsubyaml",level:4},{value:"<code>statestore.yaml</code>",id:"statestoreyaml",level:4},{value:"<code>subscription.yaml</code>",id:"subscriptionyaml",level:4},{value:"Bicep",id:"bicep",level:3},{value:"No declarative pubsub subscription support",id:"no-declarative-pubsub-subscription-support",level:3},{value:"You got mail: programmatic subscriptions!",id:"you-got-mail-programmatic-subscriptions",level:2}],u={toc:c};function d(e){var{components:n}=e,o=i(e,["components"]);return(0,a.kt)("wrapper",r({},u,o,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This post shows how to build and deploy two Azure Container Apps using Bicep and GitHub Actions. These apps will communicate using ",(0,a.kt)("a",r({parentName:"p"},{href:"https://docs.dapr.io/"}),"dapr"),"'s ",(0,a.kt)("a",r({parentName:"p"},{href:"https://docs.dapr.io/developing-applications/building-blocks/pubsub/howto-publish-subscribe/"}),"publish & subscribe (pubsub) building block"),"."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"title image reading &quot;Azure Container Apps: dapr pubsub&quot;  with the dapr, Bicep, Azure Container Apps and GitHub Actions logos",src:t(48150).Z,width:"1600",height:"900"})),(0,a.kt)("p",null,"This post will build upon code written in a ",(0,a.kt)("a",r({parentName:"p"},{href:"/2022/01/22/azure-container-apps-dapr-bicep-github-actions-debug-devcontainer"}),"previous post")," which built and deployed a simple web application to Azure Container Apps using Bicep and GitHub Actions using the GitHub container registry. Behind the scenes, that app was made up of a .NET app and a Node.js app communicating via dapr's ",(0,a.kt)("a",r({parentName:"p"},{href:"https://docs.dapr.io/developing-applications/building-blocks/service-invocation/howto-invoke-discover-services/"}),"service invocation building block"),"."),(0,a.kt)("p",null,"There's a good chance you've just googled \"pubsub dapr azure container apps\" and you don't want to read through all this. You just want the code. That's fine. The code for this blogpost is ",(0,a.kt)("a",r({parentName:"p"},{href:"https://github.com/johnnyreilly/dapr-devcontainer-debug-and-deploy/releases/tag/v2.0.0"}),"here"),"."),(0,a.kt)("h2",r({},{id:"you-got-mail-service-invocation"}),"You got mail: service invocation"),(0,a.kt)("p",null,"Right now we have a:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Node.js web app and a"),(0,a.kt)("li",{parentName:"ul"},".NET app")),(0,a.kt)("p",null,"The web app, when called, uses dapr service invocation to acquire a weather forecast from a .NET app."),(0,a.kt)("p",null,"What we want to investigate is dapr's pubsub building block. But pubsub doesn't really \"fit\" into our current app. Let's alter it. Instead of showing users a weather forecast when they browse to the site, we'll instead look for our users to provide an email address, and we'll mail them a weather forecast."),(0,a.kt)("p",null,"This kind of app could work both using dapr service invocation or using pubsub. We're going to implement using our current service invocation approach first. Once that works, we'll then pivot that into using dapr pubsub."),(0,a.kt)("p",null,"This isn't rocket surgery; this is playing around with dapr and Azure Container Apps and seeing how they all hang together."),(0,a.kt)("h3",r({},{id:"net-meet-mailgun"}),".NET meet mailgun"),(0,a.kt)("p",null,"Our existing .NET app needs the ability to send email. For that we're going to reach for ",(0,a.kt)("a",r({parentName:"p"},{href:"https://app.mailgun.com/app/dashboard"}),"mailgun"),", and we'll use ",(0,a.kt)("a",r({parentName:"p"},{href:"https://restsharp.dev/"}),"RestSharp")," to call it. Let's add RestSharp as a dependency:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-shell"}),"dotnet add package RestSharp\n")),(0,a.kt)("p",null,"With that in place, let's turn to our ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastController")," and make it send an email."),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'using Config;\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\n\nusing RestSharp;\nusing RestSharp.Authenticators;\n\nnamespace WeatherService.Controllers;\n\n[ApiController]\npublic class WeatherForecastController : ControllerBase\n{\n    private static readonly string[] Summaries = new[]\n    {\n        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"\n    };\n\n    private readonly ILogger<WeatherForecastController> _logger;\n    private readonly MailConfig _options;\n\n    public WeatherForecastController(\n        ILogger<WeatherForecastController> logger,\n        IOptions<MailConfig> options\n    )\n    {\n        _logger = logger;\n        _options = options.Value;\n    }\n\n    public record SendWeatherForecastBody(string? Email);\n\n    [HttpPost("SendWeatherForecast")]\n    public async Task<string> SendWeatherForecast(SendWeatherForecastBody body)\n    {\n        try\n        {\n            if (string.IsNullOrEmpty(body.Email)) throw new Exception("Email required");\n\n            var weatherForecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = Random.Shared.Next(-20, 55),\n                Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n            })\n            .ToArray();\n\n            var toEmailAddress = body.Email;\n            var text = $@"The weather forecast is:\n\n{string.Join("\\n", weatherForecast.Select(wf => $"On {wf.Date} the weather will be {wf.Summary}"))}\n";\n\n            await SendSimpleMessage(\n                toEmailAddress: toEmailAddress,\n                text: text\n            );\n\n            return $"We have mailed {toEmailAddress} with the following:\\n\\n{text}";\n        }\n        catch (Exception exc)\n        {\n            _logger.LogError(exc, $"Problem!");\n\n            return exc.Message;\n        }\n    }\n\n    async Task<RestResponse> SendSimpleMessage(string toEmailAddress, string text)\n    {\n        RestClient client = new(new RestClientOptions\n        {\n            BaseUrl = new Uri("https://api.mailgun.net/v3")\n        })\n        {\n            Authenticator =\n            new HttpBasicAuthenticator("api", _options.MailgunApiKey)\n        };\n        RestRequest request = new();\n        request.AddParameter("domain", "mg.priou.co.uk", ParameterType.UrlSegment);\n        request.Resource = "{domain}/messages";\n        request.AddParameter("from", "John Reilly <johnny_reilly@hotmail.com>");\n        request.AddParameter("to", toEmailAddress);\n        request.AddParameter("subject", "Weather forecast");\n        request.AddParameter("text", text);\n\n        return await client.PostAsync(request);\n    }\n}\n')),(0,a.kt)("p",null,"In our new and improved controller we:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Switch our ",(0,a.kt)("inlineCode",{parentName:"li"},"GET")," endpoint to be a ",(0,a.kt)("inlineCode",{parentName:"li"},"POST")," one instead, to reflect that we're going to take an action (sending an email) each time it's hit. (RESTful to the end)"),(0,a.kt)("li",{parentName:"ul"},"Rather than returning the weather forecast to our caller, we take the email address supplied and we send the weather forecast to it")),(0,a.kt)("p",null,"You'll also notice we're passing a ",(0,a.kt)("inlineCode",{parentName:"p"},"IOptions<MailConfig>")," to the constructor of our class, it's in this configuration object we store our Mailgun api key. So we're going to need to define a ",(0,a.kt)("inlineCode",{parentName:"p"},"MailConfig")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),"public class MailConfig\n{\n    public string MailgunApiKey { get; set; } = string.Empty;\n}\n")),(0,a.kt)("p",null,"And we need to update our ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," so it recognises ",(0,a.kt)("inlineCode",{parentName:"p"},"MailConfig")," and configures it:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'var builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<MailConfig>(builder.Configuration.GetSection("Mail"));\n// ...\n')),(0,a.kt)("p",null,"Thanks to the default setup of .NET, we'll now be able to populate this using ",(0,a.kt)("inlineCode",{parentName:"p"},"appsettings.json")," files and environment variables. Since our API key is a secret we'll avoid putting it in source control, and instead populate an environment variable that .NET can read:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{}),"MAIL__MAILGUNAPIKEY=key-goes-here\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"__")," above is the convention that .NET follows for nesting with environment variables; this is equivalent to the following structure in an ",(0,a.kt)("inlineCode",{parentName:"p"},"appsettings.json")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-json"}),'{\n  "Mail": {\n    "MailgunApiKey": "api-key-goes-here"\n  }\n  // ...\n}\n')),(0,a.kt)("h3",r({},{id:"webservice-gets-a-form"}),"Webservice gets a form"),(0,a.kt)("p",null,"Now that we've tweaked our WeatherService, we need to tweak the web site that calls it. We'll do that by first adding some dependencies that allow our Koa web service to handle routing a little easier:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-shell"}),"npm install @koa/router koa-body --save\nnpm install @types/koa__router --save-dev\n")),(0,a.kt)("p",null,"Then we'll tweak our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.ts")," like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-ts"}),"import Koa from 'koa';\nimport Router from '@koa/router';\nimport koaBody from 'koa-body';\nimport axios from 'axios';\n\n// How we connect to the dotnet service with dapr\nconst daprSidecarBaseUrl = `http://localhost:${\n  process.env.DAPR_HTTP_PORT || 3501\n}`;\n// app id header for service discovery\nconst weatherServiceAppIdHeaders = {\n  'dapr-app-id': process.env.WEATHER_SERVICE_NAME || 'dotnet-app',\n};\n\nconst app = new Koa();\nconst router = new Router();\n\napp.use(async (ctx, next) => {\n  try {\n    await next();\n    const status = ctx.status || 404;\n    if (status === 404) ctx.throw(404);\n  } catch (err: any) {\n    ctx.status = err.status || 500;\n    ctx.body = ctx.status === 404 ? 'not found alas' : `hmmm: ${ctx.status}`;\n  }\n});\n\nconst formHtml = (header: string) => `<!DOCTYPE html>\n<html>\n<head>\n<title>Email me!</title>\n</head>\n<body>\n<form method=\"post\">\n    <h1>${header}</h1>\n    <label for=\"email\">Enter your email:</label>\n    <input type=\"email\" id=\"email\" name=\"email\" required>\n    <button type=\"submit\">Submit</button>\n</form>\n</body>\n</html>\n`;\n\nrouter.get('/', async (ctx, next) => {\n  ctx.body = formHtml(\"We'd like to email you\");\n});\n\nrouter.post('/', koaBody(), async (ctx, next) => {\n  try {\n    if (ctx.request.body.email) {\n      await axios.post(\n        `${daprSidecarBaseUrl}/SendWeatherForecast`,\n        {\n          email: ctx.request.body.email,\n        },\n        {\n          headers: weatherServiceAppIdHeaders,\n        }\n      );\n\n      ctx.body = formHtml('Message sent');\n    } else {\n      ctx.body = formHtml('No email supplied');\n    }\n  } catch (exc) {\n    console.error('Problem calling weather service', exc);\n    ctx.body = 'Something went wrong!';\n  }\n});\n\napp.use(router.routes()).use(router.allowedMethods());\n\nconst portNumber = 3000;\napp.listen(portNumber);\nconsole.log(`listening on port ${portNumber}`);\n")),(0,a.kt)("p",null,"The above leaves us with a very simple form based web app that sends an email containing weather forecast:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"A gif that demos entering an email address in the form, submitting it and seeing an email arrive with a weather forecast in",src:t(79924).Z,width:"1460",height:"858"})),(0,a.kt)("h3",r({},{id:"secrets-in-bicep"}),"Secrets in Bicep"),(0,a.kt)("p",null,"Whilst we can run locally, we want to be able to deploy this. So we need to update our Bicep template to receive a ",(0,a.kt)("inlineCode",{parentName:"p"},"MAIL__MAILGUNAPIKEY")," parameter:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-bicep"}),"param branchName string\n\nparam webServiceImage string\nparam webServicePort int\nparam webServiceIsExternalIngress bool\n\nparam weatherServiceImage string\nparam weatherServicePort int\nparam weatherServiceIsExternalIngress bool\n\nparam containerRegistry string\nparam containerRegistryUsername string\n@secure()\nparam containerRegistryPassword string\n\nparam tags object\n\n@secure()\nparam MAIL__MAILGUNAPIKEY string\n\nparam location string = resourceGroup().location\nvar minReplicas = 1\nvar maxReplicas = 1\n\nvar branch = toLower(last(split(branchName, '/')))\n\nvar environmentName = '${branch}-env'\nvar workspaceName = '${branch}-log-analytics'\nvar appInsightsName = '${branch}-app-insights'\nvar webServiceContainerAppName = '${branch}-web'\nvar weatherServiceContainerAppName = '${branch}-weather'\n\nvar containerRegistryPasswordRef = 'container-registry-password'\nvar mailgunApiKeyRef = 'mailgun-api-key'\n\nresource workspace 'Microsoft.OperationalInsights/workspaces@2021-12-01-preview' = {\n  name: workspaceName\n  location: location\n  tags: tags\n  properties: {\n    sku: {\n      name: 'PerGB2018'\n    }\n    retentionInDays: 30\n    workspaceCapping: {}\n  }\n}\n\nresource appInsights 'Microsoft.Insights/components@2020-02-02' = {\n  name: appInsightsName\n  location: location\n  tags: tags\n  kind: 'web'\n  properties: {\n    Application_Type: 'web'\n    Flow_Type: 'Bluefield'\n  }\n}\n\nresource environment 'Microsoft.App/managedEnvironments@2022-01-01-preview' = {\n  name: environmentName\n  location: location\n  tags: tags\n  properties: {\n    daprAIInstrumentationKey: appInsights.properties.InstrumentationKey\n    appLogsConfiguration: {\n      destination: 'log-analytics'\n      logAnalyticsConfiguration: {\n        customerId: workspace.properties.customerId\n        sharedKey: listKeys(workspace.id, workspace.apiVersion).primarySharedKey\n      }\n    }\n  }\n}\n\nresource weatherServiceContainerApp 'Microsoft.App/containerApps@2022-01-01-preview' = {\n  name: weatherServiceContainerAppName\n  tags: tags\n  location: location\n  properties: {\n    kubeEnvironmentId: environment.id\n    configuration: {\n      secrets: [\n        {\n          name: containerRegistryPasswordRef\n          value: containerRegistryPassword\n        }\n        {\n          name: mailgunApiKeyRef\n          value: MAIL__MAILGUNAPIKEY\n        }\n      ]\n      registries: [\n        {\n          server: containerRegistry\n          username: containerRegistryUsername\n          passwordSecretRef: containerRegistryPasswordRef\n        }\n      ]\n      ingress: {\n        external: weatherServiceIsExternalIngress\n        targetPort: weatherServicePort\n      }\n    }\n    template: {\n      containers: [\n        {\n          image: weatherServiceImage\n          name: weatherServiceContainerAppName\n          env: [\n            {\n              name: 'MAIL__MAILGUNAPIKEY'\n              secretRef: mailgunApiKeyRef\n            }\n          ]\n        }\n      ]\n      scale: {\n        minReplicas: minReplicas\n        maxReplicas: maxReplicas\n      }\n      dapr: {\n        enabled: true\n        appPort: weatherServicePort\n        appId: weatherServiceContainerAppName\n      }\n    }\n  }\n}\n\nresource webServiceContainerApp 'Microsoft.App/containerApps@2022-01-01-preview' = {\n  name: webServiceContainerAppName\n  tags: tags\n  location: location\n  properties: {\n    kubeEnvironmentId: environment.id\n    configuration: {\n      secrets: [\n        {\n          name: containerRegistryPasswordRef\n          value: containerRegistryPassword\n        }\n      ]\n      registries: [\n        {\n          server: containerRegistry\n          username: containerRegistryUsername\n          passwordSecretRef: containerRegistryPasswordRef\n        }\n      ]\n      ingress: {\n        external: webServiceIsExternalIngress\n        targetPort: webServicePort\n      }\n    }\n    template: {\n      containers: [\n        {\n          image: webServiceImage\n          name: webServiceContainerAppName\n          env: [\n            {\n              name: 'WEATHER_SERVICE_NAME'\n              value: weatherServiceContainerAppName\n            }\n          ]\n        }\n      ]\n      scale: {\n        minReplicas: minReplicas\n        maxReplicas: maxReplicas\n      }\n      dapr: {\n        enabled: true\n        appPort: webServicePort\n        appId: webServiceContainerAppName\n      }\n    }\n  }\n}\n\noutput webServiceUrl string = webServiceContainerApp.properties.latestRevisionFqdn\n")),(0,a.kt)("p",null,"We can see that we treat the ",(0,a.kt)("inlineCode",{parentName:"p"},"MAIL__MAILGUNAPIKEY")," as a secret. It's passed in using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@secure")," decorator and it's configured as a secret inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"weatherServiceContainerApp")," Azure Container App."),(0,a.kt)("p",null,"We have a GitHub Action that handles our deployment. We'll need to introduce the ",(0,a.kt)("inlineCode",{parentName:"p"},"MAIL__MAILGUNAPIKEY")," secret both to the deploy step of the ",(0,a.kt)("inlineCode",{parentName:"p"},"build-and-deploy.yaml"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-yaml"}),'deploy:\n  runs-on: ubuntu-latest\n  needs: [build]\n  steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Azure Login\n      uses: azure/login@v1\n      with:\n        creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n    - name: Deploy bicep\n      uses: azure/CLI@v1\n      if: github.event_name != \'pull_request\'\n      with:\n        inlineScript: |\n          REF_SHA=\'${{ github.ref }}.${{ github.sha }}\'\n          DEPLOYMENT_NAME="${REF_SHA////-}"\n          echo "DEPLOYMENT_NAME=$DEPLOYMENT_NAME"\n\n          TAGS=\'{"owner":"johnnyreilly", "email":"johnny_reilly@hotmail.com"}\'\n          az deployment group create \\\n            --resource-group ${{ env.RESOURCE_GROUP }} \\\n            --name "$DEPLOYMENT_NAME" \\\n            --template-file ./infra/main.bicep \\\n            --parameters \\\n                branchName=\'${{ github.event.number == 0 && \'main\' ||  format(\'pr-{0}\', github.event.number) }}\' \\\n                webServiceImage=\'${{ needs.build.outputs.image-node }}\' \\\n                webServicePort=3000 \\\n                webServiceIsExternalIngress=true \\\n                weatherServiceImage=\'${{ needs.build.outputs.image-dotnet }}\' \\\n                weatherServicePort=5000 \\\n                weatherServiceIsExternalIngress=false \\\n                containerRegistry=${{ env.REGISTRY }} \\\n                containerRegistryUsername=${{ github.actor }} \\\n                containerRegistryPassword=${{ secrets.PACKAGES_TOKEN }} \\\n                tags="$TAGS" \\\n                MAIL__MAILGUNAPIKEY="${{ secrets.MAIL__MAILGUNAPIKEY }}"\n')),(0,a.kt)("p",null,"And we'll need to create the associated secret as well:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Screenshot of the secrets in the GitHub website that we need to create including MAIL__MAILGUNAPIKEY",src:t(87826).Z,width:"1586",height:"515"})),(0,a.kt)("h2",r({},{id:"you-got-mail-pubsub"}),"You got mail: pubsub!"),(0,a.kt)("p",null,"So we're now at the point where we have a pubsub style app - but still implemented using the service invocation approach. It's time to start migrating to using dapr's pubsub capabilities. Now, caveat emptor, pivoting from service invocation involves a fair amount of code. I'll try and be as brief as I can as we make the switch. However there will be big ol' lumps of code blocks as we do this. You may find it easier to just examine the finished code. I will in no way feel bad if that's the path you follow."),(0,a.kt)("h3",r({},{id:"publishing-with-dapr-client"}),"Publishing with dapr-client"),(0,a.kt)("p",null,"The first thing we need, is for our Node.js app to publish using the dapr pubsub mechanism. The easiest way to do that is with the ",(0,a.kt)("a",r({parentName:"p"},{href:"https://docs.dapr.io/developing-applications/sdks/js/"}),"dapr-client"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-shell"}),"npm install dapr-client --save\n")),(0,a.kt)("p",null,"We then switch out using axios to send our email command, to use ",(0,a.kt)("inlineCode",{parentName:"p"},"dapr-client")," instead:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-ts"}),"import Koa from 'koa';\nimport Router from '@koa/router';\nimport koaBody from 'koa-body';\n\nimport { DaprClient } from 'dapr-client';\n\nconst daprHost = 'localhost'; // Dapr Sidecar Host\nconst daprPort = `${process.env.DAPR_HTTP_PORT || 3501}`; // Dapr Sidecar Port\n\nconst client = new DaprClient(daprHost, daprPort);\n\nconst app = new Koa();\nconst router = new Router();\n\napp.use(async (ctx, next) => {\n  try {\n    await next();\n    const status = ctx.status || 404;\n    if (status === 404) ctx.throw(404);\n  } catch (err: any) {\n    ctx.status = err.status || 500;\n    ctx.body = ctx.status === 404 ? 'not found alas' : `hmmm: ${ctx.status}`;\n  }\n});\n\nconst formHtml = (header: string) => `<!DOCTYPE html>\n<html>\n<head>\n<title>Email me!</title>\n</head>\n<body>\n<form method=\"post\">\n    <h1>${header}</h1>\n    <label for=\"email\">Enter your email:</label>\n    <input type=\"email\" id=\"email\" name=\"email\" required>\n    <button type=\"submit\">Submit</button>\n</form>\n</body>\n</html>\n`;\n\nrouter.get('/', async (ctx, next) => {\n  ctx.body = formHtml(\"We'd like to email you\");\n});\n\nrouter.post('/', koaBody(), async (ctx, next) => {\n  try {\n    if (ctx.request.body.email) {\n      // Send a message\n      const sent = await client.pubsub.publish(\n        /* pubSubName */ 'weather-forecast-pub-sub',\n        /* topic */ 'weather-forecasts',\n        /* data */ {\n          email: ctx.request.body.email,\n        }\n      );\n\n      ctx.body = formHtml(`Message sent: ${sent}`);\n    } else {\n      ctx.body = formHtml('No email supplied');\n    }\n  } catch (exc) {\n    console.error('Problem calling weather service', exc);\n    ctx.body = 'Something went wrong!';\n  }\n});\n\napp.use(router.routes()).use(router.allowedMethods());\n\nconst portNumber = 3000;\napp.listen(portNumber);\nconsole.log(`listening on port ${portNumber}`);\n")),(0,a.kt)("p",null,"The thing to note above is the ",(0,a.kt)("inlineCode",{parentName:"p"},"client.pubsub.publish"),"; our WebService will now be publishing using pubsub, instead of using axios and service invocation."),(0,a.kt)("h3",r({},{id:"subscribing"}),"Subscribing"),(0,a.kt)("p",null,"Our WeatherService needs to be able to receive what is published. To make that happen, we'll make use of the following NuGet package in WeatherService:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-shell"}),"dotnet add package Dapr.AspNetCore --version 1.7.0\n")),(0,a.kt)("p",null,"Our ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," is adjusted to cater for this:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'using Config;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<MailConfig>(builder.Configuration.GetSection("Mail"));\n\nbuilder.Services.AddControllers().AddDapr();\n// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseAuthorization();\n\napp.UseCloudEvents();\n\napp.MapSubscribeHandler(); // This is the Dapr subscribe handler\napp.MapControllers();\n\napp.Run();\n')),(0,a.kt)("p",null,"The significant pieces above are:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),"builder.Services.AddControllers().AddDapr();\n\n// ...\n\napp.UseCloudEvents();\napp.MapSubscribeHandler(); // This is the Dapr subscribe handler\n")),(0,a.kt)("p",null,"We'll also need to update our ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastController.cs"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'using Config;\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\n\nusing RestSharp;\nusing RestSharp.Authenticators;\n\nusing Dapr;\n\nnamespace WeatherService.Controllers;\n\n[ApiController]\npublic class WeatherForecastController : ControllerBase\n{\n    private static readonly string[] Summaries = new[]\n    {\n        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"\n    };\n\n    private readonly ILogger<WeatherForecastController> _logger;\n    private readonly MailConfig _options;\n\n    public WeatherForecastController(\n        ILogger<WeatherForecastController> logger,\n        IOptions<MailConfig> options\n    )\n    {\n        _logger = logger;\n        _options = options.Value;\n    }\n\n    public record SendWeatherForecastBody(string? Email);\n\n    [Topic(pubsubName: "weather-forecast-pub-sub", name: "weather-forecasts")]\n    [HttpPost("SendWeatherForecast")]\n    public async Task<ActionResult<string>> SendWeatherForecast(SendWeatherForecastBody body)\n    {\n        try\n        {\n            if (string.IsNullOrEmpty(body.Email)) throw new Exception("Email required");\n\n            var weatherForecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = Random.Shared.Next(-20, 55),\n                Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n            })\n            .ToArray();\n\n            var toEmailAddress = body.Email;\n            var text = $@"The weather forecast is:\n\n{string.Join("\\n", weatherForecast.Select(wf => $"On {wf.Date} the weather will be {wf.Summary}"))}\n";\n\n            await SendSimpleMessage(\n                toEmailAddress: toEmailAddress,\n                text: text\n            );\n\n            return Ok($"We have mailed {toEmailAddress} with the following:\\n\\n{text})");\n        }\n        catch (Exception exc)\n        {\n            _logger.LogError(exc, $"Problem!");\n\n            return BadRequest(exc.Message);\n        }\n    }\n\n    async Task<RestResponse> SendSimpleMessage(string toEmailAddress, string text)\n    {\n        RestClient client = new(new RestClientOptions\n        {\n            BaseUrl = new Uri("https://api.mailgun.net/v3")\n        })\n        {\n            Authenticator =\n            new HttpBasicAuthenticator("api", _options.MailgunApiKey)\n        };\n        RestRequest request = new();\n        request.AddParameter("domain", "mg.priou.co.uk", ParameterType.UrlSegment);\n        request.Resource = "{domain}/messages";\n        request.AddParameter("from", "John Reilly <johnny_reilly@hotmail.com>");\n        request.AddParameter("to", toEmailAddress);\n        request.AddParameter("subject", "Weather forecast");\n        request.AddParameter("text", text);\n\n        return await client.PostAsync(request);\n    }\n}\n')),(0,a.kt)("p",null,"Really the only new thing here is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Topic")," attribute on the ",(0,a.kt)("inlineCode",{parentName:"p"},"SendWeatherForecast")," endpoint:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'[Topic(pubsubName: "weather-forecast-pub-sub", name: "weather-forecasts")]\n')),(0,a.kt)("p",null,"This is used (as you might imagine) to route messages."),(0,a.kt)("p",null,'The real difference to call out in what we\'ve done so far, is that both our publisher (Node.js) and our subscriber (.NET) have become "dapr aware". Although there have been changes in our code to achieve this, they have not been extensive. Noisy, yes. But not big changes.'),(0,a.kt)("h3",r({},{id:"components"}),"Components"),(0,a.kt)("p",null,"In order to communicate via pubsub, dapr needs some ",(0,a.kt)("a",r({parentName:"p"},{href:"https://docs.dapr.io/concepts/components-concept/"}),"components")," in place. We'll create a folder in the root of our project named ",(0,a.kt)("inlineCode",{parentName:"p"},"components"),", and in there create three files:"),(0,a.kt)("h4",r({},{id:"pubsubyaml"}),(0,a.kt)("inlineCode",{parentName:"h4"},"pubsub.yaml")),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-yml"}),"apiVersion: dapr.io/v1alpha1\nkind: Component\nmetadata:\n  name: weather-forecast-pub-sub\n  namespace: default\nspec:\n  type: pubsub.redis\n  version: v1\n  metadata:\n    - name: redisHost\n      value: localhost:6379\n    - name: redisPassword\n      value: ''\nscopes:\n  - node-app\n  - dotnet-app\n")),(0,a.kt)("h4",r({},{id:"statestoreyaml"}),(0,a.kt)("inlineCode",{parentName:"h4"},"statestore.yaml")),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-yml"}),"apiVersion: dapr.io/v1alpha1\nkind: Component\nmetadata:\n  name: statestore\n  namespace: default\nspec:\n  type: state.redis\n  version: v1\n  metadata:\n    - name: redisHost\n      value: localhost:6379\n    - name: redisPassword\n      value: ''\n    - name: actorStateStore\n      value: 'true'\n")),(0,a.kt)("h4",r({},{id:"subscriptionyaml"}),(0,a.kt)("inlineCode",{parentName:"h4"},"subscription.yaml")),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-yml"}),"apiVersion: dapr.io/v1alpha1\nkind: Subscription\nmetadata:\n  name: weather-forecast-pub-sub\nspec:\n  topic: weather-forecasts\n  route: /SendWeatherForecast\n  pubsubname: weather-forecast-pub-sub\nscopes:\n  - node-app\n  - dotnet-app\n")),(0,a.kt)("p",null,"These three files are fairly self-explanatory. It's worth drawing attention to the following though:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We're going to use these components when running locally and so we'll use Redis for our persistence. When we deploy to Azure Container Apps we'll use something more Azure specific."),(0,a.kt)("li",{parentName:"ol"},"We're granting access in these components to our node-app (WebService) and our dotnet-app (WeatherService)"),(0,a.kt)("li",{parentName:"ol"},"We're wiring up our subscription in ",(0,a.kt)("inlineCode",{parentName:"li"},"subscription.yaml"),"- it's this that will be used to route traffic from publishing to subscription.")),(0,a.kt)("p",null,"With the above in place we're almost ready to be able to run this locally and debug using VS Code. The final tweak is to make our apps aware of the dapr components. This is achieved by adding ",(0,a.kt)("inlineCode",{parentName:"p"},'"componentsPath": "./components",')," to the entries in our ",(0,a.kt)("inlineCode",{parentName:"p"},"tasks.json")," file. In full it looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-json"}),'{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  "version": "2.0.0",\n  "tasks": [\n    {\n      "label": "dotnet-build",\n      "command": "dotnet",\n      "type": "process",\n      "args": [\n        "build",\n        "${workspaceFolder}/WeatherService/WeatherService.csproj",\n        "/property:GenerateFullPaths=true",\n        "/consoleloggerparameters:NoSummary"\n      ],\n      "problemMatcher": "$msCompile"\n    },\n    {\n      "label": "daprd-debug-dotnet",\n      "appId": "dotnet-app",\n      "appPort": 5000,\n      "httpPort": 3500,\n      "grpcPort": 50000,\n      "metricsPort": 9090,\n      "componentsPath": "./components",\n      "type": "daprd",\n      "dependsOn": ["dotnet-build"]\n    },\n    {\n      "label": "daprd-down-dotnet",\n      "appId": "dotnet-app",\n      "type": "daprd-down"\n    },\n\n    {\n      "label": "npm-install",\n      "type": "shell",\n      "command": "npm install",\n      "options": {\n        "cwd": "${workspaceFolder}/WebService"\n      }\n    },\n    {\n      "label": "webservice-build",\n      "type": "typescript",\n      "tsconfig": "WebService/tsconfig.json",\n      "problemMatcher": ["$tsc"],\n      "group": {\n        "kind": "build",\n        "isDefault": true\n      },\n      "dependsOn": ["npm-install"]\n    },\n    {\n      "label": "daprd-debug-node",\n      "appId": "node-app",\n      "appPort": 3000,\n      "httpPort": 3501,\n      "grpcPort": 50001,\n      "metricsPort": 9091,\n      "componentsPath": "./components",\n      "type": "daprd",\n      "dependsOn": ["webservice-build"]\n    },\n    {\n      "label": "daprd-down-node",\n      "appId": "node-app",\n      "type": "daprd-down"\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"With this in place we're ready to run our apps locally using pubsub. We can publish from the WebService and receive in the WeatherService. This results in the expected email being sent, as we would hope."),(0,a.kt)("h3",r({},{id:"bicep"}),"Bicep"),(0,a.kt)("p",null,"The missing piece is Azure. How do we deploy this to Azure Container Apps? Well, we have everything we need to do this, save for the Bicep. We need to augment the Bicep we already have to include our Azure Container Apps dapr components. The full template looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-bicep"}),"param branchName string\n\nparam webServiceImage string\nparam webServicePort int\nparam webServiceIsExternalIngress bool\n\nparam weatherServiceImage string\nparam weatherServicePort int\nparam weatherServiceIsExternalIngress bool\n\nparam containerRegistry string\nparam containerRegistryUsername string\n@secure()\nparam containerRegistryPassword string\n\nparam tags object\n\n@secure()\nparam MAIL__MAILGUNAPIKEY string\n\nparam location string = resourceGroup().location\n\n@description('Storage Account type')\n@allowed([\n  'Premium_LRS'\n  'Premium_ZRS'\n  'Standard_GRS'\n  'Standard_GZRS'\n  'Standard_LRS'\n  'Standard_RAGRS'\n  'Standard_RAGZRS'\n  'Standard_ZRS'\n])\nparam storageAccountType string = 'Standard_LRS'\n\n@description('The name of the Storage Account')\nparam storageAccountName string = 'store${uniqueString(resourceGroup().id)}'\n\nparam serviceBusNamespace string = 'pubsub-namespace'\n\nresource storageAccount 'Microsoft.Storage/storageAccounts@2021-06-01' = {\n  name: storageAccountName\n  location: location\n  sku: {\n    name: storageAccountType\n  }\n  kind: 'StorageV2'\n  properties: {}\n}\n\nresource serviceBus 'Microsoft.ServiceBus/namespaces@2021-06-01-preview' = {\n  name: serviceBusNamespace\n  location: location\n}\n\nresource servicebus_authrule 'Microsoft.ServiceBus/namespaces/AuthorizationRules@2021-06-01-preview' existing = {\n  name: 'RootManageSharedAccessKey'\n  parent: serviceBus\n}\n\nresource topic 'Microsoft.ServiceBus/namespaces/topics@2021-06-01-preview' = {\n  name: 'weather-forecasts'\n  parent: serviceBus\n}\n\nvar minReplicas = 1\nvar maxReplicas = 1\n\nvar branch = toLower(last(split(branchName, '/')))\n\nvar environmentName = 'shared-env'\nvar workspaceName = '${branch}-log-analytics'\nvar appInsightsName = '${branch}-app-insights'\nvar webServiceContainerAppName = '${branch}-web'\nvar weatherServiceContainerAppName = '${branch}-weather'\n\nvar containerRegistryPasswordRef = 'container-registry-password'\nvar mailgunApiKeyRef = 'mailgun-api-key'\n\nresource workspace 'Microsoft.OperationalInsights/workspaces@2021-12-01-preview' = {\n  name: workspaceName\n  location: location\n  tags: tags\n  properties: {\n    sku: {\n      name: 'PerGB2018'\n    }\n    retentionInDays: 30\n    workspaceCapping: {}\n  }\n}\n\nresource appInsights 'Microsoft.Insights/components@2020-02-02' = {\n  name: appInsightsName\n  location: location\n  tags: tags\n  kind: 'web'\n  properties: {\n    Application_Type: 'web'\n    Flow_Type: 'Bluefield'\n  }\n}\n\nresource environment 'Microsoft.App/managedEnvironments@2022-01-01-preview' = {\n  name: environmentName\n  location: location\n  tags: tags\n  properties: {\n    daprAIInstrumentationKey: appInsights.properties.InstrumentationKey\n    appLogsConfiguration: {\n      destination: 'log-analytics'\n      logAnalyticsConfiguration: {\n        customerId: workspace.properties.customerId\n        sharedKey: listKeys(workspace.id, workspace.apiVersion).primarySharedKey\n      }\n    }\n  }\n  resource statestoreComponent 'daprComponents@2022-03-01' = {\n    name: 'statestore'\n    properties: {\n      componentType: 'state.azure.blobstorage'\n      version: 'v1'\n      ignoreErrors: false\n      initTimeout: '5s'\n      secrets: [\n        {\n          name: 'storageaccountkey'\n          value: listKeys(resourceId('Microsoft.Storage/storageAccounts/', storageAccount.name), storageAccount.apiVersion).keys[0].value\n        }\n      ]\n      metadata: [\n        {\n          name: 'accountName'\n          value: storageAccount.name\n        }\n        {\n          name: 'containerName'\n          value: 'storage_container_name'\n        }\n        {\n          name: 'accountKey'\n          secretRef: 'storageaccountkey'\n        }\n      ]\n      scopes: [\n        weatherServiceContainerAppName\n        webServiceContainerAppName\n      ]\n    }\n  }\n  resource pubsubComponent 'daprComponents@2022-03-01' = {\n    name: 'weather-forecast-pub-sub'\n    properties: {\n      componentType: 'pubsub.azure.servicebus'\n      version: 'v1'\n      metadata: [\n        {\n          name: 'connectionString'\n          secretRef: 'sb-root-connectionstring'\n        }\n      ]\n      secrets: [\n        {\n          name: 'sb-root-connectionstring'\n          value: listKeys('${serviceBus.id}/AuthorizationRules/RootManageSharedAccessKey', serviceBus.apiVersion).primaryConnectionString\n        }\n      ]\n      scopes: [\n        weatherServiceContainerAppName\n        webServiceContainerAppName\n      ]\n    }\n  }\n}\n\nresource weatherServiceContainerApp 'Microsoft.App/containerApps@2022-01-01-preview' = {\n  name: weatherServiceContainerAppName\n  tags: tags\n  location: location\n  properties: {\n    managedEnvironmentId: environment.id\n    configuration: {\n      dapr: {\n        enabled: true\n        appPort: weatherServicePort\n        appId: weatherServiceContainerAppName\n      }\n      secrets: [\n        {\n          name: containerRegistryPasswordRef\n          value: containerRegistryPassword\n        }\n        {\n          name: mailgunApiKeyRef\n          value: MAIL__MAILGUNAPIKEY\n        }\n      ]\n      registries: [\n        {\n          server: containerRegistry\n          username: containerRegistryUsername\n          passwordSecretRef: containerRegistryPasswordRef\n        }\n      ]\n      ingress: {\n        external: weatherServiceIsExternalIngress\n        targetPort: weatherServicePort\n      }\n    }\n    template: {\n      containers: [\n        {\n          image: weatherServiceImage\n          name: weatherServiceContainerAppName\n          env: [\n            {\n              name: 'MAIL__MAILGUNAPIKEY'\n              secretRef: mailgunApiKeyRef\n            }\n          ]\n        }\n      ]\n      scale: {\n        minReplicas: minReplicas\n        maxReplicas: maxReplicas\n      }\n    }\n  }\n}\n\nresource webServiceContainerApp 'Microsoft.App/containerApps@2022-01-01-preview' = {\n  name: webServiceContainerAppName\n  tags: tags\n  location: location\n  properties: {\n    managedEnvironmentId: environment.id\n    configuration: {\n      dapr: {\n        enabled: true\n        appPort: webServicePort\n        appId: webServiceContainerAppName\n      }\n      secrets: [\n        {\n          name: containerRegistryPasswordRef\n          value: containerRegistryPassword\n        }\n      ]\n      registries: [\n        {\n          server: containerRegistry\n          username: containerRegistryUsername\n          passwordSecretRef: containerRegistryPasswordRef\n        }\n      ]\n      ingress: {\n        external: webServiceIsExternalIngress\n        targetPort: webServicePort\n      }\n    }\n    template: {\n      containers: [\n        {\n          image: webServiceImage\n          name: webServiceContainerAppName\n          env: [\n            {\n              name: 'WEATHER_SERVICE_NAME'\n              value: weatherServiceContainerAppName\n            }\n          ]\n        }\n      ]\n      scale: {\n        minReplicas: minReplicas\n        maxReplicas: maxReplicas\n      }\n    }\n  }\n}\n\noutput webServiceUrl string = webServiceContainerApp.properties.latestRevisionFqdn\n")),(0,a.kt)("p",null,"Now this is undeniably a big lump of Bicep. Let's drill into the significant differences:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We're creating an Azure storage account."),(0,a.kt)("li",{parentName:"ol"},"We're creating an Azure Service Bus and a topic under it named ",(0,a.kt)("inlineCode",{parentName:"li"},"'weather-forecasts'"),"."),(0,a.kt)("li",{parentName:"ol"},"Underneath our managed environment, we're creating a statestore (using the storage account) which is the Azure equivalent of our ",(0,a.kt)("inlineCode",{parentName:"li"},"statestore.yml"),", but using Azure storage."),(0,a.kt)("li",{parentName:"ol"},"Also underneath our managed environment, we're creating a pubsub (using the service bus) which is the Azure equivalent of our ",(0,a.kt)("inlineCode",{parentName:"li"},"pubsub.yml"),", but using our Azure ServiceBus.")),(0,a.kt)("p",null,"It's also worth noting that we always have an instance of the services running; ",(0,a.kt)("inlineCode",{parentName:"p"},"minReplicas: 1"),". This is because when we dial it down to 0, the Weather Service will stop running. Probably there's a fancy KEDA trigger that prevents this; I haven't figured it out."),(0,a.kt)("h3",r({},{id:"no-declarative-pubsub-subscription-support"}),"No declarative pubsub subscription support"),(0,a.kt)("p",null,"Whilst you might be thinking \"we're home free now!\" - it turns out we're not. Whilst we'd created Azure equivalents of our ",(0,a.kt)("inlineCode",{parentName:"p"},"statestore.yml")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"pubsub.yml"),", you'll note there didn't seem to be an equivalent of the ",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions")," component in Bicep."),(0,a.kt)("p",null,(0,a.kt)("a",r({parentName:"p"},{href:"https://docs.microsoft.com/en-us/azure/container-apps/dapr-overview?tabs=bicep1%2Cyaml#known-limitations"}),"It turns out support for declarative pub/sub subscriptions is not yet available"),":"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Known limitations\nDeclarative pub/sub subscriptions")),(0,a.kt)("p",null,"So whilst we can take the code we have here and run locally, we cannot deploy it to Azure."),(0,a.kt)("p",null,"However, whilst there's no declaritive support for subscriptions, there is programmatic support. It involves more of a pivot in how we put together our code. But since it's the only game in town, we'll give it a go."),(0,a.kt)("h2",r({},{id:"you-got-mail-programmatic-subscriptions"}),"You got mail: programmatic subscriptions!"),(0,a.kt)("p",null,"We can get rid of our ",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions.yaml")," file now - we're going programmatic instead of declarative."),(0,a.kt)("p",null,"We're going to replace our ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastController.cs")," with a ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastEndpoints.cs")," which contains very similar code, but uses the .NET 6 minimal API approach instead: (There appears to be a way to work with MVC but it's not clear how to use it, and it appears to be a more confusing approach than the .NET 6 minimal API approach.)"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'using Config;\n\nusing Microsoft.Extensions.Options;\n\nusing RestSharp;\nusing RestSharp.Authenticators;\n\nusing Dapr;\n\nnamespace WeatherService.Endpoints;\n\npublic static class WeatherForecastEndpoints\n{\n    private static readonly string[] Summaries = new[]\n    {\n        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"\n    };\n\n    public record SendWeatherForecastBody(string? Email);\n\n    public static IEndpointRouteBuilder MapWeatherForecastEndpoints(this IEndpointRouteBuilder endpoints)\n    {\n        endpoints.MapPost("/SendWeatherForecast",\n            [Topic("weather-forecast-pub-sub", "weather-forecasts")]\n            async (\n                SendWeatherForecastBody body,\n                ILogger<SendWeatherForecastBody> logger,\n                IOptions<MailConfig> options\n            ) =>\n            {\n                try\n                {\n                    if (string.IsNullOrEmpty(body.Email)) throw new Exception("Email required");\n\n                    var weatherForecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast\n                    {\n                        Date = DateTime.Now.AddDays(index),\n                        TemperatureC = Random.Shared.Next(-20, 55),\n                        Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n                    })\n                    .ToArray();\n\n                    var toEmailAddress = body.Email;\n                    var text = $@"The weather forecast is:\n\n{string.Join("\\n", weatherForecast.Select(wf => $"On {wf.Date} the weather will be {wf.Summary}"))}\n";\n\n                    await SendSimpleMessage(\n                        mailgunApiKey: options.Value.MailgunApiKey,\n                        toEmailAddress: toEmailAddress,\n                        text: text\n                    );\n\n                    return Results.Ok($"We have mailed {toEmailAddress} with the following:\\n\\n{text})");\n                }\n                catch (Exception exc)\n                {\n                    logger.LogError(exc, $"Problem!");\n\n                    return Results.BadRequest(exc.Message);\n                }\n            });\n\n        return endpoints;\n    }\n\n    static async Task<RestResponse> SendSimpleMessage(string mailgunApiKey, string toEmailAddress, string text)\n    {\n        RestClient client = new(new RestClientOptions\n        {\n            BaseUrl = new Uri("https://api.mailgun.net/v3")\n        })\n        {\n            Authenticator =\n            new HttpBasicAuthenticator("api", mailgunApiKey)\n        };\n        RestRequest request = new();\n        request.AddParameter("domain", "mg.priou.co.uk", ParameterType.UrlSegment);\n        request.Resource = "{domain}/messages";\n        request.AddParameter("from", "John Reilly <johnny_reilly@hotmail.com>");\n        request.AddParameter("to", toEmailAddress);\n        request.AddParameter("subject", "Weather forecast");\n        request.AddParameter("text", text);\n\n        return await client.PostAsync(request);\n    }\n}\n')),(0,a.kt)("p",null,"The significant thing to note above is the ",(0,a.kt)("inlineCode",{parentName:"p"},'[Topic("weather-forecast-pub-sub", "weather-forecasts")]')," that we're adding to our ",(0,a.kt)("inlineCode",{parentName:"p"},"MapPost")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"MapWeatherForecastEndpoints")," method. This is the equivalent of the ",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions")," component that we wanted to create in Bicep but couldn't. This is our programmatic subscription."),(0,a.kt)("p",null,"We also need to tweak our ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," to cater for the new ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastEndpoints")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-cs"}),'using Config;\nusing WeatherService.Endpoints;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<MailConfig>(builder.Configuration.GetSection("Mail"));\n\nbuilder.Services.AddControllers().AddDapr();\n// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseAuthorization();\n\napp.UseCloudEvents();\n\napp.MapSubscribeHandler(); // This is the Dapr subscribe handler\n\napp.MapWeatherForecastEndpoints();\n\napp.Run();\n')),(0,a.kt)("p",null,"So the ",(0,a.kt)("inlineCode",{parentName:"p"},"app.MapWeatherForecastEndpoints();")," is what wires up our ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastEndpoints")," class."),(0,a.kt)("p",null,"With that in place, we're ready to deploy to Azure."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"A gif that demos entering an email address in the form, submitting it and seeing an email arrive with a weather forecast in",src:t(52879).Z,width:"1464",height:"1228"})),(0,a.kt)("p",null,"We now have Azure Container Apps running in Azure, using the dapr pubsub component. Hopefully in future declarative subscribtions will be available also, but for now we can use the programmatic approach."))}d.isMDXComponent=!0},52879:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/demo-send-email-with-pubsub-42a65d1ab700b6145f6e994f87806c9f.gif"},79924:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/demo-send-email-8b9d6fdfb4709356c1b32bb2bfa592ee.gif"},87826:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/screenshot-github-secrets-c7d53c9822c48d0f16997a6470264d0b.png"},48150:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/title-image-1083426a9aa76352a87988e08d382718.png"}}]);