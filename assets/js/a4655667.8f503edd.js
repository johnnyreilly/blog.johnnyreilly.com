"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[45483],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var t=s(96540);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}},33670:e=>{e.exports=JSON.parse('{"permalink":"/using-gulp-in-visual-studio-instead-of-web-optimization","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2014-11-04-using-gulp-in-visual-studio-instead-of-web-optimization/index.md","source":"@site/blog/2014-11-04-using-gulp-in-visual-studio-instead-of-web-optimization/index.md","title":"Using Gulp in Visual Studio instead of Web Optimization","description":"The ASP.NET team may replace Web Optimization with Grunt or Gulp. John Reilly tried out Gulp, which concatenates, minimises & version-numbers files.","date":"2014-11-04T00:00:00.000Z","tags":[{"inline":false,"label":"Visual Studio","permalink":"/tags/visual-studio","description":"The Visual Studio IDE."},{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."},{"inline":false,"label":"JavaScript","permalink":"/tags/javascript","description":"The JavaScript programming language."},{"inline":false,"label":"Node.js","permalink":"/tags/node-js","description":"The Node.js runtime."}],"readingTime":16.18,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"using-gulp-in-visual-studio-instead-of-web-optimization","title":"Using Gulp in Visual Studio instead of Web Optimization","authors":"johnnyreilly","tags":["visual studio","typescript","javascript","node.js"],"hide_table_of_contents":false,"description":"The ASP.NET team may replace Web Optimization with Grunt or Gulp. John Reilly tried out Gulp, which concatenates, minimises & version-numbers files."},"unlisted":false,"prevItem":{"title":"Pretending to be someone you\'re not and the dark pit of despair","permalink":"/Coded-UI-IE-11-and-the-runas-problem"},"nextItem":{"title":"Caching and Cache-Busting in AngularJS with HTTP interceptors","permalink":"/caching-and-cache-busting-in-angularjs-with-http-interceptors"}}')},49415:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/Screenshot-2014-10-21-17.02.11-e6efce21155e122138e6ea2793f2fa06.webp"},68842:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>d});var t=s(33670),i=s(74848),a=s(28453);const l={slug:"using-gulp-in-visual-studio-instead-of-web-optimization",title:"Using Gulp in Visual Studio instead of Web Optimization",authors:"johnnyreilly",tags:["visual studio","typescript","javascript","node.js"],hide_table_of_contents:!1,description:"The ASP.NET team may replace Web Optimization with Grunt or Gulp. John Reilly tried out Gulp, which concatenates, minimises & version-numbers files."},r=void 0,o={authorsImageUrls:[void 0]},d=[{value:"Updated 17/02/2015: I&#39;ve taken the approach discussed in this post a little further - you can see here",id:"updated-17022015-ive-taken-the-approach-discussed-in-this-post-a-little-further---you-can-see-here",level:3},{value:"Bub bye Web Optimization",id:"bub-bye-web-optimization",level:2},{value:"Installing Gulp (and Associates)",id:"installing-gulp-and-associates",level:2},{value:"Making <code>gulpfile.js</code>",id:"making-gulpfilejs",level:2},{value:"What <code>gulpfile.js</code> does",id:"what-gulpfilejs-does",level:2},{value:"Task Runner Explorer gets in on the action",id:"task-runner-explorer-gets-in-on-the-action",level:2},{value:"How do I use this in my HTML?",id:"how-do-i-use-this-in-my-html",level:2},{value:"I want to publish, how do I include my assets?",id:"i-want-to-publish-how-do-i-include-my-assets",level:2}];function p(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h3,{id:"updated-17022015-ive-taken-the-approach-discussed-in-this-post-a-little-further---you-can-see-here",children:["Updated 17/02/2015: I've taken the approach discussed in this post a little further - you can see ",(0,i.jsx)(n.a,{href:"/using-web-optimization-with-mvc-3",children:"here"})]}),"\n",(0,i.jsxs)(n.p,{children:["I've used a number of tools to package up JavaScript and CSS in my web apps. ",(0,i.jsx)(n.a,{href:"http://getcassette.net/",children:"Andrew Davey's tremendous Cassette"})," has been really useful. Also good (although less powerful/magical) has been Microsoft's very own ",(0,i.jsx)(n.a,{href:"https://www.nuget.org/packages/Microsoft.AspNet.Web.Optimization/",children:"Microsoft.AspNet.Web.Optimization"})," that ships with MVC."]}),"\n",(0,i.jsxs)(n.p,{children:["I was watching the ",(0,i.jsx)(n.a,{href:"http://youtu.be/NgbA2BxNweE?list=PL0M0zPgJ3HSftTAAHttA3JQU4vOjXFquF",children:"ASP.NET Community Standup from October 7th, 2014"})," and learned that the ASP.Net team is not planning to migrate ",(0,i.jsx)(n.a,{href:"https://www.nuget.org/packages/Microsoft.AspNet.Web.Optimization/",children:"Microsoft.AspNet.Web.Optimization"})," to the next version of ASP.Net. Instead they're looking to make use of JavaScript task runners like ",(0,i.jsx)(n.a,{href:"http://gruntjs.com/",children:"Grunt"})," and maybe ",(0,i.jsx)(n.a,{href:"http://gulpjs.com/",children:"Gulp"}),". Perhaps you're even dimly aware that they've been taking steps to make these runners more of a first class citizen in Visual Studio, hence the recent release of the new and groovy ",(0,i.jsx)(n.a,{href:"http://visualstudiogallery.msdn.microsoft.com/8e1b4368-4afb-467a-bc13-9650572db708",children:"Task Runner Explorer"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:['Gulp has been on my radar for a while now as has Grunt. By "on my radar" what I really mean is "Hmmmm, I really need to learn this..... perhaps I could wait until the ',(0,i.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/Videotape_format_war",children:"Betamax vs VHS battles"}),' are done? Oh never mind, here we go...".']}),"\n",(0,i.jsx)(n.p,{children:"My understanding is that Grunt and Gulp essentially do the same thing (run tasks in JavaScript) but have different approaches. Grunt is more about configuration, Gulp is more about code. At present Gulp also has a performance advantage as it does less IO than Grunt - though I understand that's due to change in the future. But generally my preference is code over configuration. On that basis I decided that I was going to give Gulp first crack."}),"\n",(0,i.jsx)(n.h2,{id:"bub-bye-web-optimization",children:"Bub bye Web Optimization"}),"\n",(0,i.jsxs)(n.p,{children:["I already had a project that used ",(0,i.jsx)(n.a,{href:"https://github.com/johnnyreilly/Proverb",children:"Web Optimization"})," to bundle JavaScript and CSS files. When debugging on my own machine Web Optimization served up the full JavaScript and CSS files. Thanks to the magic of source maps I was able to debug the TypeScript that created the JavaScript files too. Which was nice. When I deployed to production, Web Optimization minified and concatenated the JavaScript and CSS files. This meant I had a single HTTP request for JavaScript and a single HTTP request for CSS. This was also... nooice!"]}),"\n",(0,i.jsxs)(n.p,{children:["I took a copy of my existing project and created a ",(0,i.jsx)(n.a,{href:"https://github.com/johnnyreilly/Proverb-gulp",children:"new repo for it on GitHub"}),". It was very simple in terms of bundling. It had a ",(0,i.jsx)(n.code,{children:"BundleConfig"})," that created 2 bundles; 1 for JavaScript and 1 for CSS:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'using System.Web;\nusing System.Web.Optimization;\n\nnamespace Proverb.Web\n{\n    public class BundleConfig\n    {\n        // For more information on bundling, visit http://go.microsoft.com/fwlink/?LinkId=301862\n        public static void RegisterBundles(BundleCollection bundles)\n        {\n            var angularApp = new ScriptBundle("~/angularApp").Include(\n\n                // Vendor Scripts\n                "~/scripts/jquery-{version}.js",\n                "~/scripts/angular.js",\n                "~/scripts/angular-animate.js",\n                "~/scripts/angular-route.js",\n                "~/scripts/angular-sanitize.js",\n                "~/scripts/angular-ui/ui-bootstrap-tpls.js",\n\n                "~/scripts/toastr.js",\n                "~/scripts/moment.js",\n                "~/scripts/spin.js",\n                "~/scripts/underscore.js",\n\n                // Bootstrapping\n                "~/app/app.js",\n                "~/app/config.route.js",\n\n                // common Modules\n                "~/app/common/common.js",\n                "~/app/common/logger.js",\n                "~/app/common/spinner.js",\n\n                // common.bootstrap Modules\n                "~/app/common/bootstrap/bootstrap.dialog.js"\n                );\n\n            // directives\n            angularApp.IncludeDirectory("~/app/directives", "*.js", true);\n\n            // services\n            angularApp.IncludeDirectory("~/app/services", "*.js", true);\n\n            // controllers\n            angularApp.IncludeDirectory("~/app/admin", "*.js", true);\n            angularApp.IncludeDirectory("~/app/about", "*.js", true);\n            angularApp.IncludeDirectory("~/app/dashboard", "*.js", true);\n            angularApp.IncludeDirectory("~/app/layout", "*.js", true);\n            angularApp.IncludeDirectory("~/app/sayings", "*.js", true);\n            angularApp.IncludeDirectory("~/app/sages", "*.js", true);\n\n            bundles.Add(angularApp);\n\n            bundles.Add(new StyleBundle("~/Content/css").Include(\n                "~/content/ie10mobile.css",\n                "~/content/bootstrap.css",\n                "~/content/font-awesome.css",\n                "~/content/toastr.css",\n                "~/content/styles.css"\n            ));\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["I set myself a task. I wanted to be able to work in *",(0,i.jsx)(n.strong,{children:"exactly"}),"* the way I was working now. But using Gulp instead of Web Optimization. I wanted to lose the BundleConfig above and remove Web Optimization from my application, secure in the knowledge that I had lost nothing. Could it be done? Read on!"]}),"\n",(0,i.jsx)(n.h2,{id:"installing-gulp-and-associates",children:"Installing Gulp (and Associates)"}),"\n",(0,i.jsx)(n.p,{children:"I fired up Visual Studio and looked for an excuse to use the Task Runner Explorer. The first thing I needed was Gulp. My machine already had Node and NPM installed so I went to the command line to install Gulp globally:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps",children:"npm install gulp -g\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now to start to plug Gulp into my web project. It was time to make the introductions: Visual Studio meet NPM. At the root of the web project I created a ",(0,i.jsx)(n.code,{children:"package.json"})," file by executing the following command and accepting all the defaults:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps",children:"npm init\n"})}),"\n",(0,i.jsx)(n.p,{children:'I wanted to add Gulp as a development dependency of my project: ("Development" because I only need to run tasks at development time. My app has no dependency on Gulp at runtime - at that point it\'s just about serving up static files.)'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps",children:"npm install gulp --save-dev\n"})}),"\n",(0,i.jsxs)(n.p,{children:['This installs gulp local to the project as a development dependency. As a result we now have a "node_modules" folder sat in our root which contains our node packages. Currently, as our ',(0,i.jsx)(n.code,{children:"package.json"})," reveals, this is only gulp:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'"devDependencies": {\n    "gulp": "^3.8.8"\n  }\n'})}),"\n",(0,i.jsx)(n.p,{children:"It's time to go to town. Let's install all the packages we're going to need to bundle and minify JavaScript and CSS:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"npm install gulp-concat gulp-uglify gulp-rev del path gulp-ignore gulp-asset-manifest gulp-minify-css --save-dev\n"})}),"\n",(0,i.jsx)(n.p,{children:"This installs the packages as dev dependencies (as you've probably guessed) and leaves us with a list of dev dependencies like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'"devDependencies": {\n    "del": "^0.1.3",\n    "gulp": "^3.8.8",\n    "gulp-asset-manifest": "0.0.5",\n    "gulp-concat": "^2.4.1",\n    "gulp-ignore": "^1.2.1",\n    "gulp-minify-css": "^0.3.10",\n    "gulp-rev": "^1.1.0",\n    "gulp-uglify": "^1.0.1",\n    "path": "^0.4.9"\n  }\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"making-gulpfilejs",children:["Making ",(0,i.jsx)(n.code,{children:"gulpfile.js"})]}),"\n",(0,i.jsxs)(n.p,{children:["So now I was ready. I had everything I needed to replace my ",(0,i.jsx)(n.code,{children:"BundleConfig.cs"}),". I created a new file called ",(0,i.jsx)(n.code,{children:"gulpfile.js"})," in the root of my web project that looked like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/// <vs AfterBuild='default' />\nvar gulp = require('gulp');\n\n// Include Our Plugins\nvar concat = require('gulp-concat');\nvar ignore = require('gulp-ignore');\nvar manifest = require('gulp-asset-manifest');\nvar minifyCss = require('gulp-minify-css');\nvar uglify = require('gulp-uglify');\nvar rev = require('gulp-rev');\nvar del = require('del');\nvar path = require('path');\n\nvar tsjsmapjsSuffix = '.{ts,js.map,js}';\nvar excludetsjsmap = '**/*.{ts,js.map}';\n\nvar bundleNames = { scripts: 'scripts', styles: 'styles' };\n\nvar filesAndFolders = {\n  base: '.',\n  buildBaseFolder: './build/',\n  debug: 'debug',\n  release: 'release',\n  css: 'css',\n\n  // The fonts we want Gulp to process\n  fonts: ['./fonts/*.*'],\n\n  // The scripts we want Gulp to process - adapted from BundleConfig\n  scripts: [\n    // Vendor Scripts\n    './scripts/angular.js',\n    './scripts/angular-animate.js',\n    './scripts/angular-route.js',\n    './scripts/angular-sanitize.js',\n    './scripts/angular-ui/ui-bootstrap-tpls.js',\n\n    './scripts/toastr.js',\n    './scripts/moment.js',\n    './scripts/spin.js',\n    './scripts/underscore.js',\n\n    // Bootstrapping\n    './app/app' + tsjsmapjsSuffix,\n    './app/config.route' + tsjsmapjsSuffix,\n\n    // common Modules\n    './app/common/common' + tsjsmapjsSuffix,\n    './app/common/logger' + tsjsmapjsSuffix,\n    './app/common/spinner' + tsjsmapjsSuffix,\n\n    // common.bootstrap Modules\n    './app/common/bootstrap/bootstrap.dialog' + tsjsmapjsSuffix,\n\n    // directives\n    './app/directives/**/*' + tsjsmapjsSuffix,\n\n    // services\n    './app/services/**/*' + tsjsmapjsSuffix,\n\n    // controllers\n    './app/about/**/*' + tsjsmapjsSuffix,\n    './app/admin/**/*' + tsjsmapjsSuffix,\n    './app/dashboard/**/*' + tsjsmapjsSuffix,\n    './app/layout/**/*' + tsjsmapjsSuffix,\n    './app/sages/**/*' + tsjsmapjsSuffix,\n    './app/sayings/**/*' + tsjsmapjsSuffix,\n  ],\n\n  // The styles we want Gulp to process - adapted from BundleConfig\n  styles: [\n    './content/ie10mobile.css',\n    './content/bootstrap.css',\n    './content/font-awesome.css',\n    './content/toastr.css',\n    './content/styles.css',\n  ],\n};\n\nfilesAndFolders.debugFolder =\n  filesAndFolders.buildBaseFolder + '/' + filesAndFolders.debug + '/';\nfilesAndFolders.releaseFolder =\n  filesAndFolders.buildBaseFolder + '/' + filesAndFolders.release + '/';\n\n/**\n * Create a manifest depending upon the supplied arguments\n *\n * @param {string} manifestName\n * @param {string} bundleName\n * @param {boolean} includeRelativePath\n * @param {string} pathPrepend\n */\nfunction getManifest(\n  manifestName,\n  bundleName,\n  includeRelativePath,\n  pathPrepend,\n) {\n  // Determine filename (\"./build/manifest-debug.json\" or \"./build/manifest-release.json\"\n  var manifestFile =\n    filesAndFolders.buildBaseFolder + 'manifest-' + manifestName + '.json';\n\n  return manifest({\n    bundleName: bundleName,\n    includeRelativePath: includeRelativePath,\n    manifestFile: manifestFile,\n    log: true,\n    pathPrepend: pathPrepend,\n    pathSeparator: '/',\n  });\n}\n\n// Delete the build folder\ngulp.task('clean', function (cb) {\n  del([filesAndFolders.buildBaseFolder], cb);\n});\n\n// Copy across all files in filesAndFolders.scripts to build/debug\ngulp.task('scripts-debug', ['clean'], function () {\n  return gulp\n    .src(filesAndFolders.scripts, { base: filesAndFolders.base })\n    .pipe(gulp.dest(filesAndFolders.debugFolder));\n});\n\n// Create a manifest.json for the debug build - this should have lots of script files in\ngulp.task('manifest-scripts-debug', ['scripts-debug'], function () {\n  return gulp\n    .src(filesAndFolders.scripts, { base: filesAndFolders.base })\n    .pipe(ignore.exclude('**/*.{ts,js.map}')) // Exclude ts and js.map files from the manifest (as they won't become script tags)\n    .pipe(getManifest(filesAndFolders.debug, bundleNames.scripts, true));\n});\n\n// Copy across all files in filesAndFolders.styles to build/debug\ngulp.task('styles-debug', ['clean'], function () {\n  return gulp\n    .src(filesAndFolders.styles, { base: filesAndFolders.base })\n    .pipe(gulp.dest(filesAndFolders.debugFolder));\n});\n\n// Create a manifest.json for the debug build - this should have lots of style files in\ngulp.task(\n  'manifest-styles-debug',\n  ['styles-debug', 'manifest-scripts-debug'],\n  function () {\n    return (\n      gulp\n        .src(filesAndFolders.styles, { base: filesAndFolders.base })\n        //.pipe(ignore.exclude(\"**/*.{ts,js.map}\")) // Exclude ts and js.map files from the manifest (as they won't become script tags)\n        .pipe(getManifest(filesAndFolders.debug, bundleNames.styles, true))\n    );\n  },\n);\n\n// Concatenate & Minify JS for release into a single file\ngulp.task('scripts-release', ['clean'], function () {\n  return (\n    gulp\n      .src(filesAndFolders.scripts)\n      .pipe(ignore.exclude('**/*.{ts,js.map}')) // Exclude ts and js.map files - not needed in release mode\n\n      .pipe(concat('app.js')) // Make a single file - if you want to see the contents then include the line below\n      //.pipe(gulp.dest(releaseFolder))\n\n      .pipe(uglify()) // Make the file titchy tiny small\n      .pipe(rev()) // Suffix a version number to it\n      .pipe(gulp.dest(filesAndFolders.releaseFolder))\n  ); // Write single versioned file to build/release folder\n});\n\n// Create a manifest.json for the release build - this should just have a single file for scripts\ngulp.task('manifest-scripts-release', ['scripts-release'], function () {\n  return gulp\n    .src(filesAndFolders.buildBaseFolder + filesAndFolders.release + '/*.js')\n    .pipe(getManifest(filesAndFolders.release, bundleNames.scripts, false));\n});\n\n// Copy across all files in filesAndFolders.styles to build/debug\ngulp.task('styles-release', ['clean'], function () {\n  return (\n    gulp\n      .src(filesAndFolders.styles)\n      .pipe(concat('app.css')) // Make a single file - if you want to see the contents then include the line below\n      //.pipe(gulp.dest(releaseFolder))\n\n      .pipe(minifyCss()) // Make the file titchy tiny small\n      .pipe(rev()) // Suffix a version number to it\n      .pipe(\n        gulp.dest(filesAndFolders.releaseFolder + '/' + filesAndFolders.css),\n      )\n  ); // Write single versioned file to build/release folder\n});\n\n// Create a manifest.json for the debug build - this should have a single style files in\ngulp.task(\n  'manifest-styles-release',\n  ['styles-release', 'manifest-scripts-release'],\n  function () {\n    return gulp\n      .src(filesAndFolders.releaseFolder + '**/*.css')\n      .pipe(\n        getManifest(\n          filesAndFolders.release,\n          bundleNames.styles,\n          false,\n          filesAndFolders.css + '/',\n        ),\n      );\n  },\n);\n\n// Copy across all fonts in filesAndFolders.fonts to both release and debug locations\ngulp.task('fonts', ['clean'], function () {\n  return gulp\n    .src(filesAndFolders.fonts, { base: filesAndFolders.base })\n    .pipe(gulp.dest(filesAndFolders.debugFolder))\n    .pipe(gulp.dest(filesAndFolders.releaseFolder));\n});\n\n// Default Task\ngulp.task('default', [\n  'scripts-debug',\n  'manifest-scripts-debug',\n  'styles-debug',\n  'manifest-styles-debug',\n  'scripts-release',\n  'manifest-scripts-release',\n  'styles-release',\n  'manifest-styles-release',\n  'fonts',\n]);\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"what-gulpfilejs-does",children:["What ",(0,i.jsx)(n.code,{children:"gulpfile.js"})," does"]}),"\n",(0,i.jsxs)(n.p,{children:["This file does a number of things each time it is run. First of all it deletes any ",(0,i.jsx)(n.code,{children:"build"})," folder in the root of the web project so we're ready to build anew. Then it packages up files both for debug and for release mode. For debug it does the following:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["It copies the ",(0,i.jsx)(n.code,{children:"ts"}),", ",(0,i.jsx)(n.code,{children:"js.map"})," and ",(0,i.jsx)(n.code,{children:"js"})," files declared in ",(0,i.jsx)(n.code,{children:"filesAndFolders.scripts"})," to the ",(0,i.jsx)(n.code,{children:"build/debug"})," folder preserving their original folder structure. (So, for example, ",(0,i.jsx)(n.code,{children:"app/app.ts"}),", ",(0,i.jsx)(n.code,{children:"app/app.js.map"})," and ",(0,i.jsx)(n.code,{children:"app/app.js"})," will all end up at ",(0,i.jsx)(n.code,{children:"build/debug/app/app.ts"}),", ",(0,i.jsx)(n.code,{children:"build/debug/app/app.js.map"})," and ",(0,i.jsx)(n.code,{children:"build/debug/app/app.js"})," respectively.) This is done to allow the continued debugging of the original TypeScript files when running in debug mode."]}),"\n",(0,i.jsxs)(n.li,{children:["It copies the ",(0,i.jsx)(n.code,{children:"css"})," files declared in ",(0,i.jsx)(n.code,{children:"filesAndFolders.styles"})," to the ",(0,i.jsx)(n.code,{children:"build/debug"})," folder preserving their original folder structure. (So ",(0,i.jsx)(n.code,{children:"content/bootstrap.css"})," will end up at ",(0,i.jsx)(n.code,{children:"build/debug/content/bootstrap.css"}),".)"]}),"\n",(0,i.jsxs)(n.li,{children:["It creates a ",(0,i.jsx)(n.code,{children:"build/manifest-debug.json"})," file which contains details of all the script and style files that have been packaged up:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": [\n    "scripts/angular.js",\n    "scripts/angular-animate.js",\n    "scripts/angular-route.js",\n    "scripts/angular-sanitize.js",\n    "scripts/angular-ui/ui-bootstrap-tpls.js",\n    "scripts/toastr.js",\n    "scripts/moment.js",\n    "scripts/spin.js",\n    "scripts/underscore.js",\n    "app/app.js",\n    "app/config.route.js",\n    "app/common/common.js",\n    "app/common/logger.js",\n    "app/common/spinner.js",\n    "app/common/bootstrap/bootstrap.dialog.js",\n    "app/directives/imgPerson.js",\n    "app/directives/serverError.js",\n    "app/directives/sidebar.js",\n    "app/directives/spinner.js",\n    "app/directives/waiter.js",\n    "app/directives/widgetClose.js",\n    "app/directives/widgetHeader.js",\n    "app/directives/widgetMinimize.js",\n    "app/services/datacontext.js",\n    "app/services/repositories.js",\n    "app/services/repository.sage.js",\n    "app/services/repository.saying.js",\n    "app/about/about.js",\n    "app/admin/admin.js",\n    "app/dashboard/dashboard.js",\n    "app/layout/shell.js",\n    "app/layout/sidebar.js",\n    "app/layout/topnav.js",\n    "app/sages/sageDetail.js",\n    "app/sages/sageEdit.js",\n    "app/sages/sages.js",\n    "app/sayings/sayingEdit.js",\n    "app/sayings/sayings.js"\n  ],\n  "styles": [\n    "content/ie10mobile.css",\n    "content/bootstrap.css",\n    "content/font-awesome.css",\n    "content/toastr.css",\n    "content/styles.css"\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For release our gulpfile works with the same resources but has a different aim. Namely to minimise the the number of HTTP requests, obfuscate the code and version the files produced to prevent caching issues. To achieve those lofty aims it does the following:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["It concatenates together all the ",(0,i.jsx)(n.code,{children:"js"})," files declared in ",(0,i.jsx)(n.code,{children:"filesAndFolders.scripts"}),", minifies them and writes them to a single ",(0,i.jsx)(n.code,{children:"build/release/app-{xxxxx}.js"})," file (where ",(0,i.jsx)(n.code,{children:"-{xxxxx}"})," represents a version created by gulp-rev)."]}),"\n",(0,i.jsxs)(n.li,{children:["It concatenates together all the ",(0,i.jsx)(n.code,{children:"css"})," files declared in ",(0,i.jsx)(n.code,{children:"filesAndFolders.styles"}),", minifies them and writes them to a single ",(0,i.jsx)(n.code,{children:"build/release/css/app-{xxxxx}.css"})," file. The file is placed in a css subfolder because of relative paths specified in the CSS file."]}),"\n",(0,i.jsxs)(n.li,{children:["It creates a ",(0,i.jsx)(n.code,{children:"build/manifest-release.json"})," file which contains details of all the script and style files that have been packaged up:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": ["app-95d1e06d.js"],\n  "styles": ["css/app-1a6256ea.css"]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, the number of files included are reduced down to 2; 1 for JavaScript and 1 for CSS."}),"\n",(0,i.jsxs)(n.p,{children:["Finally, for both the debug and release packages the contents of the ",(0,i.jsx)(n.code,{children:"fonts"})," folder is copied across wholesale, preserving the original folder structure. This is because the CSS files contain relative references that point to the font files. If I had image files which were referenced by my CSS I'd similarly need to include these in the build process."]}),"\n",(0,i.jsx)(n.h2,{id:"task-runner-explorer-gets-in-on-the-action",children:"Task Runner Explorer gets in on the action"}),"\n",(0,i.jsxs)(n.p,{children:["The eagle eyed amongst you will also have noticed a peculiar first line to our ",(0,i.jsx)(n.code,{children:"gulpfile.js"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/// <vs AfterBuild='default' />\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This mysterious comment is actually how the Task Runner Explorer hooks our ",(0,i.jsx)(n.code,{children:"gulpfile.js"}),' into the Visual Studio build process. Our "magic comment" ensures that on the ',(0,i.jsx)(n.code,{children:"AfterBuild"})," event, Task Runner Explorer runs the ",(0,i.jsx)(n.code,{children:"default"})," task in our ",(0,i.jsx)(n.code,{children:"gulpfile.js"}),". The reason we're using the ",(0,i.jsx)(n.code,{children:"AfterBuild"})," event rather than the ",(0,i.jsx)(n.code,{children:"BeforeBuild"})," event is because our project contains TypeScript and we need the transpiled JavaScript to be created before we can usefully run our package tasks. If we were using JavaScript alone then that wouldn't be an issue and either build event would do."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:s(49415).A+"",width:"640",height:"553",loading:"lazy"})}),"\n",(0,i.jsx)(n.h2,{id:"how-do-i-use-this-in-my-html",children:"How do I use this in my HTML?"}),"\n",(0,i.jsx)(n.p,{children:"Well this is magnificent - we have a gulpfile that builds our debug and release packages. The question now is, how do we use it?"}),"\n",(0,i.jsxs)(n.p,{children:["Web Optimization made our lives really easy. Up in my head I had a ",(0,i.jsx)(n.code,{children:'@Styles.Render("~/Content/css")'})," which pushed out my CSS and down at the foot of the body tag I had a ",(0,i.jsx)(n.code,{children:'@Scripts.Render("~/angularApp")'})," which pushed out my script tags. ",(0,i.jsx)(n.code,{children:"Styles"})," and ",(0,i.jsx)(n.code,{children:"Scripts"})," are server-side utilities. It would be very easy to write equivalent utility classes that, depending on whether we were in debug or not, read the appropriate ",(0,i.jsx)(n.code,{children:"build/manifest-xxxxxx.json"})," file and served up either debug or release ",(0,i.jsx)(n.code,{children:"style"})," / ",(0,i.jsx)(n.code,{children:"script"})," tags."]}),"\n",(0,i.jsxs)(n.p,{children:["That would be pretty simple - and for what it's worth **simple is ",(0,i.jsx)("u",{children:"good"})]}),"\n",(0,i.jsx)(n.p,{children:"**. But today I felt like a challenge. What say server side rendering had been outlawed? A draconian ruling had been passed and all you had to play with was HTML / JavaScript and a server API that served up JSON? What would you do then? (All fantasy I know... But go with me on this - it's a journey.) Or more sensibly, what if you just want to remove some of the work your app is doing server-side to bundle and minify. Just serve up static assets instead. Spend less money in Azure why not?"}),"\n",(0,i.jsx)(n.p,{children:"Before I make all the changes let's review where we were. I had a single MVC view which, in terms of bundles, CSS and JavaScript pretty much looked like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<!doctype html>\n<html>\n  <head>\n    \x3c!-- ... --\x3e\n    @Styles.Render("~/Content/css")\n  </head>\n  <body>\n    \x3c!-- ... --\x3e\n\n    @Scripts.Render("~/angularApp")\n    <script>\n      (function () {\n        $.getJSON(\'@Url.Content("~/Home/StartApp")\').done(\n          function (startUpData) {\n            var appConfig = $.extend({}, startUpData, {\n              appRoot: \'@Url.Content("~/")\',\n              remoteServiceRoot: \'@Url.Content("~/api/")\',\n            });\n\n            angularApp.start({\n              thirdPartyLibs: {\n                moment: window.moment,\n                toastr: window.toastr,\n                underscore: window._,\n              },\n              appConfig: appConfig,\n            });\n          },\n        );\n      })();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,i.jsx)(n.p,{children:"This is already more a complicated example than most peoples use cases. Essentially what's happening here is both bundles are written out as part of the HTML and then, once the scripts have loaded the Angular app is bootstrapped with some configuration loaded from the server by a good old jQuery AJAX call."}),"\n",(0,i.jsxs)(n.p,{children:["After reading ",(0,i.jsx)(n.a,{href:"http://www.html5rocks.com/en/tutorials/speed/script-loading/",children:"an article about script loading by the magnificently funny Jake Archibald"})," I felt ready. I cast my MVC view to the four winds and created myself a straight HTML file:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<!doctype html>\n<html>\n  <head>\n    \x3c!-- ... --\x3e\n  </head>\n  <body>\n    \x3c!-- ... --\x3e\n\n    <script src=\"Scripts/jquery-2.1.1.min.js\"><\/script>\n    <script>\n      (function () {\n        var appConfig = {};\n        var scriptsToLoad;\n\n        /**\n         * Handler which fires as each script loads\n         */\n        function onScriptLoad(event) {\n          scriptsToLoad -= 1;\n\n          // Now all the scripts are present start the app\n          if (scriptsToLoad === 0) {\n            angularApp.start({\n              thirdPartyLibs: {\n                moment: window.moment,\n                toastr: window.toastr,\n                underscore: window._,\n              },\n              appConfig: appConfig,\n            });\n          }\n        }\n\n        // Load startup data from the server\n        $.getJSON('api/Startup').done(function (startUpData) {\n          appConfig = startUpData;\n\n          // Determine the assets folder depending upon whether in debug mode or not\n          var buildFolder = appConfig.appRoot + 'build/';\n          var debugOrRelease = appConfig.inDebug ? 'debug' : 'release';\n          var manifestFile =\n            buildFolder + 'manifest-' + debugOrRelease + '.json';\n          var outputFolder = buildFolder + debugOrRelease + '/';\n\n          // Load JavaScript and CSS listed in manifest file\n          $.getJSON(manifestFile).done(function (manifest) {\n            manifest.styles.forEach(function (href) {\n              var link = document.createElement('link');\n\n              link.rel = 'stylesheet';\n              link.media = 'all';\n              link.href = outputFolder + href;\n\n              document.head.appendChild(link);\n            });\n\n            scriptsToLoad = manifest.scripts.length;\n            manifest.scripts.forEach(function (src) {\n              var script = document.createElement('script');\n\n              script.onload = onScriptLoad;\n              script.src = outputFolder + src;\n              script.async = false;\n\n              document.head.appendChild(script);\n            });\n          });\n        });\n      })();\n    <\/script>\n  </body>\n</html>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you very carefully compare the HTML above the MVC view that it replaces you can see the commonalities. They are doing pretty much the same thing - the only real difference is the bootstrapping API. Previously it was an MVC endpoint at ",(0,i.jsx)(n.code,{children:"/Home/StartApp"}),". Now it's a Web API endpoint at ",(0,i.jsx)(n.code,{children:"api/Startup"}),". Here's how it works:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A jQuery AJAX call kicks off a call to load the bootstrapping / app config data. Importantly this data includes whether the app is running in debug or not."}),"\n",(0,i.jsxs)(n.li,{children:["Depending on the ",(0,i.jsx)(n.code,{children:"isDebug"})," flag the app either loads the ",(0,i.jsx)(n.code,{children:"build/manifest-debug.json"})," or ",(0,i.jsx)(n.code,{children:"build/manifest-release.json"})," manifest."]}),"\n",(0,i.jsxs)(n.li,{children:["For each CSS file in the styles bundle a ",(0,i.jsx)(n.code,{children:"link"})," element is created and added to the page."]}),"\n",(0,i.jsxs)(n.li,{children:["For each JavaScript file in the scripts bundle a ",(0,i.jsx)(n.code,{children:"script"})," element is created and added to the page."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["It's worth pointing out that this also has a performance edge over Web Optimization as the assets are loaded asynchronously! (Yes I know it says ",(0,i.jsx)(n.code,{children:"script.async = false"})," but that's not what you think it is... Go read Jake's article!)"]}),"\n",(0,i.jsxs)(n.p,{children:["To finish off I had to make a few tweaks to my ",(0,i.jsx)(n.code,{children:"web.config"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Allow ASP.Net to serve up JSON files --\x3e\n    <system.webServer>\n        <staticContent>\n            <mimeMap fileExtension=".json" mimeType="application/json"/>\n        </staticContent>\n    </system.webServer>\n\n    \x3c!-- The build folder (and it\'s child folder "debug") will not be cached.\n         When people are debugging they don\'t want to cache --\x3e\n    <location path="build">\n        <system.webServer>\n            <staticContent>\n                <clientCache cacheControlMode="DisableCache"/>\n            </staticContent>\n        </system.webServer>\n    </location>\n\n    \x3c!-- The release folder will be cached for a loooooong time\n         When you\'re in Production caching is your friend --\x3e\n    <location path="build/release">\n        <system.webServer>\n            <staticContent>\n                <clientCache cacheControlMode="UseMaxAge"/>\n            </staticContent>\n        </system.webServer>\n    </location>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"i-want-to-publish-how-do-i-include-my-assets",children:"I want to publish, how do I include my assets?"}),"\n",(0,i.jsxs)(n.p,{children:["It's time for some ",(0,i.jsx)(n.code,{children:"csproj"})," trickery. I must say I think I'll be glad to see the back of project files when ASP.Net vNext ships. This is what you need:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<Target Name="AfterBuild">\n    <ItemGroup>\n      \x3c!-- what ever is in the build folder should be included in the project --\x3e\n      <Content Include="build\\**\\*.*" />\n    </ItemGroup>\n  </Target>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["What's happening here is that *",(0,i.jsx)(n.em,{children:"after"}),"* a build Visual Studio considers the complete contents of the build folder to part of the project. It's after the build because the folder will be deleted and reconstructed as part of the build."]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);