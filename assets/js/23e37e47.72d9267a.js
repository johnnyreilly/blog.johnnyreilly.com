"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[93073],{78:e=>{e.exports=JSON.parse('{"permalink":"/c-sharp-9-azure-functions-in-process","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2021-07-01-c-sharp-9-azure-functions-in-process/index.md","source":"@site/blog/2021-07-01-c-sharp-9-azure-functions-in-process/index.md","title":"C# 9 in-process Azure Functions","description":"Learn to use C# 9 with .NET Core 3.1 Azure Functions in this step-by-step guide by adding new elements to your .csproj file.","date":"2021-07-01T00:00:00.000Z","tags":[{"inline":false,"label":"C#","permalink":"/tags/csharp","description":"The C# programming language."},{"inline":false,"label":"Azure Functions","permalink":"/tags/azure-functions","description":"The Azure Functions service."},{"inline":false,"label":"ASP.NET","permalink":"/tags/asp-net","description":"The web framework built by Microsoft."}],"readingTime":5.14,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"c-sharp-9-azure-functions-in-process","title":"C# 9 in-process Azure Functions","authors":"johnnyreilly","tags":["c#","azure functions","asp.net"],"image":"./title-image.png","hide_table_of_contents":false,"description":"Learn to use C# 9 with .NET Core 3.1 Azure Functions in this step-by-step guide by adding new elements to your .csproj file."},"unlisted":false,"prevItem":{"title":"Output connection strings and keys from Azure Bicep","permalink":"/output-connection-strings-and-keys-from-azure-bicep"},"nextItem":{"title":"React 18 and TypeScript","permalink":"/react-18-and-typescript"}}')},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(96540);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}},33940:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/dotnet-functions-roadmap-4f8c92dc82df396648ea7e3d35ef61ac.webp"},53897:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/title-image-b8b84348dde4a80d4de091c908ecc77d.png"},55837:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var o=t(78),s=t(74848),r=t(28453);const i={slug:"c-sharp-9-azure-functions-in-process",title:"C# 9 in-process Azure Functions",authors:"johnnyreilly",tags:["c#","azure functions","asp.net"],image:"./title-image.png",hide_table_of_contents:!1,description:"Learn to use C# 9 with .NET Core 3.1 Azure Functions in this step-by-step guide by adding new elements to your .csproj file."},a=void 0,c={image:t(53897).A,authorsImageUrls:[void 0]},l=[{value:"Azure Functions: in-process and isolated",id:"azure-functions-in-process-and-isolated",level:2},{value:"Setting up a C# 8 project",id:"setting-up-a-c-8-project",level:2},{value:"What does it take to get to C# 9?",id:"what-does-it-take-to-get-to-c-9",level:2},{value:"Adding C# 9 to the in-process function",id:"adding-c-9-to-the-in-process-function",level:2},{value:"Making a C# 9 program",id:"making-a-c-9-program",level:2},{value:"Best before...",id:"best-before",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"C# 9 has some amazing features. Azure Functions are have two modes: isolated and in-process. Whilst isolated supports .NET 5 (and hence C# 9), in-process supports .NET Core 3.1 (C# 8). This post shows how we can use C# 9 with in-process Azure Functions running on .NET Core 3.1."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"title image showing name of post and the Azure Functions logo",src:t(93874).A+"",width:"880",height:"412",loading:"lazy"})}),"\n",(0,s.jsx)(n.h2,{id:"azure-functions-in-process-and-isolated",children:"Azure Functions: in-process and isolated"}),"\n",(0,s.jsxs)(n.p,{children:['Historically .NET Azure Functions have been in-process. This changed with .NET 5 where a new model was introduced named "isolated". ',(0,s.jsx)(n.a,{href:"https://techcommunity.microsoft.com/t5/apps-on-azure/net-on-azure-functions-roadmap/ba-p/2197916",children:"To quote from the roadmap"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Running in an isolated process decouples .NET functions from the Azure Functions host\u2014allowing us to more easily support new .NET versions and address pain points associated with sharing a single process."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["However, the initial launch of isolated functions ",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/azure/azure-functions/dotnet-isolated-process-guide#differences-with-net-class-library-functions",children:"does not have the full level of functionality enjoyed by in-process functions"}),". This will happen, according the roadmap:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Long term, our vision is to have full feature parity out of process, bringing many of the features that are currently exclusive to the in-process model to the isolated model. We plan to begin delivering improvements to the isolated model after the .NET 6 general availability release."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the future, in-process functions will be retired in favour of isolated functions. However, it will be .NET 7 (scheduled to ship in November 2022) before that takes place:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"the Azure Functions roadmap image illustrating the future of .NET functions taken from https://techcommunity.microsoft.com/t5/apps-on-azure/net-on-azure-functions-roadmap/ba-p/2197916",src:t(33940).A+"",width:"998",height:"340",loading:"lazy"})}),"\n",(0,s.jsx)(n.p,{children:"As the image taken from the roadmap shows, when .NET 5 shipped, it did not support in-process Azure Functions. When .NET 6 ships in November, it should."}),"\n",(0,s.jsx)(n.p,{children:"In the meantime, we would like to use C# 9."}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-a-c-8-project",children:"Setting up a C# 8 project"}),"\n",(0,s.jsxs)(n.p,{children:["We're have the ",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local",children:"Azure Functions Core Tools"})," installed, so let's create a new function project:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'func new --worker-runtime dotnet --template "Http Trigger" --name "HelloRecord"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The above command scaffolds out a .NET Core 3.1 Azure function project which contains a single Azure function. The ",(0,s.jsx)(n.code,{children:"--worker-runtime dotnet"})," parameter is what causes an in-process .NET Core 3.1 function being created. You should have a ",(0,s.jsx)(n.code,{children:".csproj"})," file that looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<Project Sdk="Microsoft.NET.Sdk">\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n    <AzureFunctionsVersion>v3</AzureFunctionsVersion>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include="Microsoft.NET.Sdk.Functions" Version="3.0.11" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Update="host.json">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n    <None Update="local.settings.json">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n      <CopyToPublishDirectory>Never</CopyToPublishDirectory>\n    </None>\n  </ItemGroup>\n</Project>\n'})}),"\n",(0,s.jsx)(n.p,{children:"We're running with C# 8 and .NET Core 3.1 at this point. What does it take to get us to C# 9?"}),"\n",(0,s.jsx)(n.h2,{id:"what-does-it-take-to-get-to-c-9",children:"What does it take to get to C# 9?"}),"\n",(0,s.jsxs)(n.p,{children:["There's a ",(0,s.jsx)(n.a,{href:"https://www.reddit.com/r/csharp/comments/kiplz8/can_i_use_c90_with_aspnet_core_31/",children:"great post on Reddit addressing using C# 9 with .NET Core 3.1 which says:"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"<LangVersion>9.0</LangVersion>"}),", and VS even includes support for suggesting a language upgrade."]}),"\n",(0,s.jsx)(n.p,{children:"However, there are three categories of features in C#:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"features that are entirely part of the compiler. Those will work."}),"\n",(0,s.jsxs)(n.li,{children:["features that require BCL additions. Since you're on the older BCL, those will need to be backported. For example, to use init; and record, you can use ",(0,s.jsx)(n.a,{href:"https://github.com/manuelroemer/IsExternalInit",children:"https://github.com/manuelroemer/IsExternalInit"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"features that require runtime additions. Those cannot be added at all. For example, default interface members in C# 8, and covariant return types in C# 9."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Of the above, 1 and 2 add a tremendous amount of value. The features of 3 are great, but more niche. Speaking personally, I care a great deal about ",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9#record-types",children:"Record types"}),". So let's apply this."]}),"\n",(0,s.jsx)(n.h2,{id:"adding-c-9-to-the-in-process-function",children:"Adding C# 9 to the in-process function"}),"\n",(0,s.jsx)(n.p,{children:"To get C# into the mix, we want to make two changes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["add a ",(0,s.jsx)(n.code,{children:"<LangVersion>9.0</LangVersion>"})," to the ",(0,s.jsx)(n.code,{children:"<PropertyGroup>"})," element of our ",(0,s.jsx)(n.code,{children:".csproj"})," file"]}),"\n",(0,s.jsxs)(n.li,{children:["add a package reference to the ",(0,s.jsx)(n.a,{href:"https://github.com/manuelroemer/IsExternalInit",children:(0,s.jsx)(n.code,{children:"IsExternalInit"})})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The applied changes look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-diff",children:'<Project Sdk="Microsoft.NET.Sdk">\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n+    <LangVersion>9.0</LangVersion>\n    <AzureFunctionsVersion>v3</AzureFunctionsVersion>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include="Microsoft.NET.Sdk.Functions" Version="3.0.11" />\n+    <PackageReference Include="IsExternalInit" Version="1.0.1" PrivateAssets="all" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Update="host.json">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n    <None Update="local.settings.json">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n      <CopyToPublishDirectory>Never</CopyToPublishDirectory>\n    </None>\n  </ItemGroup>\n</Project>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we used ",(0,s.jsx)(n.code,{children:"dotnet add package IsExternalInit"}),", we might be using a different syntax in the ",(0,s.jsx)(n.code,{children:".csproj"}),". Be not afeard - that won't affect usage."]}),"\n",(0,s.jsx)(n.h2,{id:"making-a-c-9-program",children:"Making a C# 9 program"}),"\n",(0,s.jsxs)(n.p,{children:["Now we can theoretically use C# 9.... Let's use C# 9. We'll tweak our ",(0,s.jsx)(n.code,{children:"HelloRecord.cs"})," file, add in a simple ",(0,s.jsx)(n.code,{children:"record"})," named ",(0,s.jsx)(n.code,{children:"MessageRecord"})," and tweak the ",(0,s.jsx)(n.code,{children:"Run"})," method to use it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Azure.WebJobs;\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\n\nnamespace tmp\n{\n    public record MessageRecord(string message);\n\n    public static class HelloRecord\n    {\n        [FunctionName("HelloRecord")]\n        public static async Task<IActionResult> Run(\n            [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,\n            ILogger log)\n        {\n            log.LogInformation("C# HTTP trigger function processed a request.");\n\n            string name = req.Query["name"];\n\n            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();\n            dynamic data = JsonConvert.DeserializeObject(requestBody);\n            name = name ?? data?.name;\n\n            var responseMessage = new MessageRecord(string.IsNullOrEmpty(name)\n                ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."\n                : $"Hello, {name}. This HTTP triggered function executed successfully.");\n\n            return new OkObjectResult(responseMessage);\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we kick off our function with ",(0,s.jsx)(n.code,{children:"func start"}),":"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"screenshot of the output of the HelloRecord function",src:t(79126).A+"",width:"2082",height:"282",loading:"lazy"})}),"\n",(0,s.jsx)(n.p,{children:"We can see we can compile, and output is as we might expect and hope. Likewise if we try and debug in VS Code, we can:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"screenshot of the output of the HelloRecord function",src:t(82417).A+"",width:"2672",height:"1148",loading:"lazy"})}),"\n",(0,s.jsx)(n.h2,{id:"best-before",children:"Best before..."}),"\n",(0,s.jsx)(n.p,{children:"So, we've now a way to use C# 9 (or most of it) with in-process .NET Core 3.1 apps. This should serve until .NET 6 ships in November 2021 and we're able to use C# 9 by default."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},79126:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/calling-hello-record-3718d7a642315632d15fced0638c9489.webp"},82417:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/debugging-hello-record-086ac36a5a8c21883decfe20bb16a0a8.png"},93874:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/title-image-b8b84348dde4a80d4de091c908ecc77d.png"}}]);