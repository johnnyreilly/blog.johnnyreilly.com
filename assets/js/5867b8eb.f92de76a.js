"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[75010],{12048:e=>{e.exports=JSON.parse('{"permalink":"/typescript-4-7-and-ecmascript-module-support","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2022-06-07-typescript-4-7-and-ecmascript-module-support/index.md","source":"@site/blog/2022-06-07-typescript-4-7-and-ecmascript-module-support/index.md","title":"TypeScript 4.7 and ECMAScript Module Support","description":"As part of the TypeScript 4.7 release comes a major upgrade to ECMAScript Module Support for Node.js. This post takes a look at what that means.","date":"2022-06-07T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."},{"inline":false,"label":"JavaScript","permalink":"/tags/javascript","description":"The JavaScript programming language."}],"readingTime":5.97,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"typescript-4-7-and-ecmascript-module-support","title":"TypeScript 4.7 and ECMAScript Module Support","authors":"johnnyreilly","tags":["typescript","javascript"],"image":"./title-image.png","description":"As part of the TypeScript 4.7 release comes a major upgrade to ECMAScript Module Support for Node.js. This post takes a look at what that means.","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Azure Container Apps: dapr pubsub","permalink":"/azure-container-apps-pubsub"},"nextItem":{"title":"Azure Static Web Apps: Node.js 16 / 18 and Oryx","permalink":"/azure-static-web-apps-node-16-oryx"}}')},20779:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/title-image-51300ba4c5cfd4700a16f915bbbe51d2.png"},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>l});var i=s(96540);const n={},o=i.createContext(n);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(o.Provider,{value:t},e.children)}},29068:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/title-image-51300ba4c5cfd4700a16f915bbbe51d2.png"},88870:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=s(12048),n=s(74848),o=s(28453);const r={slug:"typescript-4-7-and-ecmascript-module-support",title:"TypeScript 4.7 and ECMAScript Module Support",authors:"johnnyreilly",tags:["typescript","javascript"],image:"./title-image.png",description:"As part of the TypeScript 4.7 release comes a major upgrade to ECMAScript Module Support for Node.js. This post takes a look at what that means.",hide_table_of_contents:!1},l=void 0,d={image:s(29068).A,authorsImageUrls:[void 0]},c=[{value:"A short history of ECMAScript modules",id:"a-short-history-of-ecmascript-modules",level:2},{value:"TypeScript support",id:"typescript-support",level:2},{value:"Making a module",id:"making-a-module",level:2},{value:"Adding TypeScript 4.7",id:"adding-typescript-47",level:2},{value:"Writing TypeScript ECMAScript modules",id:"writing-typescript-ecmascript-modules",level:2},{value:"ECMAScript and CommonJS side by side",id:"ecmascript-and-commonjs-side-by-side",level:2},{value:"What files are emitted?",id:"what-files-are-emitted",level:2},{value:"Conclusion",id:"conclusion",level:2}];function a(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components},{Head:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"As part of the TypeScript 4.7 release comes a major upgrade to ECMAScript Module Support for Node.js. This post takes a look at what that means."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"title image reading &quot;Upgrading to React 18 with TypeScript&quot; with the React, TypeScript and Definitely Typed logos`",src:s(20779).A+"",width:"1600",height:"900",loading:"lazy"})}),"\n",(0,n.jsx)(t.h2,{id:"a-short-history-of-ecmascript-modules",children:"A short history of ECMAScript modules"}),"\n",(0,n.jsx)(t.p,{children:'When ES6 shipped back in 2015, with it came the concept of modules for JavaScript. Back then it was known as "ES6 modules". These days they are called ECMAScript modules.'}),"\n",(0,n.jsx)(t.p,{children:"Whilst writing code using ECMAScript module semantics came quickly for front end, for the back end (which is generally Node.js) that has not the case. There's a number of reasons for this:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["There was already an established module system used in Node.js called ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/CommonJS",children:"CommonJS"})]}),"\n",(0,n.jsxs)(t.li,{children:["Node.js itself did not initially offer support for ECMAScript modules; in large part because of the problems associated with being able to support CommonJS ",(0,n.jsx)(t.em,{children:"as well"})," as ECMAScript modules."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["However, with the release Node.js 14 support for ECMAScript modules (AKA \"ESM\") landed. If you're interested in the details of that module support then it's worth ",(0,n.jsx)(t.a,{href:"https://blog.logrocket.com/es-modules-in-node-today/",children:"reading this post on ECMAScript modules"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"typescript-support",children:"TypeScript support"}),"\n",(0,n.jsx)(t.p,{children:"The TypeScript team have been experimenting with ways to offer support for ECMAScript modules from a Node.js perspective, and with TypeScript 4.7 support is being released."}),"\n",(0,n.jsx)(t.p,{children:"In this post we'll test drive that support by attempting to build a simple module in TypeScript using the new ECMAScript modules support. As we do this, we'll discuss what it looks like to author ECMAScript modules for Node.js in TypeScript."}),"\n",(0,n.jsx)(t.p,{children:"Let's go!"}),"\n",(0,n.jsx)(t.h2,{id:"making-a-module",children:"Making a module"}),"\n",(0,n.jsxs)(t.p,{children:["We're going to make a module named ",(0,n.jsx)(t.code,{children:"greeter"})," - let's initialise it:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-shell",children:"mkdir greeter\ncd greeter\nnpm init --yes\n"})}),"\n",(0,n.jsxs)(t.p,{children:["We now have a ",(0,n.jsx)(t.code,{children:"package.json"})," that looks something like this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "name": "greeter",\n  "version": "1.0.0",\n  "description": "",\n  "main": "index.js",\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "keywords": [],\n  "author": "",\n  "license": "ISC"\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Node.js supports a new setting in ",(0,n.jsx)(t.code,{children:"package.json"})," called ",(0,n.jsx)(t.code,{children:"type"}),". ",(0,n.jsx)(t.a,{href:"https://nodejs.org/api/packages.html#type",children:'This can be set to either "module" or "commonjs"'}),". To quote the docs:"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["Files ending with ",(0,n.jsx)(t.code,{children:".js"})," are loaded as ES modules when the nearest parent package.json file contains a top-level field ",(0,n.jsx)(t.code,{children:'"type"'})," with a value of ",(0,n.jsx)(t.code,{children:'"module"'}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["With that in mind, we'll add a ",(0,n.jsx)(t.code,{children:'"type": "module"'})," to our ",(0,n.jsx)(t.code,{children:"package.json"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"We're now ECMAScript module support compliant, let's start adding some TypeScript."}),"\n",(0,n.jsx)(t.h2,{id:"adding-typescript-47",children:"Adding TypeScript 4.7"}),"\n",(0,n.jsx)(t.p,{children:"In order that we can make use of TypeScript ECMAScript modules support we're going to install TypeScript 4.7 (currently in beta):"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"npm install typescript@4.7.0-beta --save\n"})}),"\n",(0,n.jsx)(t.p,{children:"With this in place we'll initialise a TypeScript project:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"npx tsc --init\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This will create a ",(0,n.jsx)(t.code,{children:"tsconfig.json"})," file which contains many options. We will tweak the ",(0,n.jsx)(t.code,{children:"module"})," option to be ",(0,n.jsx)(t.code,{children:"nodenext"})," to opt into ECMAScript module support:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    // ...\n    "module": "nodenext" /* Specify what module code is generated. */,\n    "outDir": "./lib" /* Specify an output folder for all emitted files. */,\n    "declaration": true /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n\n    // ...\n  }\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["We've also set the ",(0,n.jsx)(t.code,{children:"outDir"})," option, such that compiled JavaScript will go into that directory, and the ",(0,n.jsx)(t.code,{children:"declaration"})," option such that ",(0,n.jsx)(t.code,{children:".d.ts"})," files will be generated. We'll also update the ",(0,n.jsx)(t.code,{children:'"scripts"'})," section of our ",(0,n.jsx)(t.code,{children:"package.json"})," to include ",(0,n.jsx)(t.code,{children:"build"})," and ",(0,n.jsx)(t.code,{children:"start"})," scripts:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'  "scripts": {\n    "build": "tsc",\n    "start": "node lib/index.js"\n  },\n'})}),"\n",(0,n.jsx)(t.h2,{id:"writing-typescript-ecmascript-modules",children:"Writing TypeScript ECMAScript modules"}),"\n",(0,n.jsxs)(t.p,{children:["With all that set up, we're ready to write some TypeScript ECMAScript modules. First we'll write a ",(0,n.jsx)(t.code,{children:"greetings.ts"})," module:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"export function helloWorld(): string {\n  return 'hello world!';\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["There is nothing new or surprising about this; it's just a module exporting a single function named ",(0,n.jsx)(t.code,{children:"helloWorld"}),". It becomes more interesting as we write our ",(0,n.jsx)(t.code,{children:"index.ts"})," module:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { helloWorld } from './greetings.js';\n\nconst greeting = helloWorld();\n\nconsole.log(greeting);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The code above imports our ",(0,n.jsx)(t.code,{children:"helloWorld"})," function and then executes it; writing the output to the console. Not particularly noteworthy. However, the way we import is. We are importing from ",(0,n.jsx)(t.code,{children:"'./greetings.js'"}),". In the past we would have written:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { helloWorld } from './greetings';\n"})}),"\n",(0,n.jsx)(t.p,{children:"Now we write:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { helloWorld } from './greetings.js';\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This can feel slightly odd and unnatural because we have no ",(0,n.jsx)(t.code,{children:"greetings.js"})," in our codebase; only ",(0,n.jsx)(t.code,{children:"greetings.ts"}),". The imports we're writing, reflect the code that will end up being executed; once our TypeScript has been compiled to JavaScript. In ES modules relative import paths need to use extensions."]}),"\n",(0,n.jsx)(t.p,{children:"The easiest way to demonstrate that this is legitimate, is to run the code:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-shell",children:"npm run build && npm start\n"})}),"\n",(0,n.jsx)(t.p,{children:"Which results in:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-shell",children:"> greeter@1.0.0 build\n> tsc\n\n\n> greeter@1.0.0 start\n> node lib/index.js\n\nhello world!\n"})}),"\n",(0,n.jsx)(t.p,{children:"So it works!"}),"\n",(0,n.jsx)(t.h2,{id:"ecmascript-and-commonjs-side-by-side",children:"ECMAScript and CommonJS side by side"}),"\n",(0,n.jsxs)(t.p,{children:["Part of ECMAScript module support is the ability to specify the module type of a file based on the file suffix. If you use ",(0,n.jsx)(t.code,{children:".mjs"}),", you're explicitly saying a file is an ECMAScript module. If you use ",(0,n.jsx)(t.code,{children:".cjs"}),", you're explicitly saying a file is an CommonJS module. If you're authoring with TypeScript you'd use ",(0,n.jsx)(t.code,{children:"mts"})," and ",(0,n.jsx)(t.code,{children:"cts"})," respectively and they'd be transpiled to ",(0,n.jsx)(t.code,{children:"mjs"})," and ",(0,n.jsx)(t.code,{children:"cjs"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Happily Node.js allows ES modules to import CommonJS modules as if they were ES modules with a default export; which is good news for interop. Let's test that out by writing a ",(0,n.jsx)(t.code,{children:"oldGreetings.cts"})," module:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"export function helloOldWorld(): string {\n  return 'hello old world!';\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Exactly the same syntax as before. We'll adjust our ",(0,n.jsx)(t.code,{children:"index.ts"})," to consume this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { helloWorld } from './greetings.js';\nimport { helloOldWorld } from './oldGreetings.cjs';\n\nconsole.log(helloWorld());\nconsole.log(helloOldWorld());\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Note that we're importing from ",(0,n.jsx)(t.code,{children:"'./oldGreetings.cjs'"}),". We'll see if it works:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-shell",children:"npm run build && npm start\n"})}),"\n",(0,n.jsx)(t.p,{children:"Which results in:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-shell",children:"> greeter@1.0.0 build\n> tsc\n\n\n> greeter@1.0.0 start\n> node lib/index.js\n\nhello world!\nhello old world!\n"})}),"\n",(0,n.jsx)(t.p,{children:"It does work!"}),"\n",(0,n.jsx)(t.h2,{id:"what-files-are-emitted",children:"What files are emitted?"}),"\n",(0,n.jsxs)(t.p,{children:["Before we close out, it might be interesting to look at what TypeScript is doing when we run our ",(0,n.jsx)(t.code,{children:"npm run build"}),". It transpiles our TypeScript into JavaScript in our ",(0,n.jsx)(t.code,{children:"lib"})," directory:"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"A screenshot of VS Code showing the files in the lib directory",src:s(96113).A+"",width:"331",height:"314",loading:"lazy"})}),"\n",(0,n.jsxs)(t.p,{children:["Note the ",(0,n.jsx)(t.code,{children:"greetings.ts"})," file has resulted in ",(0,n.jsx)(t.code,{children:"greetings.js"})," and a ",(0,n.jsx)(t.code,{children:"greetings.d.ts"})," files. Whereas ",(0,n.jsx)(t.code,{children:"oldGreetings.cts"})," has resulted in ",(0,n.jsx)(t.code,{children:"oldGreetings.cjs"})," and a ",(0,n.jsx)(t.code,{children:"oldGreetings.d.cts"})," files; reflecting the different module types represented."]}),"\n",(0,n.jsxs)(t.p,{children:["It's also interesting to look at the difference in the emitted JavaScript. When you consider how similar the source files were. If you look at ",(0,n.jsx)(t.code,{children:"greetings.js"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"export function helloWorld() {\n  return 'hello world!';\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This is the same code as ",(0,n.jsx)(t.code,{children:"greetings.ts"})," but with types stripped. However, if we look at ",(0,n.jsx)(t.code,{children:"oldGreetings.cjs"})," we see this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.helloOldWorld = void 0;\nfunction helloOldWorld() {\n  return 'hello old world!';\n}\nexports.helloOldWorld = helloOldWorld;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In the middle the same code as ",(0,n.jsx)(t.code,{children:"oldGreetings.cts"})," but with types stripped, but around that boilerplate code that TypeScript is emitting for us to aid in interop."]}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(t.p,{children:"We've seen what TypeScript support for ECMAScript modules looks like, and how to set up a module to embrace it."}),"\n",(0,n.jsxs)(t.p,{children:["If you'd like to read up further on the topic, the ",(0,n.jsx)(t.a,{href:"https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#esm-nodejs",children:"TypeScript 4.7 beta release notes"})," are an excellent resource."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://blog.logrocket.com/typescript-4-7-ecmascript-module-support/",children:"This post was originally published on LogRocket."})}),"\n",(0,n.jsx)(i,{children:(0,n.jsx)("link",{rel:"canonical",href:"https://blog.logrocket.com/typescript-4-7-ecmascript-module-support/"})})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},96113:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/screenshot-output-files-9909cf81f2820eb8cb1148d3d3186866.png"}}]);