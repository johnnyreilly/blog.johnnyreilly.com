"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[1326],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),l=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=l(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(t),m=r,h=d["".concat(p,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},66830:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>p,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>d});t(67294);var a=t(3905);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}const s={slug:"azure-container-apps-dapr-bicep-github-actions-debug-devcontainer",title:"Azure Container Apps: dapr, devcontainer, debug and deploy",authors:"johnnyreilly",tags:["bicep","github actions","azure container apps"],image:"./title-image.png",description:"Build and deploy two Azure Container Apps using Bicep and GitHub Actions, communicate using dapr, build, run and debug in VS Code using a devcontainer.",hide_table_of_contents:!1},p=void 0,l={permalink:"/azure-container-apps-dapr-bicep-github-actions-debug-devcontainer",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2022-01-22-azure-container-apps-dapr-bicep-github-actions-debug-devcontainer/index.md",source:"@site/blog/2022-01-22-azure-container-apps-dapr-bicep-github-actions-debug-devcontainer/index.md",title:"Azure Container Apps: dapr, devcontainer, debug and deploy",description:"Build and deploy two Azure Container Apps using Bicep and GitHub Actions, communicate using dapr, build, run and debug in VS Code using a devcontainer.",date:"2022-01-22T00:00:00.000Z",formattedDate:"January 22, 2022",tags:[{label:"bicep",permalink:"/tags/bicep"},{label:"github actions",permalink:"/tags/github-actions"},{label:"azure container apps",permalink:"/tags/azure-container-apps"}],readingTime:21.6,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"azure-container-apps-dapr-bicep-github-actions-debug-devcontainer",title:"Azure Container Apps: dapr, devcontainer, debug and deploy",authors:"johnnyreilly",tags:["bicep","github actions","azure container apps"],image:"./title-image.png",description:"Build and deploy two Azure Container Apps using Bicep and GitHub Actions, communicate using dapr, build, run and debug in VS Code using a devcontainer.",hide_table_of_contents:!1},prevItem:{title:"Lazy loading images with Docusaurus",permalink:"/lazy-loading-images-with-docusaurus"},nextItem:{title:"Preload fonts with Docusaurus (updated 03/11/2022)",permalink:"/preload-fonts-with-docusaurus"}},c={image:t(565).Z,authorsImageUrls:[void 0]},d=[{value:"Updated 02/05/2022",id:"updated-02052022",level:2},{value:"What we&#39;re going to build",id:"what-were-going-to-build",level:2},{value:"Setting up our devcontainer",id:"setting-up-our-devcontainer",level:2},{value:"Create a dotnet service",id:"create-a-dotnet-service",level:2},{value:"Create a Node.js service (with Koa)",id:"create-a-nodejs-service-with-koa",level:2},{value:"Debugging dapr in VS Code",id:"debugging-dapr-in-vs-code",level:2},{value:"Containerising our services with Docker",id:"containerising-our-services-with-docker",level:2},{value:"Deploying to Azure",id:"deploying-to-azure",level:2},{value:"Setting up a resource group",id:"setting-up-a-resource-group",level:2},{value:"Secrets for GitHub Actions",id:"secrets-for-github-actions",level:2},{value:"<code>AZURE_CREDENTIALS</code> - GitHub logging into Azure",id:"azure_credentials---github-logging-into-azure",level:3},{value:"<code>PACKAGES_TOKEN</code> - Azure accessing the GitHub container registry",id:"packages_token---azure-accessing-the-github-container-registry",level:3},{value:"Deploying with GitHub Actions",id:"deploying-with-github-actions",level:2},{value:"<code>build</code> - building our image",id:"build---building-our-image",level:3},{value:"<code>deploy</code> - shipping our image to Azure",id:"deploy---shipping-our-image-to-azure",level:3},{value:"Running it",id:"running-it",level:2},{value:"<code>The subscription &#39;***&#39; cannot have more than 2 environments.</code>",id:"the-subscription--cannot-have-more-than-2-environments",level:2}],u={toc:d};function m(e){var{components:n}=e,s=o(e,["components"]);return(0,a.kt)("wrapper",i(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),a.forEach((function(n){r(e,n,t[n])}))}return e}({},u,s),{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This post shows how to build and deploy two Azure Container Apps using Bicep and GitHub Actions. These apps will communicate using ",(0,a.kt)("a",{parentName:"p",href:"https://docs.dapr.io/"},"dapr"),", be built in ",(0,a.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/remote/containers"},"VS Code using a devcontainer"),". It will be possible to debug in VS Code and run with ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose"),"."),(0,a.kt)("p",null,"This follows on from the ",(0,a.kt)("a",{parentName:"p",href:"/azure-container-apps-build-and-deploy-with-bicep-and-github-actions"},"previous post")," which built and deployed a simple web application to Azure Container Apps using Bicep and GitHub Actions using the GitHub container registry."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"eager",fetchpriority:"high",alt:"title image reading &quot;Azure Container Apps dapr, devcontainer, debug and deploy&quot;  with the dapr, Bicep, Azure Container Apps and GitHub Actions logos",src:t(565).Z,width:"1600",height:"900"})),(0,a.kt)("h2",{id:"updated-02052022"},"Updated 02/05/2022"),(0,a.kt)("p",null,"This post has been updated to reflect the migration of Azure Container Apps from the Microsoft.Web namespace to the Microsoft.App namespace in March 2022. See: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/azure-container-apps/issues/109"},"https://github.com/microsoft/azure-container-apps/issues/109")),(0,a.kt)("h2",{id:"what-were-going-to-build"},"What we're going to build"),(0,a.kt)("p",null,"As an engineer, I'm productive when:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Integrating different services together is a turnkey experience and"),(0,a.kt)("li",{parentName:"ul"},"I'm able to easily debug my code")),(0,a.kt)("p",null,"I've found that using dapr and VS Code I'm able to achieve both of these goals. I can build an application made up of multiple services, compose them together using dapr and deploy them to Azure Container Apps with relative ease."),(0,a.kt)("p",null,"In this post we're going to build an example of that from scratch, with a ",(0,a.kt)("a",{parentName:"p",href:"https://koajs.com/"},"koa/node.js")," (built with TypeScript) front end that will communicate with a ",(0,a.kt)("a",{parentName:"p",href:"https://dotnet.microsoft.com/en-us/"},"dotnet")," service via dapr."),(0,a.kt)("p",null,"All the work done in this post can be found in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/johnnyreilly/dapr-devcontainer-debug-and-deploy/tree/v1.0.0"},(0,a.kt)("inlineCode",{parentName:"a"},"dapr-devcontainer-debug-and-deploy"))," repo. As a note, if you're interested in this topic it's also worth looking at the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Azure-Samples/container-apps-store-api-microservice"},(0,a.kt)("inlineCode",{parentName:"a"},"Azure-Samples/container-apps-store-api-microservice"))," repo."),(0,a.kt)("h2",{id:"setting-up-our-devcontainer"},"Setting up our devcontainer"),(0,a.kt)("p",null,"The first thing we'll do is set up our devcontainer. We're going to use a tweaked version of the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/vscode-dev-containers/tree/main/containers/docker-in-docker"},"docker-in-docker")," image from the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/vscode-dev-containers"},"vscode-dev-containers")," repo."),(0,a.kt)("p",null,"In the root of our project we'll create a ",(0,a.kt)("inlineCode",{parentName:"p"},".devcontainer")," folder, and within that a ",(0,a.kt)("inlineCode",{parentName:"p"},"library-scripts")," folder. There's a number of communal scripts from the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/vscode-dev-containers"},(0,a.kt)("inlineCode",{parentName:"a"},"vscode-dev-containers"))," repo which we're going to lift and shift into in our ",(0,a.kt)("inlineCode",{parentName:"p"},"library-scripts")," folder:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/microsoft/vscode-dev-containers/blob/d93de4632781372d4b4da1699e27ae3a2404c96c/script-library/docker-in-docker-debian.sh"},"docker-in-docker-debian.sh")," - for installing Docker in Docker"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/microsoft/vscode-dev-containers/blob/d93de4632781372d4b4da1699e27ae3a2404c96c/script-library/azcli-debian.sh"},"azcli-debian.sh")," - for installing the Azure CLI")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},".devcontainer")," folder we want to create a ",(0,a.kt)("inlineCode",{parentName:"p"},"Dockerfile"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-docker"},'# [Choice] .NET version: 6.0, 5.0, 3.1, 2.1\nARG VARIANT=3.1\nFROM mcr.microsoft.com/vscode/devcontainers/dotnet:0-${VARIANT}\nRUN su vscode -c "umask 0002 && dotnet tool install -g Microsoft.Tye --version \\"0.10.0-alpha.21420.1\\" 2>&1"\n\n# [Choice] Node.js version: none, lts/*, 16, 14, 12, 10\nARG NODE_VERSION="14"\nRUN if [ "${NODE_VERSION}" != "none" ]; then su vscode -c "umask 0002 && . /usr/local/share/nvm/nvm.sh && nvm install ${NODE_VERSION} 2>&1"; fi\n\n# [Option] Install Azure CLI\nARG INSTALL_AZURE_CLI="false"\nCOPY library-scripts/azcli-debian.sh /tmp/library-scripts/\nRUN if [ "$INSTALL_AZURE_CLI" = "true" ]; then bash /tmp/library-scripts/azcli-debian.sh; fi \\\n    && apt-get clean -y && rm -rf /var/lib/apt/lists/* /tmp/library-scripts \\\n    && az bicep install\n\n# [Option] Enable non-root Docker access in container\nARG ENABLE_NONROOT_DOCKER="true"\n# [Option] Use the OSS Moby CLI instead of the licensed Docker CLI\nARG USE_MOBY="true"\n# [Option] Engine/CLI Version\nARG DOCKER_VERSION="latest"\n\n# Enable new "BUILDKIT" mode for Docker CLI\nENV DOCKER_BUILDKIT=1\n\nARG USERNAME=vscode\n\n# Install needed packages and setup non-root user. Use a separate RUN statement to add your\n# own dependencies. A user of "automatic" attempts to reuse an user ID if one already exists.\nCOPY library-scripts/docker-in-docker-debian.sh /tmp/library-scripts/\nRUN apt-get update \\\n    && apt-get install python3-pip -y \\\n# Use Docker script from script library to set things up\n    && /bin/bash /tmp/library-scripts/docker-in-docker-debian.sh "${ENABLE_NONROOT_DOCKER}" "${USERNAME}" "${USE_MOBY}" "${DOCKER_VERSION}"\n\n# Install Dapr\nRUN wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash \\\n    # Clean up\n    && apt-get autoremove -y && apt-get clean -y && rm -rf /var/lib/apt/lists/* /tmp/library-scripts/\n\n# Add daprd to the path for the VS Code Dapr extension.\nENV PATH="${PATH}:/home/${USERNAME}/.dapr/bin"\n\n# Install Tye\nENV PATH=/home/${USERNAME}/.dotnet/tools:$PATH\n\nVOLUME [ "/var/lib/docker" ]\n\n# Setting the ENTRYPOINT to docker-init.sh will configure non-root access\n# to the Docker socket. The script will also execute CMD as needed.\nENTRYPOINT [ "/usr/local/share/docker-init.sh" ]\nCMD [ "sleep", "infinity" ]\n\n# [Optional] Uncomment this section to install additional OS packages.\n# RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \\\n#     && apt-get -y install --no-install-recommends <your-package-list-here>\n')),(0,a.kt)("p",null,"The above is a loose riff on the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/vscode-dev-containers/blob/main/containers/docker-in-docker/.devcontainer/Dockerfile"},"docker-in-docker Dockerfile"),", lovingly mixed with the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Azure-Samples/container-apps-store-api-microservice/blob/main/.devcontainer/Dockerfile"},"Azure-Samples container-apps Dockerfile"),"."),(0,a.kt)("p",null,"It installs the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Dot Net"),(0,a.kt)("li",{parentName:"ul"},"Node.js"),(0,a.kt)("li",{parentName:"ul"},"the Azure CLI"),(0,a.kt)("li",{parentName:"ul"},"Docker"),(0,a.kt)("li",{parentName:"ul"},"Bicep"),(0,a.kt)("li",{parentName:"ul"},"Dapr")),(0,a.kt)("p",null,"Now we have our ",(0,a.kt)("inlineCode",{parentName:"p"},"Dockerfile"),", we need a ",(0,a.kt)("inlineCode",{parentName:"p"},"devcontainer.json")," to go with it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'// For format details, see https://aka.ms/devcontainer.json. For config options, see the README at:\n// https://github.com/microsoft/vscode-dev-containers/tree/v0.205.0/containers/dapr-dotnet\n{\n  "name": "dapr",\n  "build": {\n    "dockerfile": "Dockerfile",\n    "args": {\n      // Update \'VARIANT\' to pick a .NET Core version: 3.1, 5.0, 6.0\n      "VARIANT": "6.0",\n      // Options\n      "NODE_VERSION": "lts/*",\n      "INSTALL_AZURE_CLI": "true"\n    }\n  },\n  "runArgs": ["--init", "--privileged"],\n  "mounts": ["source=dind-var-lib-docker,target=/var/lib/docker,type=volume"],\n  "overrideCommand": false,\n\n  // Use this environment variable if you need to bind mount your local source code into a new container.\n  "remoteEnv": {\n    "LOCAL_WORKSPACE_FOLDER": "${localWorkspaceFolder}",\n    "PATH": "/home/vscode/.dapr/bin/:/home/vscode/.dotnet/tools:$PATH${containerEnv:PATH}"\n  },\n\n  // Set *default* container specific settings.json values on container create.\n  "settings": {},\n\n  // Add the IDs of extensions you want installed when the container is created.\n  "extensions": [\n    "ms-azuretools.vscode-dapr",\n    "ms-azuretools.vscode-docker",\n    "ms-dotnettools.csharp",\n    "ms-vscode.azurecli",\n    "ms-azuretools.vscode-bicep"\n  ],\n\n  // Use \'forwardPorts\' to make a list of ports inside the container available locally.\n  // "forwardPorts": [],\n\n  // Ensure Dapr is running on opening the container\n  "postCreateCommand": "dapr uninstall --all && dapr init",\n\n  // Comment out connect as root instead. More info: https://aka.ms/vscode-remote/containers/non-root.\n  "remoteUser": "vscode",\n  "features": {\n    "azure-cli": "latest"\n  }\n}\n')),(0,a.kt)("p",null,"The above will:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"install Node 16 / dotnet 6 and the latest Azure CLI"),(0,a.kt)("li",{parentName:"ul"},"install a number of VS Code extensions related to dapr / Docker / Bicep / Azure / C#"),(0,a.kt)("li",{parentName:"ul"},"install dapr when the container starts")),(0,a.kt)("p",null,"We're ready! Reopen your repo in a container (it will take a while first time out) and you'll be ready to go."),(0,a.kt)("h2",{id:"create-a-dotnet-service"},"Create a dotnet service"),(0,a.kt)("p",null,"Now we're going to create a dotnet service. The aim of this post is not to build a specific application, but rather to demonstrate how simple service to service communication is with dapr. So we'll use the web api template that ships with dotnet 6. That arrives with a fake weather API included, so we'll name our service accordingly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new webapi -o WeatherService\n")),(0,a.kt)("p",null,"Inside the created ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs"),", find the following line and delete it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"app.UseHttpsRedirection();\n")),(0,a.kt)("p",null,"HTTPS is important, however Azure Container Apps are going to tackle that for us."),(0,a.kt)("h2",{id:"create-a-nodejs-service-with-koa"},"Create a Node.js service (with Koa)"),(0,a.kt)("p",null,"Creating our dotnet service was very simple. We're now going to create a web app with Node.js and Koa that calls our dotnet service. This will be a little more complicated - but still surprisingly simple thanks to the great API choices of dapr."),(0,a.kt)("p",null,"Let's make that service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"mkdir WebService\ncd WebService\nnpm init -y\nnpm install koa axios --save\nnpm install @types/koa @types/node @types/axios typescript --save-dev\n")),(0,a.kt)("p",null,"We're installing the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://koajs.com/"},"koa")," - the web framework we're going to use"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://axios-http.com/"},"axios")," - to make calls to our dotnet service via HTTP / dapr"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.typescriptlang.org/"},"TypeScript")," and associated type definitions, so we can take advantage of static typing. Admittedly since we're building a minimal example this is not super beneficial; but TS makes me happy and I'd certainly want static typing in place if going beyond a simple example. Start as you mean to go on.")),(0,a.kt)("p",null,"We'll create a ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "compilerOptions": {\n    "esModuleInterop": true,\n    "module": "commonjs",\n    "target": "es2017",\n    "noImplicitAny": true,\n    "outDir": "./dist",\n    "strict": true,\n    "sourceMap": true\n  }\n}\n')),(0,a.kt)("p",null,"We'll update the ",(0,a.kt)("inlineCode",{parentName:"p"},"scripts")," section of our ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'  "scripts": {\n    "build": "tsc",\n    "start": "node dist/index.js"\n  },\n')),(0,a.kt)("p",null,"So we can build and start our web app. Now let's write it!"),(0,a.kt)("p",null,"We're going to create an ",(0,a.kt)("inlineCode",{parentName:"p"},"index.ts")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import Koa from 'koa';\nimport axios from 'axios';\n\n// How we connect to the dotnet service with dapr\nconst daprSidecarBaseUrl = `http://localhost:${\n  process.env.DAPR_HTTP_PORT || 3501\n}`;\n// app id header for service discovery\nconst weatherServiceAppIdHeaders = {\n  'dapr-app-id': process.env.WEATHER_SERVICE_NAME || 'dotnet-app',\n};\n\nconst app = new Koa();\n\napp.use(async (ctx) => {\n  try {\n    const data = await axios.get<WeatherForecast[]>(\n      `${daprSidecarBaseUrl}/weatherForecast`,\n      {\n        headers: weatherServiceAppIdHeaders,\n      },\n    );\n\n    ctx.body = `And the weather today will be ${data.data[0].summary}`;\n  } catch (exc) {\n    console.error('Problem calling weather service', exc);\n    ctx.body = 'Something went wrong!';\n  }\n});\n\nconst portNumber = 3000;\napp.listen(portNumber);\nconsole.log(`listening on port ${portNumber}`);\n\ninterface WeatherForecast {\n  date: string;\n  temperatureC: number;\n  temperatureF: number;\n  summary: string;\n}\n")),(0,a.kt)("p",null,"The above code is fairly simple but is achieving quite a lot. It:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"uses various environment variables to construct the URLs / headers which allow connecting to the dapr sidecar running alongside the app, and consequently to the weather service through the dapr sidecar running alongside the weather service. We're going to set up the environment variables which this code relies upon later."),(0,a.kt)("li",{parentName:"ul"},"spins up a web server with koa on port 3000"),(0,a.kt)("li",{parentName:"ul"},"that web server, when sent an HTTP request, will call the ",(0,a.kt)("inlineCode",{parentName:"li"},"weatherForecast")," endpoint of the dotnet app. It will grab what comes back, take the first entry in there and surface that up as the weather forecast."),(0,a.kt)("li",{parentName:"ul"},"We're also defining a ",(0,a.kt)("inlineCode",{parentName:"li"},"WeatherForecast")," interface to represent the type of the data that comes back from the dotnet service")),(0,a.kt)("p",null,"It's worth dwelling for a moment on the simplicity that dapr is affording us here. We're able to make HTTP requests to our dotnet service just like they were any other service running locally. What's actually happening is illustrated by the diagram below:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"a diagram showing traffic going from the web service to the weather service and back again via dapr",src:t(4187).Z,width:"672",height:"403"})),(0,a.kt)("p",null,"We're making HTTP requests from the web service, which look like they're going directly to the weather service. But in actual fact, they're being routed through dapr sidecars until they reach their destination. Why is this fantastic? Well there's two things we aren't having to think about here:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"certificates"),(0,a.kt)("li",{parentName:"ul"},"inter-service authentication")),(0,a.kt)("p",null,"Both of these can be complex and burn a large amount of engineering time. Because we're using dapr it's not a problem we have to solve. Isn't that great?"),(0,a.kt)("h2",{id:"debugging-dapr-in-vs-code"},"Debugging dapr in VS Code"),(0,a.kt)("p",null,"We want to be able to debug this code. We can achieve that in VS Code by setting a ",(0,a.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes"},(0,a.kt)("inlineCode",{parentName:"a"},"launch.json"))," and a ",(0,a.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/editor/tasks"},(0,a.kt)("inlineCode",{parentName:"a"},"tasks.json"))," file."),(0,a.kt)("p",null,"First of all we'll create a ",(0,a.kt)("inlineCode",{parentName:"p"},"launch.json")," file in the ",(0,a.kt)("inlineCode",{parentName:"p"},".vscode")," folder of our repo:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  "version": "0.2.0",\n  "compounds": [\n    {\n      "name": "All Container Apps",\n      "configurations": ["WeatherService", "WebService"],\n      "presentation": {\n        "hidden": false,\n        "group": "Containers",\n        "order": 1\n      }\n    }\n  ],\n  "configurations": [\n    {\n      "name": "WeatherService",\n      "type": "coreclr",\n      "request": "launch",\n      "preLaunchTask": "daprd-debug-dotnet",\n      "postDebugTask": "daprd-down-dotnet",\n      "program": "${workspaceFolder}/WeatherService/bin/Debug/net6.0/WeatherService.dll",\n      "args": [],\n      "cwd": "${workspaceFolder}/WeatherService",\n      "stopAtEntry": false,\n      "env": {\n        "DOTNET_ENVIRONMENT": "Development",\n        "DOTNET_URLS": "http://localhost:5000",\n        "DAPR_HTTP_PORT": "3500",\n        "DAPR_GRPC_PORT": "50000",\n        "DAPR_METRICS_PORT": "9090"\n      }\n    },\n\n    {\n      "name": "WebService",\n      "type": "node",\n      "request": "launch",\n      "preLaunchTask": "daprd-debug-node",\n      "postDebugTask": "daprd-down-node",\n      "program": "${workspaceFolder}/WebService/index.ts",\n      "cwd": "${workspaceFolder}/WebService",\n      "env": {\n        "NODE_ENV": "development",\n        "PORT": "3000",\n        "DAPR_HTTP_PORT": "3501",\n        "DAPR_GRPC_PORT": "50001",\n        "DAPR_METRICS_PORT": "9091",\n        "WEATHER_SERVICE_NAME": "dotnet-app"\n      },\n      "protocol": "inspector",\n      "outFiles": ["${workspaceFolder}/WebService/dist/**/*.js"],\n      "serverReadyAction": {\n        "action": "openExternally"\n      }\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"The things to note about this are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'we create a Node.js ("WebService") and a dotnet ("WeatherService") configuration. These are referenced by the ',(0,a.kt)("inlineCode",{parentName:"li"},"All Container Apps")," compound. Kicking off that will start both the Node.js and the dotnet apps."),(0,a.kt)("li",{parentName:"ul"},"The Node.js app runs a ",(0,a.kt)("inlineCode",{parentName:"li"},"daprd-debug-node")," task prior to launch and a ",(0,a.kt)("inlineCode",{parentName:"li"},"daprd-down-node")," task when debugging completes. Comparable tasks are run by the dotnet container - we'll look at these in a moment."),(0,a.kt)("li",{parentName:"ul"},"Various environment variables are configured, most of which control the behaviour of dapr. When we're debugging locally we'll be using some non-typical ports to accomodate multiple dapr sidecars being in play at the same time. Note also the ",(0,a.kt)("inlineCode",{parentName:"li"},'"WEATHER_SERVICE_NAME": "dotnet-app"')," - it's this that allows the WebService to communicate with the WeatherService - ",(0,a.kt)("inlineCode",{parentName:"li"},"dotnet-app")," is the ",(0,a.kt)("inlineCode",{parentName:"li"},"appId")," used to identify a service with dapr. We'll see that as we configure our ",(0,a.kt)("inlineCode",{parentName:"li"},"tasks.json"),".")),(0,a.kt)("p",null,"Here's the ",(0,a.kt)("inlineCode",{parentName:"p"},"tasks.json")," we must make:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  "version": "2.0.0",\n  "tasks": [\n    {\n      "label": "dotnet-build",\n      "command": "dotnet",\n      "type": "process",\n      "args": [\n        "build",\n        "${workspaceFolder}/WeatherService/WeatherService.csproj",\n        "/property:GenerateFullPaths=true",\n        "/consoleloggerparameters:NoSummary"\n      ],\n      "problemMatcher": "$msCompile"\n    },\n    {\n      "label": "daprd-debug-dotnet",\n      "appId": "dotnet-app",\n      "appPort": 5000,\n      "httpPort": 3500,\n      "grpcPort": 50000,\n      "metricsPort": 9090,\n      "type": "daprd",\n      "dependsOn": ["dotnet-build"]\n    },\n    {\n      "label": "daprd-down-dotnet",\n      "appId": "dotnet-app",\n      "type": "daprd-down"\n    },\n\n    {\n      "label": "npm-install",\n      "type": "shell",\n      "command": "npm install",\n      "options": {\n        "cwd": "${workspaceFolder}/WebService"\n      }\n    },\n    {\n      "label": "webservice-build",\n      "type": "typescript",\n      "tsconfig": "WebService/tsconfig.json",\n      "problemMatcher": ["$tsc"],\n      "group": {\n        "kind": "build",\n        "isDefault": true\n      },\n      "dependsOn": ["npm-install"]\n    },\n    {\n      "label": "daprd-debug-node",\n      "appId": "node-app",\n      "appPort": 3000,\n      "httpPort": 3501,\n      "grpcPort": 50001,\n      "metricsPort": 9091,\n      "type": "daprd",\n      "dependsOn": ["webservice-build"]\n    },\n    {\n      "label": "daprd-down-node",\n      "appId": "node-app",\n      "type": "daprd-down"\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"There's two sets of tasks here; one for the WeatherService and one for the WebService. You'll see some commonalities here. For each service there's a ",(0,a.kt)("inlineCode",{parentName:"p"},"daprd")," task that depends upon the relevant service being built and passes the various ports for the dapr sidecar to run on that runs just before debugging kicks off. To go with that, there's a ",(0,a.kt)("inlineCode",{parentName:"p"},"daprd-down")," task for each service that runs when debugging finishes and shuts down dapr."),(0,a.kt)("p",null,"We're now ready to debug our app. Let's hit F5."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of debugging the index.ts file in VS Code",src:t(35541).Z,width:"2680",height:"1080"})),(0,a.kt)("p",null,"And if we look at our browser:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of browsing Firefox at http://localhost:3000 and seeing &quot;And the weather today will be Freezing&quot; in the output",src:t(50702).Z,width:"764",height:"160"})),(0,a.kt)("p",null,"It works! We're running a Node.js WebService which, when called, is communicating with our dotnet WeatherService and surfacing up the results. Brilliant!"),(0,a.kt)("h2",{id:"containerising-our-services-with-docker"},"Containerising our services with Docker"),(0,a.kt)("p",null,"Before we can deploy each of our services, they need to be containerised."),(0,a.kt)("p",null,"First let's add a ",(0,a.kt)("inlineCode",{parentName:"p"},"Dockerfile")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherService")," folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-docker"},'FROM mcr.microsoft.com/dotnet/sdk:6.0 as build\nWORKDIR /app\nCOPY . .\nRUN dotnet restore\nRUN dotnet publish -o /app/publish\n\nFROM mcr.microsoft.com/dotnet/aspnet:6.0 as runtime\nWORKDIR /app\nCOPY --from=build /app/publish /app\n\nENV DOTNET_ENVIRONMENT=Production\nENV ASPNETCORE_URLS=\'http://+:5000\'\nEXPOSE 5000\nENTRYPOINT [ "dotnet", "/app/WeatherService.dll" ]\n')),(0,a.kt)("p",null,"Then we'll add a ",(0,a.kt)("inlineCode",{parentName:"p"},"Dockerfile")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"WebService")," folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-docker"},'FROM node:16 AS build\nWORKDIR /app\nCOPY package.json ./\nCOPY package-lock.json ./\nRUN npm install\n\nCOPY . .\nRUN npm run build\n\nFROM node:16 AS runtime\nWORKDIR /app\nCOPY --from=build /app/dist /app\nCOPY --from=build /app/package.json /app\nCOPY --from=build /app/package-lock.json /app\nRUN npm install\n\nENV NODE_ENV production\nEXPOSE 3000\nENTRYPOINT [ "node", "/app/index.js" ]\n')),(0,a.kt)("p",null,"Likely these ",(0,a.kt)("inlineCode",{parentName:"p"},"Dockerfile"),"s could be optimised further; but we're not focussed on that just now. What we have now are two simple ",(0,a.kt)("inlineCode",{parentName:"p"},"Dockerfile"),"s that will give us images we can run. Given that one depends on the other it makes sense to bring them together with a ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file which we'll place in the root of the repo:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yml"},"version: '3.4'\n\nservices:\n  weatherservice:\n    image: ${REGISTRY:-weatherservice}:${TAG:-latest}\n    build:\n      context: ./WeatherService\n      dockerfile: Dockerfile\n    ports:\n      - '50000:50000' # Dapr instances communicate over gRPC so we need to expose the gRPC port\n    environment:\n      DOTNET_ENVIRONMENT: 'Development'\n      ASPNETCORE_URLS: 'http://+:5000'\n      DAPR_HTTP_PORT: 3500\n      DAPR_GRPC_PORT: 50000\n      DAPR_METRICS_PORT: 9090\n\n  weatherservice-dapr:\n    image: 'daprio/daprd:latest'\n    command:\n      [\n        './daprd',\n        '-app-id',\n        'dotnet-app',\n        '-app-port',\n        '5000',\n        '-dapr-http-port',\n        '3500',\n        '-placement-host-address',\n        'placement:50006',\n      ]\n    network_mode: 'service:weatherservice'\n    depends_on:\n      - weatherservice\n\n  webservice:\n    image: ${REGISTRY:-webservice}:${TAG:-latest}\n    ports:\n      - '3000:3000' # The web front end port\n      - '50001:50001' # Dapr instances communicate over gRPC so we need to expose the gRPC port\n    build:\n      context: ./WebService\n      dockerfile: Dockerfile\n    environment:\n      NODE_ENV: 'development'\n      PORT: '3000'\n      DAPR_HTTP_PORT: 3501\n      DAPR_GRPC_PORT: 50001\n      DAPR_METRICS_PORT: 9091\n      WEATHER_SERVICE_NAME: 'dotnet-app'\n\n  webservice-dapr:\n    image: 'daprio/daprd:latest'\n    command: [\n        './daprd',\n        '-app-id',\n        'node-app',\n        '-app-port',\n        '3000',\n        '-dapr-http-port',\n        '3501',\n        '-placement-host-address',\n        'placement:50006', # Dapr's placement service can be reach via the docker DNS entry\n      ]\n    network_mode: 'service:webservice'\n    depends_on:\n      - webservice\n\n  dapr-placement:\n    image: 'daprio/dapr:latest'\n    command: ['./placement', '-port', '50006']\n    ports:\n      - '50006:50006'\n")),(0,a.kt)("p",null,"With this in place we can run ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose up")," and bring up our application locally."),(0,a.kt)("p",null,"And now we have docker images built, we can look at deploying them."),(0,a.kt)("h2",{id:"deploying-to-azure"},"Deploying to Azure"),(0,a.kt)("p",null,"At this point we have pretty much everything we need in terms of application code and the ability to build and debug it. Now we'd like to deploy it to Azure."),(0,a.kt)("p",null,"Let's begin with the Bicep required to deploy our Azure Container Apps."),(0,a.kt)("p",null,"In our repository we'll create an ",(0,a.kt)("inlineCode",{parentName:"p"},"infra")," directory, into which we'll place a ",(0,a.kt)("inlineCode",{parentName:"p"},"main.bicep")," file which will contain our Bicep template:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bicep"},"param branchName string\n\nparam webServiceImage string\nparam webServicePort int\nparam webServiceIsExternalIngress bool\n\nparam weatherServiceImage string\nparam weatherServicePort int\nparam weatherServiceIsExternalIngress bool\n\nparam containerRegistry string\nparam containerRegistryUsername string\n@secure()\nparam containerRegistryPassword string\n\nparam tags object\n\nparam location string = resourceGroup().location\n\nvar minReplicas = 0\nvar maxReplicas = 1\n\nvar branch = toLower(last(split(branchName, '/')))\n\nvar environmentName = 'shared-env'\nvar workspaceName = '${branch}-log-analytics'\nvar appInsightsName = '${branch}-app-insights'\nvar webServiceContainerAppName = '${branch}-web'\nvar weatherServiceContainerAppName = '${branch}-weather'\n\nvar containerRegistryPasswordRef = 'container-registry-password'\n\nresource workspace 'Microsoft.OperationalInsights/workspaces@2021-12-01-preview' = {\n  name: workspaceName\n  location: location\n  tags: tags\n  properties: {\n    sku: {\n      name: 'PerGB2018'\n    }\n    retentionInDays: 30\n    workspaceCapping: {}\n  }\n}\n\nresource appInsights 'Microsoft.Insights/components@2020-02-02' = {\n  name: appInsightsName\n  location: location\n  tags: tags\n  kind: 'web'\n  properties: {\n    Application_Type: 'web'\n    Flow_Type: 'Bluefield'\n  }\n}\n\nresource environment 'Microsoft.App/managedEnvironments@2022-01-01-preview' = {\n  name: environmentName\n  location: location\n  tags: tags\n  properties: {\n    daprAIInstrumentationKey: appInsights.properties.InstrumentationKey\n    appLogsConfiguration: {\n      destination: 'log-analytics'\n      logAnalyticsConfiguration: {\n        customerId: workspace.properties.customerId\n        sharedKey: listKeys(workspace.id, workspace.apiVersion).primarySharedKey\n      }\n    }\n  }\n}\n\nresource weatherServiceContainerApp 'Microsoft.App/containerApps@2022-01-01-preview' = {\n  name: weatherServiceContainerAppName\n  kind: 'containerapps'\n  tags: tags\n  location: location\n  properties: {\n    managedEnvironmentId: environment.id\n    configuration: {\n      dapr: {\n        enabled: true\n        appPort: weatherServicePort\n        appId: weatherServiceContainerAppName\n      }\n      secrets: [\n        {\n          name: containerRegistryPasswordRef\n          value: containerRegistryPassword\n        }\n      ]\n      registries: [\n        {\n          server: containerRegistry\n          username: containerRegistryUsername\n          passwordSecretRef: containerRegistryPasswordRef\n        }\n      ]\n      ingress: {\n        external: weatherServiceIsExternalIngress\n        targetPort: weatherServicePort\n      }\n    }\n    template: {\n      containers: [\n        {\n          image: weatherServiceImage\n          name: weatherServiceContainerAppName\n          transport: 'auto'\n        }\n      ]\n      scale: {\n        minReplicas: minReplicas\n        maxReplicas: maxReplicas\n      }\n    }\n  }\n}\n\nresource webServiceContainerApp 'Microsoft.App/containerApps@2022-01-01-preview' = {\n  name: webServiceContainerAppName\n  kind: 'containerapps'\n  tags: tags\n  location: location\n  properties: {\n    managedEnvironmentId: environment.id\n    configuration: {\n      dapr: {\n        enabled: true\n        appPort: webServicePort\n        appId: webServiceContainerAppName\n      }\n      secrets: [\n        {\n          name: containerRegistryPasswordRef\n          value: containerRegistryPassword\n        }\n      ]\n      registries: [\n        {\n          server: containerRegistry\n          username: containerRegistryUsername\n          passwordSecretRef: containerRegistryPasswordRef\n        }\n      ]\n      ingress: {\n        external: webServiceIsExternalIngress\n        targetPort: webServicePort\n      }\n    }\n    template: {\n      containers: [\n        {\n          image: webServiceImage\n          name: webServiceContainerAppName\n          transport: 'auto'\n          env: [\n            {\n              name: 'WEATHER_SERVICE_NAME'\n              value: weatherServiceContainerAppName\n            }\n          ]\n        }\n      ]\n      scale: {\n        minReplicas: minReplicas\n        maxReplicas: maxReplicas\n      }\n    }\n  }\n}\n\noutput webServiceUrl string = webServiceContainerApp.properties.latestRevisionFqdn\n")),(0,a.kt)("p",null,"This will deploy two container apps - one for our ",(0,a.kt)("inlineCode",{parentName:"p"},"WebService")," and one for our ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherService"),". Alongside that we've resources for logging and environments."),(0,a.kt)("h2",{id:"setting-up-a-resource-group"},"Setting up a resource group"),(0,a.kt)("p",null,"With our Bicep in place, we're going to need a resource group to send it to. Right now, Azure Container Apps aren't available everywhere. So we're going to create ourselves a resource group in North Europe which does support ACAs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"az group create -g rg-aca -l northeurope\n")),(0,a.kt)("h2",{id:"secrets-for-github-actions"},"Secrets for GitHub Actions"),(0,a.kt)("p",null,"We're aiming to set up a GitHub Action to handle our deployment. This will depend upon a number of secrets:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"Screenshot of the secrets in the GitHub website that we need to create",src:t(7175).Z,width:"1544",height:"250"})),(0,a.kt)("p",null,"We'll need to create each of these secrets."),(0,a.kt)("h3",{id:"azure_credentials---github-logging-into-azure"},(0,a.kt)("inlineCode",{parentName:"h3"},"AZURE_CREDENTIALS")," - GitHub logging into Azure"),(0,a.kt)("p",null,"So GitHub Actions can interact with Azure on our behalf, we need to provide it with some credentials. We'll use the Azure CLI to create these:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'az ad sp create-for-rbac --name "myApp" --role contributor \\\n    --scopes /subscriptions/{subscription-id}/resourceGroups/{resource-group} \\\n    --sdk-auth\n')),(0,a.kt)("p",null,"Remember to replace the ",(0,a.kt)("inlineCode",{parentName:"p"},"{subscription-id}")," with your subscription id and ",(0,a.kt)("inlineCode",{parentName:"p"},"{resource-group}")," with the name of your resource group (",(0,a.kt)("inlineCode",{parentName:"p"},"rg-aca")," if you're following along). This command will pump out a lump of JSON that looks something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "clientId": "a-client-id",\n  "clientSecret": "a-client-secret",\n  "subscriptionId": "a-subscription-id",\n  "tenantId": "a-tenant-id",\n  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",\n  "resourceManagerEndpointUrl": "https://management.azure.com/",\n  "activeDirectoryGraphResourceId": "https://graph.windows.net/",\n  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",\n  "galleryEndpointUrl": "https://gallery.azure.com/",\n  "managementEndpointUrl": "https://management.core.windows.net/"\n}\n')),(0,a.kt)("p",null,"Take this and save it as the ",(0,a.kt)("inlineCode",{parentName:"p"},"AZURE_CREDENTIALS")," secret in Azure."),(0,a.kt)("h3",{id:"packages_token---azure-accessing-the-github-container-registry"},(0,a.kt)("inlineCode",{parentName:"h3"},"PACKAGES_TOKEN")," - Azure accessing the GitHub container registry"),(0,a.kt)("p",null,"We also need a secret for accessing packages from Azure. We're going to be publishing packages to the GitHub container registry. Azure is going to need to be able to access this when we're deploying. ACA deployment works by telling Azure where to look for an image and providing any necessary credentials to do the acquisition. To facilitate this we'll set up a ",(0,a.kt)("inlineCode",{parentName:"p"},"PACKAGES_TOKEN")," secret. This is a GitHub personal access token with the ",(0,a.kt)("inlineCode",{parentName:"p"},"read:packages")," scope. ",(0,a.kt)("a",{parentName:"p",href:"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token"},"Follow the instructions here to create the token.")),(0,a.kt)("h2",{id:"deploying-with-github-actions"},"Deploying with GitHub Actions"),(0,a.kt)("p",null,"With our secrets configured, we're now well placed to write our GitHub Action. We'll create a ",(0,a.kt)("inlineCode",{parentName:"p"},".github/workflows/build-and-deploy.yaml")," file in our repository and populate it thusly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"# yaml-language-server: $schema=./build.yaml\nname: Build and Deploy\non:\n  # Trigger the workflow on push or pull request,\n  # but only for the main branch\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n    # Publish semver tags as releases.\n    tags: ['v*.*.*']\n  workflow_dispatch:\n\nenv:\n  RESOURCE_GROUP: rg-aca\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        services:\n          [\n            { 'imageName': 'node-service', 'directory': './WebService' },\n            { 'imageName': 'dotnet-service', 'directory': './WeatherService' },\n          ]\n    permissions:\n      contents: read\n      packages: write\n    outputs:\n      image-node: ${{ steps.image-tag.outputs.image-node-service }}\n      image-dotnet: ${{ steps.image-tag.outputs.image-dotnet-service }}\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      # Login against a Docker registry except on PR\n      # https://github.com/docker/login-action\n      - name: Log into registry ${{ env.REGISTRY }}\n        if: github.event_name != 'pull_request'\n        uses: docker/login-action@v1\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      # Extract metadata (tags, labels) for Docker\n      # https://github.com/docker/metadata-action\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v3\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.services.imageName }}\n          tags: |\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n            type=ref,event=branch\n            type=sha\n\n      # Build and push Docker image with Buildx (don't push on PR)\n      # https://github.com/docker/build-push-action\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v2\n        with:\n          context: ${{ matrix.services.directory }}\n          push: ${{ github.event_name != 'pull_request' }}\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Output image tag\n        id: image-tag\n        run: echo \"::set-output name=image-${{ matrix.services.imageName }}::${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.services.imageName }}:sha-$(git rev-parse --short HEAD)\" | tr '[:upper:]' '[:lower:]'\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: [build]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Azure Login\n        uses: azure/login@v1\n        with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n      - name: Deploy bicep\n        uses: azure/CLI@v1\n        if: github.event_name != 'pull_request'\n        with:\n          inlineScript: |\n            REF_SHA='${{ github.ref }}.${{ github.sha }}'\n            DEPLOYMENT_NAME=\"${REF_SHA////-}\"\n            echo \"DEPLOYMENT_NAME=$DEPLOYMENT_NAME\"\n\n            TAGS='{\"owner\":\"johnnyreilly\", \"email\":\"johnny_reilly@hotmail.com\"}'\n            az deployment group create \\\n              --resource-group ${{ env.RESOURCE_GROUP }} \\\n              --name \"$DEPLOYMENT_NAME\" \\\n              --template-file ./infra/main.bicep \\\n              --parameters \\\n                  branchName='${{ github.event.number == 0 && 'main' ||  format('pr-{0}', github.event.number) }}' \\\n                  webServiceImage='${{ needs.build.outputs.image-node }}' \\\n                  webServicePort=3000 \\\n                  webServiceIsExternalIngress=true \\\n                  weatherServiceImage='${{ needs.build.outputs.image-dotnet }}' \\\n                  weatherServicePort=5000 \\\n                  weatherServiceIsExternalIngress=false \\\n                  containerRegistry=${{ env.REGISTRY }} \\\n                  containerRegistryUsername=${{ github.actor }} \\\n                  containerRegistryPassword=${{ secrets.PACKAGES_TOKEN }} \\\n                  tags=\"$TAGS\"\n")),(0,a.kt)("p",null,"There's a lot in this workflow. Let's dig into the ",(0,a.kt)("inlineCode",{parentName:"p"},"build")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"deploy")," jobs to see what's happening."),(0,a.kt)("h3",{id:"build---building-our-image"},(0,a.kt)("inlineCode",{parentName:"h3"},"build")," - building our image"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"build")," job is all about building our container images and pushing then to the GitHub registry. It's heavily inspired by ",(0,a.kt)("a",{parentName:"p",href:"https://twitter.com/jeffhollan"},"Jeff Hollan"),"'s ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Azure-Samples/container-apps-store-api-microservice"},"Azure sample app GHA"),". When we look at the ",(0,a.kt)("inlineCode",{parentName:"p"},"strategy")," we can see a ",(0,a.kt)("inlineCode",{parentName:"p"},"matrix")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"services")," consisting of two services; our node app and our dotnet app:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"strategy:\n  matrix:\n    services:\n      [\n        { 'imageName': 'node-service', 'directory': './WebService' },\n        { 'imageName': 'dotnet-service', 'directory': './WeatherService' },\n      ]\n")),(0,a.kt)("p",null,"This is a matrix because a typical use case of an Azure Container Apps will be multi-container - just as this is. The ",(0,a.kt)("inlineCode",{parentName:"p"},"outputs")," pumps out the details of our ",(0,a.kt)("inlineCode",{parentName:"p"},"image-node")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"image-dotnet")," images to be used later:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"outputs:\n  image-node: ${{ steps.image-tag.outputs.image-node-service }}\n  image-dotnet: ${{ steps.image-tag.outputs.image-dotnet-service }}\n")),(0,a.kt)("p",null,"With that understanding in place, let's examine what each of the steps in the ",(0,a.kt)("inlineCode",{parentName:"p"},"build")," job does"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Log into registry")," - logs into the GitHub container registry"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Extract Docker metadata")," - acquire tags which will be used for versioning"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Build and push Docker image")," - build the docker image and if this is not a PR: tag, label and push it to the registry"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Output image tag")," - write out the image tag for usage in deployment")),(0,a.kt)("h3",{id:"deploy---shipping-our-image-to-azure"},(0,a.kt)("inlineCode",{parentName:"h3"},"deploy")," - shipping our image to Azure"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"deploy")," job runs the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az_deployment_group_create"},(0,a.kt)("inlineCode",{parentName:"a"},"az deployment group create"))," command which performs a deployment of our ",(0,a.kt)("inlineCode",{parentName:"p"},"main.bicep")," file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- name: Deploy bicep\n  uses: azure/CLI@v1\n  if: github.event_name != 'pull_request'\n  with:\n    inlineScript: |\n      REF_SHA='${{ github.ref }}.${{ github.sha }}'\n      DEPLOYMENT_NAME=\"${REF_SHA////-}\"\n      echo \"DEPLOYMENT_NAME=$DEPLOYMENT_NAME\"\n\n      TAGS='{\"owner\":\"johnnyreilly\", \"email\":\"johnny_reilly@hotmail.com\"}'\n      az deployment group create \\\n        --resource-group ${{ env.RESOURCE_GROUP }} \\\n        --name \"$DEPLOYMENT_NAME\" \\\n        --template-file ./infra/main.bicep \\\n        --parameters \\\n            branchName='${{ github.event.number == 0 && 'main' ||  format('pr-{0}', github.event.number) }}' \\\n            webServiceImage='${{ needs.build.outputs.image-node }}' \\\n            webServicePort=3000 \\\n            webServiceIsExternalIngress=true \\\n            weatherServiceImage='${{ needs.build.outputs.image-dotnet }}' \\\n            weatherServicePort=5000 \\\n            weatherServiceIsExternalIngress=false \\\n            containerRegistry=${{ env.REGISTRY }} \\\n            containerRegistryUsername=${{ github.actor }} \\\n            containerRegistryPassword=${{ secrets.PACKAGES_TOKEN }} \\\n            tags=\"$TAGS\"\n")),(0,a.kt)("p",null,"In either case we pass the same set of parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"branchName='${{ github.event.number == 0 && 'main' ||  format('pr-{0}', github.event.number) }}' \\\nwebServiceImage='${{ needs.build.outputs.image-node }}' \\\nwebServicePort=3000 \\\nwebServiceIsExternalIngress=true \\\nweatherServiceImage='${{ needs.build.outputs.image-dotnet }}' \\\nweatherServicePort=5000 \\\nweatherServiceIsExternalIngress=true \\\ncontainerRegistry=${{ env.REGISTRY }} \\\ncontainerRegistryUsername=${{ github.actor }} \\\ncontainerRegistryPassword=${{ secrets.PACKAGES_TOKEN }} \\\ntags=\"$tags\"\n")),(0,a.kt)("p",null,"These are either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"secrets we set up earlier"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.github.com/en/actions/learn-github-actions/contexts"},"special github variables")),(0,a.kt)("li",{parentName:"ul"},"environment variables declared at the start of the script or"),(0,a.kt)("li",{parentName:"ul"},"outputs from the build step - this is where we acquire our node and dotnet images")),(0,a.kt)("h2",{id:"running-it"},"Running it"),(0,a.kt)("p",null,"When the GitHub Action has been run you'll find that Azure Container Apps are now showing up inside the Azure Portal in your resource group, alongside the other resources:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of the Azure Container App&#39;s resource group in the Azure Portal",src:t(42643).Z,width:"2635",height:"1142"})),(0,a.kt)("p",null,"If we take a look at our web ACA we'll see"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of the web Azure Container App&#39;s in the Azure Portal",src:t(52684).Z,width:"1064",height:"612"})),(0,a.kt)("p",null,"And when we take a closer look at the container app, we find a URL we can navigate to:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of the Azure Container App in the Azure Portal revealing it&#39;s URL",src:t(23770).Z,width:"900",height:"332"})),(0,a.kt)("p",null,"Congratulations! You've built and deployed a simple web app to Azure Container Apps with Bicep and GitHub Actions and secrets."),(0,a.kt)("h2",{id:"the-subscription--cannot-have-more-than-2-environments"},(0,a.kt)("inlineCode",{parentName:"h2"},"The subscription '***' cannot have more than 2 environments.")),(0,a.kt)("p",null,"Before signing off, it's probably worth sharing this gotcha. If you've been playing with Azure Container Apps you may have already deployed an \"environment\" (",(0,a.kt)("inlineCode",{parentName:"p"},"Microsoft.Web/kubeEnvironments"),"). It's fairly common to have a limit of one environment per subscription, which is what this message is saying. So either delete other environments, share the one you have or arrange to raise the limit on your subscription."))}m.isMDXComponent=!0},50702:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/app-running-f560d14fbaf0900443be72da0e2531a7.png"},4187:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/dapr-sidecar.drawio-eab5aa6a6db152b2d4b5dc0a2ee50cc2.svg"},35541:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/debugging-660bb23b8958f3362aac922d0a188a9a.png"},52684:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/screenshot-azure-portal-container-app-9b737cce4d0bdd153a640ce08538cb4f.png"},42643:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/screenshot-azure-portal-resource-group-b64514fc0f1f74a4c50a2fa94f13d5c2.png"},7175:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/screenshot-github-secrets-29ef6fe4f7b252562e7a9130dcb05f7c.png"},23770:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/screenshot-working-app-2e37ea9245120191848855f9ca826399.png"},565:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/title-image-ce3537156e15ded6dd344102c8a164b7.png"}}]);