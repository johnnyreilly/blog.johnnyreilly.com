"use strict";(self.webpackChunkblog_johnnyreilly_com=self.webpackChunkblog_johnnyreilly_com||[]).push([[27759],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||r;return n?i.createElement(m,o(o({ref:t},c),{},{components:n})):i.createElement(m,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},38282:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var i=n(87462),a=n(63366),r=(n(67294),n(3905)),o=["components"],s={title:"Migrating from AngularJS to AngularTS - a walkthrough",authors:"johnnyreilly",tags:["Jasmine","TypeScript","Unit tests","AngularJS"],hide_table_of_contents:!1},l=void 0,p={permalink:"/2014/06/01/migrating-from-angularjs-to-angularts",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/blog/2014-06-01-migrating-from-angularjs-to-angularts/index.md",source:"@site/blog/2014-06-01-migrating-from-angularjs-to-angularts/index.md",title:"Migrating from AngularJS to AngularTS - a walkthrough",description:"It started with nuns. Don't all good stories start that way? One of my (many) aunts is a Poor Clare nun. At some point in the distant past I was cajoled into putting together a simple website for her convent. This post is a walkthrough of how to migrate from AngularJS using JavaScript to AngularJS using TypeScript. It just so happens that the AngularJS app in question is the one that belongs to my mother's sister's convent.",date:"2014-06-01T00:00:00.000Z",formattedDate:"June 1, 2014",tags:[{label:"Jasmine",permalink:"/tags/jasmine"},{label:"TypeScript",permalink:"/tags/type-script"},{label:"Unit tests",permalink:"/tags/unit-tests"},{label:"AngularJS",permalink:"/tags/angular-js"}],readingTime:12.545,truncated:!1,authors:[{name:"John Reilly",url:"https://twitter.com/johnny_reilly",imageURL:"https://blog.johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{title:"Migrating from AngularJS to AngularTS - a walkthrough",authors:"johnnyreilly",tags:["Jasmine","TypeScript","Unit tests","AngularJS"],hide_table_of_contents:!1},prevItem:{title:"A folk story wherein we shall find dates, DataAnnotations & data impedance mismatch",permalink:"/2014/06/20/dates-DataAnnotations-and-data-impedance-mismatch"},nextItem:{title:"Team Foundation Server, Continuous Integration and separate projects for JavaScript unit tests",permalink:"/2014/05/15/team-foundation-server-continuous-integration-and-javascript-unit-tests-in-unit-test-project"}},c={authorsImageUrls:[void 0]},u=[{value:"TL;DR - grab what you need",id:"tldr---grab-what-you-need",level:2},{value:"Background",id:"background",level:2},{value:"Typings",id:"typings",level:2},{value:"Changing JS files to TS files",id:"changing-js-files-to-ts-files",level:2},{value:"Recap",id:"recap",level:2},{value:"TypeScriptify <code>app.ts</code>",id:"typescriptify-appts",level:2},{value:"TypeScriptify <code>siteSectionService.ts</code>",id:"typescriptify-sitesectionservicets",level:2},{value:"TypeScriptify <code>prayerRequestService.ts</code>",id:"typescriptify-prayerrequestservicets",level:2},{value:"TypeScriptify <code>prayerRequestController.ts</code>",id:"typescriptify-prayerrequestcontrollerts",level:2},{value:"TypeScriptify <code>navController.ts</code>",id:"typescriptify-navcontrollerts",level:2},{value:"TypeScriptify <code>mainController.ts</code>",id:"typescriptify-maincontrollerts",level:2}],h={toc:u};function d(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It started with nuns. Don't all good stories start that way? One of my (many) aunts is a Poor Clare nun. At some point in the distant past I was cajoled into putting together a simple website for her convent. This post is a walkthrough of how to migrate from AngularJS using JavaScript to AngularJS using TypeScript. It just so happens that the AngularJS app in question is the one that belongs to my mother's sister's convent."),(0,r.kt)("h2",{id:"tldr---grab-what-you-need"},"TL;DR - grab what you need"),(0,r.kt)("p",null,'For reference the complete "before" and "after" projects can be found on GitHub ',(0,r.kt)("a",{parentName:"p",href:"https://github.com/johnnyreilly/AngularJS2AngularTS"},"here"),". This is available so people can see clearly what changes have been made in the migration."),(0,r.kt)("p",null,"The content of the site is available for ",(0,r.kt)("u",null,"reference only")),(0,r.kt)("p",null,'. (Not that I can really imagine people creating their own "Poor Clares" site and hawking it to convents around the globe but I thought I\'d make the point.)'),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,"I've been quietly maintaining this website / app for quite a while now. It's a very simple site; 95% of it is static content about the convent. The one piece of actual functionality is a page which allows the user of the website to send a prayer request to the nuns at the convent."),(0,r.kt)("p",null,"Behind the scenes this sends 2 emails:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The first back to the person who submitted the prayer request assuring them that they will be prayed for."),(0,r.kt)("li",{parentName:"ul"},"The second to the convent telling them the details of what the person would like prayer for.")),(0,r.kt)("aside",null,(0,r.kt)("em",null,"It's not accidental that I am not sharing the location of my aunt's website in this post. Given the inherent mischievousness of most developers (I should know, I am one) I harbour a fear that readers of this post might go away and submit many an insincere prayer request (or worse) to the convent. If that's you I don't intend to help you. You're clever, you'll find the site if you are so minded. But please know that the nuns who read any of your prayer requests are wonderful people (nuns get a bad rep) and that they love you. They *",(0,r.kt)("strong",null,"will"),"* pray for you. They're good like that. I appeal to your better nature on this.")),(0,r.kt)("p",null,"Right now you are probably thinking this is an unusual post. Perhaps it is, but bear with me."),(0,r.kt)("p",null,"Over time the website has had many incarnations. It's been table-based layout, it's used Kendo UI, it's used Bootstrap. It's been static HTML, it's been ASP.Net WebForms, it's been ASP.Net MVC and it's currently built using ",(0,r.kt)("strong",{parentName:"p"},"AngularJS")," with ",(0,r.kt)("strong",{parentName:"p"},"MVC")," on the back-end to handle bundling / minification and dispatching of emails."),(0,r.kt)("p",null,"I decided to migrate this AngularJS app to use TypeScript. As I did that I thought I'd document the process for anyone else who might be considering doing something similar. As it happens this is a particularly good candidate for migration as there's a full unit test suite for the app (written with Jasmine). Once I've finished the migration these unit tests should pass, just as they do currently."),(0,r.kt)("p",null,'You are probably thinking to yourself "but TypeScript is just about adding compile-time annotations right? How could the unit tests not pass after migration?" Fair point, well made. Well that is generally true but I have something slightly different planned when we get to the controllers - you\'ll see what I mean...'),(0,r.kt)("p",null,"It's also a good candidate for documenting a walkthrough as it's a particularly small and simple Angular app. It consists of just ",(0,r.kt)("strong",{parentName:"p"},"3 controllers"),", ",(0,r.kt)("strong",{parentName:"p"},"2 services")," and ",(0,r.kt)("strong",{parentName:"p"},"1 app"),"."),(0,r.kt)("p",null,"Before I kick off I thought I'd list a couple of guidelines / caveats on this post:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"I don't intend to say much about the architecture of this application - I want to focus on the migration from JavaScript to TypeScript."),(0,r.kt)("li",{parentName:"ul"},'The choices that I make for the migration path do not necessarily reflect the "one true way". Rather, they are pragmatic choices that I am making - there may be alternatives approaches here and there that could be used instead.'),(0,r.kt)("li",{parentName:"ul"},"I love Visual Studio - it's my IDE of choice and the one I am using as I perform the migration. Some of the points that I will make are Visual Studio specific - I will try and highlight that when appropriate.")),(0,r.kt)("h2",{id:"typings"},"Typings"),(0,r.kt)("p",null,"The first thing we're going to need to get going are the Angular typing files which can be found on Definitely Typed ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/borisyankov/DefinitelyTyped/tree/master/angularjs"},"here"),". Since these typings are made available over ",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/angularjs.TypeScript.DefinitelyTyped/"},"NuGet")," I'm going to pull them in with a wave of my magic ",(0,r.kt)("inlineCode",{parentName:"p"},"Install-Package angularjs.TypeScript.DefinitelyTyped"),"."),(0,r.kt)("p",null,"As well as pulling in the typing files Visual Studio 2013 has also made some tweaks to my ",(0,r.kt)("inlineCode",{parentName:"p"},"PoorClaresAngular.csproj")," file which it tells me about."),(0,r.kt)("p",null,"And these are the TypeScript specific additions that Visual Studio has made to ",(0,r.kt)("inlineCode",{parentName:"p"},"PoorClaresAngular.csproj"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<Import\n   Project="$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props"\n   Condition="Exists(\'$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\')" />\n\n  <TypeScriptToolsVersion>1.0</TypeScriptToolsVersion>\n\n  <Import\n   Project="$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets"\n   Condition="Exists(\'$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\')" />\n')),(0,r.kt)("p",null,"I'm going to add one extra of my own:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"<TypeScriptNoImplicitAny>True</TypeScriptNoImplicitAny>\n")),(0,r.kt)("p",null,"This prevents you having variables of type ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," in your TypeScript codebase without you implicitly specifying the type. You can live without this but I've found it's useful to catch where you're missing out on the benefit of static typing. Further to that, this option can be particularly useful when performing a migration. It will become obvious why this is the case as we go on."),(0,r.kt)("p",null,"I decline the kind opportunity to further search NuGet as I'm already on my way typing-wise. So let's review what has happened. Below you can see the typing files that have been pulled in and that the project and packages files were amended."),(0,r.kt)("h2",{id:"changing-js-files-to-ts-files"},"Changing JS files to TS files"),(0,r.kt)("p",null,"This really should be as simple as changing all the JavaScript files underneath the ",(0,r.kt)("inlineCode",{parentName:"p"},"js")," directory to have the suffix ",(0,r.kt)("inlineCode",{parentName:"p"},"ts"),"."),(0,r.kt)("p",null,"And if you're not using Visual Studio it is. But if you are using Visual Studio there's a certain amount of fiddling required to include the generated ",(0,r.kt)("inlineCode",{parentName:"p"},".js")," and ",(0,r.kt)("inlineCode",{parentName:"p"},".js.map")," files associated with each ",(0,r.kt)("inlineCode",{parentName:"p"},".ts")," file. The easiest (hah!) thing to do is to crack open the project and wherever you find a ",(0,r.kt)("inlineCode",{parentName:"p"},'&lt;TypeScriptCompile Include="js\\somePath.ts" /&gt;')," to add in 2 ",(0,r.kt)("inlineCode",{parentName:"p"},"Content")," statements, one for each generated file which states the dependency on the TypeScript file. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<TypeScriptCompile Include="js\\services\\siteSectionService.ts" />\n    <Content Include="js\\services\\siteSectionService.js">\n      <DependentUpon>siteSectionService.ts</DependentUpon>\n    </Content>\n    <Content Include="js\\services\\siteSectionService.js.map">\n      <DependentUpon>siteSectionService.ts</DependentUpon>\n    </Content>\n')),(0,r.kt)("p",null,"It's a bit of a pain to have to do this at the moment. Hopefully the Visual Studio tooling will catch up so this sort of tweaking becomes unnecessary."),(0,r.kt)("h2",{id:"recap"},"Recap"),(0,r.kt)("p",null,"So, where are we? Well, we've got our project ready for TypeScript, we've pulled in the Angular typings from Definitely Typed and we've turned all our JavaScript files in the ",(0,r.kt)("inlineCode",{parentName:"p"},"js")," directory into TypeScript files."),(0,r.kt)("p",null,"Now we can actually start working through our TypeScript files and ensuring we're all typed correctly. Please note that because I'm working in Visual Studio I get the benefit of implicit referencing; I don't have to explicitly state the typing files each TypeScript file relies on at the head of the file (eg ",(0,r.kt)("inlineCode",{parentName:"p"},'/// &lt;reference path="angularjs/angular.d.ts" /&gt;'),"). If you aren't working in Visual Studio then you'd need to add these yourself."),(0,r.kt)("h2",{id:"typescriptify-appts"},"TypeScriptify ",(0,r.kt)("inlineCode",{parentName:"h2"},"app.ts")),(0,r.kt)("p",null,"Opening up ",(0,r.kt)("inlineCode",{parentName:"p"},"app.ts")," we're presented with a few red squigglies."),(0,r.kt)("p",null,"These red squigglies are the direct result of my earlier opting in to ",(0,r.kt)("inlineCode",{parentName:"p"},"NoImplicitAny"),". So in my view it's already paid for itself as it's telling me where I could start using typings. So to get things working nicely I'll give ",(0,r.kt)("inlineCode",{parentName:"p"},"$routeProvider")," the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"ng.route.IRouteProvider")," and I'll explicitly specify the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," for the 2 ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// ...\n    function ($routeProvider: ng.route.IRouteProvider) {\n\n        function getTheConventTemplateUrl(params: any) {\n            var view = params.view || "home";\n            return "partials/theConvent/" + view + ".html";\n        }\n\n        function getMainTemplateUrl(params: any) {\n            var view = params.view || "home";\n            return "partials/main/" + view + ".html";\n        }\n\n        // ...\n    }\n    // ...\n')),(0,r.kt)("h2",{id:"typescriptify-sitesectionservicets"},"TypeScriptify ",(0,r.kt)("inlineCode",{parentName:"h2"},"siteSectionService.ts")),(0,r.kt)("p",null,"Opening up ",(0,r.kt)("inlineCode",{parentName:"p"},"siteSectionService.ts")," we're only presented with a single squiggly, and for the same reason as last time."),(0,r.kt)("p",null,"This error is easily remedied by giving ",(0,r.kt)("inlineCode",{parentName:"p"},"path")," the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,r.kt)("p",null,"What's more interesting / challenging is thinking about how we want to enforce the definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"siteSectionService"),". Remember, this is a service and as such it will be re-used elsewhere in the application (in both ",(0,r.kt)("inlineCode",{parentName:"p"},"navController")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mainController"),"). What we need is an interface that describes what our (revealing module pattern) service exposes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\ninterface ISiteSectionService {\n  getSiteSection: () => string;\n  determineSiteSection: (path: string) => void;\n}\n\nangular.module('poorClaresApp.services').factory(\n  'siteSectionService',\n\n  [\n    // No dependencies at present\n    function (): ISiteSectionService {\n      var siteSection = 'home';\n\n      function getSiteSection() {\n        return siteSection;\n      }\n\n      function determineSiteSection(path: string) {\n        var newSiteSection = 'home';\n\n        if (path.indexOf('/theConvent/') !== -1) {\n          newSiteSection = 'theConvent';\n        } else if (path !== '/') {\n          newSiteSection = 'main';\n        }\n\n        siteSection = newSiteSection;\n      }\n\n      return {\n        getSiteSection: getSiteSection,\n        determineSiteSection: determineSiteSection,\n      };\n    },\n  ]\n);\n")),(0,r.kt)("p",null,"As you can see the ",(0,r.kt)("inlineCode",{parentName:"p"},"ISiteSectionService ")," interface is marked as the return type of the function. This ensures that what we return from the function satisfies that definition. Also, it allows us to re-use that interface elsewhere (as we will do later)."),(0,r.kt)("h2",{id:"typescriptify-prayerrequestservicets"},"TypeScriptify ",(0,r.kt)("inlineCode",{parentName:"h2"},"prayerRequestService.ts")),(0,r.kt)("p",null,"Opening up ",(0,r.kt)("inlineCode",{parentName:"p"},"prayerRequestService.ts")," we're again in ",(0,r.kt)("inlineCode",{parentName:"p"},"NoImplicitAny")," country."),(0,r.kt)("p",null,"This is fixed up by defining ",(0,r.kt)("inlineCode",{parentName:"p"},"$http")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"ng.IHttpService")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"email")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"prayFor")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,r.kt)("p",null,"As with ",(0,r.kt)("inlineCode",{parentName:"p"},"siteSectionService")," we need to create an interface to define what ",(0,r.kt)("inlineCode",{parentName:"p"},"prayerRequestService")," exposes. This leaves us with this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\ninterface IPrayerRequestService {\n  sendPrayerRequest: (\n    email: string,\n    prayFor: string\n  ) => ng.IPromise<{\n    success: boolean;\n    text: string;\n  }>;\n}\n\nangular.module('poorClaresApp.services').factory(\n  'prayerRequestService',\n\n  [\n    '$http',\n    function ($http: ng.IHttpService): IPrayerRequestService {\n      var url = '/PrayerRequest';\n\n      function sendPrayerRequest(email: string, prayFor: string) {\n        var params = { email: email, prayFor: prayFor };\n\n        return $http.post(url, params).then(function (response) {\n          return {\n            success: response.data.success,\n            text: response.data.text,\n          };\n        });\n      }\n\n      return {\n        sendPrayerRequest: sendPrayerRequest,\n      };\n    },\n  ]\n);\n")),(0,r.kt)("h2",{id:"typescriptify-prayerrequestcontrollerts"},"TypeScriptify ",(0,r.kt)("inlineCode",{parentName:"h2"},"prayerRequestController.ts")),(0,r.kt)("p",null,"Opening up ",(0,r.kt)("inlineCode",{parentName:"p"},"prayerRequestController.ts")," leads me to the conclusion that I have ",(0,r.kt)("strong",{parentName:"p"},"no interesting way left")," of telling you that we once more need to supply types for our parameters. Let's take it as read that the same will happen on all remaining files as well eh? Hopefully by now it's fairly clear that this option is useful, even if only for a migration. I say this because using it forces you to think about what typings should be applied to your code."),(0,r.kt)("p",null,"We'll define ",(0,r.kt)("inlineCode",{parentName:"p"},"$scope")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"ng.IScope"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"prayerRequestService")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"IPrayerRequestService")," (which we created just now) and ",(0,r.kt)("inlineCode",{parentName:"p"},"prayerRequest")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"{ email: string; prayFor: string }"),". Which leaves me with this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\nangular.module('poorClaresApp.controllers').controller(\n  'PrayerRequestController',\n\n  [\n    '$scope',\n    'prayerRequestService',\n    function ($scope: ng.IScope, prayerRequestService: IPrayerRequestService) {\n      var vm = this;\n\n      vm.send = function (prayerRequest: { email: string; prayFor: string }) {\n        vm.message = {\n          success: true,\n          text: 'Sending...',\n        };\n\n        prayerRequestService\n          .sendPrayerRequest(prayerRequest.email, prayerRequest.prayFor)\n          .then(function (response) {\n            vm.message = {\n              success: response.success,\n              text: response.text,\n            };\n          })\n          .then(null, function (error) {\n            // IE 8 friendly alias for catch\n            vm.message = {\n              success: false,\n              text: 'Sorry your email was not sent',\n            };\n          });\n      };\n    },\n  ]\n);\n")),(0,r.kt)("p",null,"I could move on but let's go for bonus points (and now you'll see why the unit test suite is so handy). To quote the Angular documentation:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In Angular, a Controller is a JavaScript constructor function that is used to augment the Angular Scope.")),(0,r.kt)("p",null,"So let's see if we can swap over our vanilla contructor function for a TypeScript class. This will (in my view) better express the intention of the code. To do this I am essentially following the example laid down by my Definitely Typed colleague ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/basarat"},"Basarat"),". I highly recommend his ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=WdtVn_8K17E"},"screencast on the topic"),". Also kudos to ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/andrewdavey"},"Andrew Davey")," whose ",(0,r.kt)("a",{parentName:"p",href:"http://aboutcode.net/2013/10/20/typescript-angularjs-controller-classes.html"},"post on the topic")," also fed into this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\nmodule poorClaresApp.controllers {\n  class PrayerRequestController {\n    static $inject = ['$scope', 'prayerRequestService'];\n    constructor(\n      private $scope: ng.IScope,\n      private prayerRequestService: IPrayerRequestService\n    ) {}\n\n    message: { success: boolean; text: string };\n\n    send(prayerRequest: { email: string; prayFor: string }) {\n      this.message = {\n        success: true,\n        text: 'Sending...',\n      };\n\n      this.prayerRequestService\n        .sendPrayerRequest(prayerRequest.email, prayerRequest.prayFor)\n        .then((response) => {\n          this.message = {\n            success: response.success,\n            text: response.text,\n          };\n        })\n        .then(null, (error) => {\n          // IE 8 friendly alias for catch\n          this.message = {\n            success: false,\n            text: 'Sorry your email was not sent',\n          };\n        });\n    }\n  }\n\n  angular\n    .module('poorClaresApp.controllers')\n    .controller('PrayerRequestController', PrayerRequestController);\n}\n")),(0,r.kt)("p",null,"My only reservation with this approach is that we have to declare the TypeScript class outside the ",(0,r.kt)("inlineCode",{parentName:"p"},"angular.module...")," statement. To avoid cluttering up global scope I've placed our class in a module called ",(0,r.kt)("inlineCode",{parentName:"p"},"poorClaresApp.controllers")," which maps nicely to our Angular module name. It would be nice if I could place the class definition in an ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Immediately-invoked_function_expression"},"IIFE")," to completely keep this completely isolated but TypeScript doesn't allow for that syntax (for reasons I'm unclear about - the output would be legal JavaScript)."),(0,r.kt)("p",null,"For a small class this seems to add a little noise but as classes grow in complexity I think this approach will quickly start to pay dividends. There are a few things worth noting about the above approach:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The required injectable parameters have moved into the class definition in the form of the ",(0,r.kt)("inlineCode",{parentName:"li"},"static $inject")," statement. I personally like that this no longer sits outside the code it relates to."),(0,r.kt)("li",{parentName:"ul"},'Because we\'re using TypeScript arrow functions (which preserve the outer "this" context) we are now free to dispose of the ',(0,r.kt)("inlineCode",{parentName:"li"},"var vm = this;")," mechanism we're were previously using for the same purpose. Much more intuitive code to my mind."),(0,r.kt)("li",{parentName:"ul"},"We are not actually using ",(0,r.kt)("inlineCode",{parentName:"li"},"$scope")," at all in this controller - maybe it should be removed entirely in the long run.")),(0,r.kt)("h2",{id:"typescriptify-navcontrollerts"},"TypeScriptify ",(0,r.kt)("inlineCode",{parentName:"h2"},"navController.ts")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"navController")," can be simply converted like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\ninterface INavControllerScope extends ng.IScope {\n  isCollapsed: boolean;\n  siteSection: string;\n}\n\nangular.module('poorClaresApp.controllers').controller(\n  'NavController',\n\n  [\n    '$scope',\n    'siteSectionService',\n    function (\n      $scope: INavControllerScope,\n      siteSectionService: ISiteSectionService\n    ) {\n      $scope.isCollapsed = true;\n      $scope.siteSection = siteSectionService.getSiteSection();\n\n      $scope.$watch(\n        siteSectionService.getSiteSection,\n        function (newValue, oldValue) {\n          $scope.siteSection = newValue;\n        }\n      );\n    },\n  ]\n);\n")),(0,r.kt)("p",null,"I'd draw your attention to the creation of a the ",(0,r.kt)("inlineCode",{parentName:"p"},"INavControllerScope")," interface that extends the default Angular $scope of ",(0,r.kt)("inlineCode",{parentName:"p"},"ng.IScope")," with 2 extra properties."),(0,r.kt)("p",null,"Let's also switch this over to the class based approach (there is less of a reason to on this occasion just looking at the size of the codebase but I'm all about consistency of approach):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\nmodule poorClaresApp.controllers {\n  interface INavControllerScope extends ng.IScope {\n    isCollapsed: boolean;\n    siteSection: string;\n  }\n\n  class NavController {\n    static $inject = ['$scope', 'siteSectionService'];\n    constructor(\n      private $scope: INavControllerScope,\n      private siteSectionService: ISiteSectionService\n    ) {\n      $scope.isCollapsed = true;\n      $scope.siteSection = siteSectionService.getSiteSection();\n\n      $scope.$watch(\n        siteSectionService.getSiteSection,\n        function (newValue, oldValue) {\n          $scope.siteSection = newValue;\n        }\n      );\n    }\n  }\n\n  angular\n    .module('poorClaresApp.controllers')\n    .controller('NavController', NavController);\n}\n")),(0,r.kt)("h2",{id:"typescriptify-maincontrollerts"},"TypeScriptify ",(0,r.kt)("inlineCode",{parentName:"h2"},"mainController.ts")),(0,r.kt)("p",null,"Finally, ",(0,r.kt)("inlineCode",{parentName:"p"},"mainController")," can be converted as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\nangular.module('poorClaresApp.controllers').controller(\n  'MainController',\n\n  [\n    '$location',\n    'siteSectionService',\n    function (\n      $location: ng.ILocationService,\n      siteSectionService: ISiteSectionService\n    ) {\n      siteSectionService.determineSiteSection($location.path());\n    },\n  ]\n);\n")),(0,r.kt)("p",null,"Again it's just a case of assigning the undeclared types. For completeness lets also switch this over to the class based approach:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"'use strict';\n\nmodule poorClaresApp.controllers {\n  class MainController {\n    static $inject = ['$location', 'siteSectionService'];\n    constructor(\n      private $location: ng.ILocationService,\n      private siteSectionService: ISiteSectionService\n    ) {\n      siteSectionService.determineSiteSection($location.path());\n    }\n  }\n\n  angular\n    .module('poorClaresApp.controllers')\n    .controller('MainController', MainController);\n}\n")))}d.isMDXComponent=!0}}]);