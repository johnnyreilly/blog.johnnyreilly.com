"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[66190],{36795:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(85893),o=t(11151);const s={slug:"azure-functions-dotnet-5-query-params-di-bicep",title:"Azure Functions and .NET 5: Query params, Dependency Injection, Bicep & Build",authors:"johnnyreilly",tags:["azure functions","bicep","asp.net"],image:"./title-image.png",description:"The upgrade of Azure Functions from .NET Core 3.1 to .NET 5 is significant. This post shows part of the upgrade: Query params, Dependency Injection, Bicep & Build",hide_table_of_contents:!1},r=void 0,a={permalink:"/azure-functions-dotnet-5-query-params-di-bicep",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2021-06-11-azure-functions-dotnet-5-query-params-di-bicep/index.md",source:"@site/blog/2021-06-11-azure-functions-dotnet-5-query-params-di-bicep/index.md",title:"Azure Functions and .NET 5: Query params, Dependency Injection, Bicep & Build",description:"The upgrade of Azure Functions from .NET Core 3.1 to .NET 5 is significant. This post shows part of the upgrade: Query params, Dependency Injection, Bicep & Build",date:"2021-06-11T00:00:00.000Z",formattedDate:"June 11, 2021",tags:[{label:"azure functions",permalink:"/tags/azure-functions"},{label:"bicep",permalink:"/tags/bicep"},{label:"asp.net",permalink:"/tags/asp-net"}],readingTime:3.385,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"azure-functions-dotnet-5-query-params-di-bicep",title:"Azure Functions and .NET 5: Query params, Dependency Injection, Bicep & Build",authors:"johnnyreilly",tags:["azure functions","bicep","asp.net"],image:"./title-image.png",description:"The upgrade of Azure Functions from .NET Core 3.1 to .NET 5 is significant. This post shows part of the upgrade: Query params, Dependency Injection, Bicep & Build",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"React 18 and TypeScript",permalink:"/react-18-and-typescript"},nextItem:{title:"Azurite and Table Storage in a dev container",permalink:"/azurite-and-table-storage-dev-container"}},c={image:t(82315).Z,authorsImageUrls:[void 0]},l=[{value:"Query params",id:"query-params",level:2},{value:"Dependency Injection, local development and Azure Application Settings",id:"dependency-injection-local-development-and-azure-application-settings",level:2},{value:"Bicep",id:"bicep",level:2},{value:"Building .NET 5 functions",id:"building-net-5-functions",level:2}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The upgrade of Azure Functions from .NET Core 3.1 to .NET 5 is significant. There's an excellent ",(0,i.jsx)(n.a,{href:"https://codetraveler.io/2021/05/28/creating-azure-functions-using-net-5/",children:"guide"})," for the general steps required to perform the upgrade. However there's a number of (unrelated) items which are not covered by that post:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Query params"}),"\n",(0,i.jsx)(n.li,{children:"Dependency Injection"}),"\n",(0,i.jsx)(n.li,{children:"Bicep"}),"\n",(0,i.jsx)(n.li,{children:"Build"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This post will show how to tackle these."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"title image showing name of post and the Azure Functions logo",src:t(28061).Z+"",width:"1347",height:"431",loading:"eager",fetchpriority:"high"})}),"\n",(0,i.jsx)(n.h2,{id:"query-params",children:"Query params"}),"\n",(0,i.jsxs)(n.p,{children:["As part of the move to .NET 5 functions, we say goodbye to ",(0,i.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequest?view=aspnetcore-5.0",children:(0,i.jsx)(n.code,{children:"HttpRequest"})})," and hello to ",(0,i.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.functions.worker.http.httprequestdata?view=azure-dotnet",children:(0,i.jsx)(n.code,{children:"HttpRequestData"})}),". Now ",(0,i.jsx)(n.code,{children:"HttpRequest"})," had a useful ",(0,i.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequest.query?view=aspnetcore-5.0#Microsoft_AspNetCore_Http_HttpRequest_Query",children:(0,i.jsx)(n.code,{children:"Query"})})," property which allowed for the simple extraction of query parameters like so."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'var from = req.Query["from"]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"HttpRequestData"})," has no such property. However, it's straightforward to make our own. It's simply a matter of using ",(0,i.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.web.httputility.parsequerystring?view=net-5.0",children:(0,i.jsx)(n.code,{children:"System.Web.HttpUtility.ParseQueryString"})})," on ",(0,i.jsx)(n.code,{children:"req.Url.Query"})," and using that:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'var query = System.Web.HttpUtility.ParseQueryString(req.Url.Query);\nvar from = query["from"]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"dependency-injection-local-development-and-azure-application-settings",children:"Dependency Injection, local development and Azure Application Settings"}),"\n",(0,i.jsxs)(n.p,{children:["Dependency Injection is a much more familiar shape in .NET 5 if you're familiar with .NET Core web apps. Once again we have a ",(0,i.jsx)(n.code,{children:"Program.cs"})," file. To get the configuration built in such a way to support both local development and when deployed to Azure, there's a few things to do. When deployed to Azure you'll likely want to read from Azure Application Settings:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"screenshot of Azure Application Settings",src:t(27809).Z+"",width:"3014",height:"1364",loading:"lazy"})}),"\n",(0,i.jsxs)(n.p,{children:["To tackle both of these, you'll want to use ",(0,i.jsx)(n.code,{children:"AddJsonFile"})," and ",(0,i.jsx)(n.code,{children:"AddEnvironmentVariables"})," in ",(0,i.jsx)(n.code,{children:"ConfigureAppConfiguration"}),". A final ",(0,i.jsx)(n.code,{children:"Program.cs"})," might look something like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static Task Main(string[] args)\n        {\n            var host = new HostBuilder()\n                .ConfigureAppConfiguration(configurationBuilder =>\n                    configurationBuilder\n                        .AddCommandLine(args)\n                        // below is for local development\n                        .AddJsonFile("local.settings.json", optional: true, reloadOnChange: true)\n                        // below is what you need to read Application Settings in Azure\n                        .AddEnvironmentVariables()\n                )\n                .ConfigureFunctionsWorkerDefaults()\n                .ConfigureServices(services =>\n                {\n                    services.AddLogging();\n                    services.AddHttpClient();\n                })\n                .Build();\n\n            return host.RunAsync();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"With this approach in place, when the application runs, it should construct a configuration driven by all the providers required to run our application."}),"\n",(0,i.jsx)(n.h2,{id:"bicep",children:"Bicep"}),"\n",(0,i.jsxs)(n.p,{children:["When it comes to deploying to Azure via ",(0,i.jsx)(n.a,{href:"https://github.com/Azure/bicep",children:"Bicep"}),", there's some small tweaks required:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"appSettings.FUNCTIONS_WORKER_RUNTIME"})," becomes ",(0,i.jsx)(n.code,{children:"dotnet-isolated"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"linuxFxVersion"})," becomes ",(0,i.jsx)(n.code,{children:"DOTNET-ISOLATED|5.0"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Applied to the resource itself the diff looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-diff",children:"resource functionAppName_resource 'Microsoft.Web/sites@2018-11-01' = {\n  name: functionAppName\n  location: location\n  tags: tags_var\n  kind: 'functionapp,linux'\n  identity: {\n    type: 'SystemAssigned'\n  }\n  properties: {\n    serverFarmId: appServicePlanName_resource.id\n    siteConfig: {\n      http20Enabled: true\n      remoteDebuggingEnabled: false\n      minTlsVersion: '1.2'\n      appSettings: [\n        {\n          name: 'FUNCTIONS_EXTENSION_VERSION'\n          value: '~3'\n        }\n        {\n          name: 'FUNCTIONS_WORKER_RUNTIME'\n-          value: 'dotnet'\n+          value: 'dotnet-isolated'\n        }\n        {\n          name: 'AzureWebJobsStorage'\n          value: 'DefaultEndpointsProtocol=https;AccountName=${storageAccountName};AccountKey=${listKeys(resourceId('Microsoft.Storage/storageAccounts', storageAccountName), '2019-06-01').keys[0].value};EndpointSuffix=${environment().suffixes.storage}'\n        }\n      ]\n      connectionStrings: [\n        {\n          name: 'TableStorageConnectionString'\n          connectionString: 'DefaultEndpointsProtocol=https;AccountName=${storageAccountName};AccountKey=${listKeys(resourceId('Microsoft.Storage/storageAccounts', storageAccountName), '2019-06-01').keys[0].value};EndpointSuffix=${environment().suffixes.storage}'\n        }\n      ]\n-      linuxFxVersion: 'DOTNETCORE|LTS'\n+      linuxFxVersion: 'DOTNET-ISOLATED|5.0'\n      ftpsState: 'Disabled'\n      managedServiceIdentityId: 1\n    }\n    clientAffinityEnabled: false\n    httpsOnly: true\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"building-net-5-functions",children:"Building .NET 5 functions"}),"\n",(0,i.jsxs)(n.p,{children:["Before signing off, there's one more thing to slip in. When attempting to build .NET 5 Azure Functions with the .NET SDK ",(0,i.jsx)(n.em,{children:"alone"}),", you'll encounter this error:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"The framework 'Microsoft.NETCore.App', version '3.1.0' was not found.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Docs on this seem to be pretty short. The closest I came to docs was ",(0,i.jsx)(n.a,{href:"https://stackoverflow.com/questions/66938752/net-5-the-framework-microsoft-netcore-app-version-3-1-0-was-not-found/66938753#66938753",children:"this comment on Stack Overflow"}),":"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"To build .NET 5 functions, the .NET Core 3 SDK is required. So this must be installed alongside the 5.0.x sdk."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"So with Azure Pipelines you might have have something that looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yml",children:"stages:\n  - stage: build\n    displayName: build\n    pool:\n      vmImage: 'ubuntu-latest'\n    jobs:\n      - job: BuildAndTest\n        displayName: 'Build and Test'\n        steps:\n          # we need .NET Core SDK 3.1 too!\n          - task: UseDotNet@2\n            displayName: 'Install .NET Core SDK 3.1'\n            inputs:\n              packageType: 'sdk'\n              version: 3.1.x\n\n          - task: UseDotNet@2\n            displayName: 'Install .NET SDK 5.0'\n            inputs:\n              packageType: 'sdk'\n              version: 5.0.x\n\n          - task: DotNetCoreCLI@2\n            displayName: 'function app test'\n            inputs:\n              command: test\n\n          - task: DotNetCoreCLI@2\n            displayName: 'function app build'\n            inputs:\n              command: build\n              arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)/MyApp'\n\n          - task: DotNetCoreCLI@2\n            displayName: 'function app publish'\n            inputs:\n              command: publish\n              arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)/MyApp /p:SourceRevisionId=$(Build.SourceVersion)'\n              publishWebProjects: false\n              modifyOutputPath: false\n              zipAfterPublish: true\n\n          - publish: $(Build.ArtifactStagingDirectory)/MyApp\n            artifact: functionapp\n"})}),"\n",(0,i.jsx)(n.p,{children:"Have fun building .NET 5 functions!"})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},82315:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/title-image-8c454e88184cf532ac81230927060f90.png"},27809:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/application-settings-03a89ec8679efd18aa79e3793c61647e.png"},28061:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/title-image-8c454e88184cf532ac81230927060f90.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var i=t(67294);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);