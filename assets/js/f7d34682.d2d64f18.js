"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["16599"],{92589:function(t,e,n){n.r(e),n.d(e,{assets:function(){return l},contentTitle:function(){return r},default:function(){return h},frontMatter:function(){return o},metadata:function(){return a},toc:function(){return u}});var a=n(38538),i=n(85893),s=n(50065);let o={slug:"instant-stubs-with-jsonnet",title:"Instant Stubs with JSON.Net (just add hot water)",authors:"johnnyreilly",tags:["automated testing","asp.net"],hide_table_of_contents:!1,description:"A utility class can create stubs to test an untested system with complex I/O. Serializing complex data to JSON files eases the process."},r=void 0,l={authorsImageUrls:[void 0]},u=[{value:"Instant Stubs",id:"instant-stubs",level:2},{value:"Using your JSON",id:"using-your-json",level:2}];function d(t){let e={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"I'd like you to close your eyes and imagine a scenario. You're handed a prototype system. You're told it works. It has no documentation. It has 0 unit tests. The hope is that you can take it on, refactor it, make it better and (crucially) not break it. Oh, and you don't really understand what the code does or why it does it either; information on that front is, alas, sorely lacking."}),"\n",(0,i.jsx)(e.p,{children:"This has happened to me; it's alas not that unusual. The common advice handed out in this situation is: \"add unit tests before you change it\". That's good advice. We need to take the implementation that embodies the correctness of the system and create unit tests that set that implementation in stone. However, what say the system that you're hoping to add tests to takes a number of large and complex inputs from some external source and produces a similarly large and complex output?"}),"\n",(0,i.jsx)(e.p,{children:"You could start with integration tests. They're good but slow and crucially they depend upon the external inputs being available and unchanged (which is perhaps unlikely). What you could do (what I have done) is debug a working working system. At each point that an input is obtained I have painstakingly transcribed the data which allows me to subsequently hand code stub data. There comes a point when this is plainly untenable; it's just too much data to transcribe. At this point the temptation is to think \"it's okay; I can live without the tests. I'll just be super careful with my refactoring... It'll be fine It'll be fine It'll be fine It'll be fine\"."}),"\n",(0,i.jsx)(e.p,{children:"Actually, it probably won't be fine. And even if it is (miracles do happen) you're going to be fairly stressed as you wonder if you've been careful enough. What if there was another way? A way that wasn't quite so hard but that allowed you to add tests without requiring 3 months hand coding...."}),"\n",(0,i.jsx)(e.h2,{id:"instant-stubs",children:"Instant Stubs"}),"\n",(0,i.jsxs)(e.p,{children:["What I've come up with is a super simple utility class for creating stubs / fakes. (I'm aware the naming of such things ",(0,i.jsx)(e.a,{href:"http://martinfowler.com/articles/mocksArentStubs.html",children:"can be a little contentious"}),".)"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cs",children:'using Newtonsoft.Json;\nusing System;\nusing System.IO;\n\nnamespace MakeFakeData.UnitTests\n{\n  public static class Stubs\n  {\n    private static JsonSerializer _serializer = new JsonSerializer { NullValueHandling = NullValueHandling.Ignore };\n\n    public static void Make<T>(string stubPath, T data)\n    {\n      try\n      {\n        if (string.IsNullOrEmpty(stubPath))\n          throw new ArgumentNullException(nameof(stubPath));\n        if (data == null)\n          throw new ArgumentNullException(nameof(data));\n\n        using (var sw = new StreamWriter(stubPath))\n        using (var writer = new JsonTextWriter(sw) {\n            Formatting = Formatting.Indented,\n            IndentChar = \' \',\n            Indentation = 2})\n        {\n          _serializer.Serialize(writer, data);\n        }\n      }\n      catch (Exception exc)\n      {\n        throw new Exception($"Failed to make {stubPath}", exc);\n      }\n    }\n\n    public static T Load<T>(string stubPath)\n    {\n      try\n      {\n        if (string.IsNullOrEmpty(stubPath))\n          throw new ArgumentNullException(nameof(stubPath));\n\n        using (var file = File.OpenText(stubPath))\n        using (var reader = new JsonTextReader(file))\n        {\n          return _serializer.Deserialize<T>(reader);\n        }\n      }\n      catch (Exception exc)\n      {\n        throw new Exception($"Failed to load {stubPath}", exc);\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["As you can see this class uses ",(0,i.jsx)(e.a,{href:"http://www.newtonsoft.com/json",children:"JSON.Net"})," and exposes 2 methods:"]}),"\n",(0,i.jsxs)("dl",{children:[(0,i.jsx)("dt",{children:"Make"}),(0,i.jsx)("dd",{children:"Takes a given piece of data and uses JSON.Net to serialise it as JSON to a file. (nb I choose to format the JSON for readability and exclude null values; both totally optional)"}),(0,i.jsx)("dt",{children:"Load"}),(0,i.jsx)("dd",{children:"Takes the given path and loads the associated JSON file and deserialises it back into an object."})]}),"\n",(0,i.jsx)(e.p,{children:"The idea is this: we take our working implementation and, wherever it extracts data from an external source, we insert a temporary statement like this:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cs",children:'var data = _dataService.GetComplexData();\n\n    // Just inserted so we can generate the stub data...\n    Stubs.Make($"{System.AppDomain.CurrentDomain.BaseDirectory}\\\\data.json", data);\n'})}),"\n",(0,i.jsxs)(e.p,{children:["The next time you run the implementation you'll find the app generates a ",(0,i.jsx)(e.code,{children:"data.json"})," file containing the complex data serialized to JSON. Strip out your ",(0,i.jsx)(e.code,{children:"Stubs.Make"})," statements from the implementation and we're ready for the next stage."]}),"\n",(0,i.jsx)(e.h2,{id:"using-your-json",children:"Using your JSON"}),"\n",(0,i.jsxs)(e.p,{children:["What you need to do now is to take the new and shiny ",(0,i.jsx)(e.code,{children:"data.json"})," file and move it to your unit test project. It needs to be included within the unit test project. Also, for each JSON file you have, the ",(0,i.jsx)(e.code,{children:"Build Action"})," in VS needs to be set to ",(0,i.jsx)(e.code,{children:"Content"})," and the ",(0,i.jsx)(e.code,{children:"Copy to Output Directory"})," to ",(0,i.jsx)(e.code,{children:"Copy if newer"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"Then within your unit tests you can write code like this:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"var dummyData = Stubs.Load<ComplexDataType>('Stubs/data.json');\n"})}),"\n",(0,i.jsx)(e.p,{children:"Which pulls in your data from the JSON file and deserialises it into the original types. With this in hand you can plug together a unit test based on an existing implementation which depends on external data much faster than the hand-cranked method of old."}),"\n",(0,i.jsx)(e.p,{children:"Finally, before the wildebeest of TDD descend upon me howling and wailing, let me say again; I anticipate this being useful when you're trying to add tests to something that already exists but is untested. Clearly it would be better not to be in this situaion in the first place."})]})}function h(t={}){let{wrapper:e}={...(0,s.a)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(d,{...t})}):d(t)}},50065:function(t,e,n){n.d(e,{Z:function(){return r},a:function(){return o}});var a=n(67294);let i={},s=a.createContext(i);function o(t){let e=a.useContext(s);return a.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function r(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:o(t.components),a.createElement(s.Provider,{value:e},t.children)}},38538:function(t){t.exports=JSON.parse('{"permalink":"/instant-stubs-with-jsonnet","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2016-04-25-instant-stubs-with-jsonnet/index.md","source":"@site/blog/2016-04-25-instant-stubs-with-jsonnet/index.md","title":"Instant Stubs with JSON.Net (just add hot water)","description":"A utility class can create stubs to test an untested system with complex I/O. Serializing complex data to JSON files eases the process.","date":"2016-04-25T00:00:00.000Z","tags":[{"inline":false,"label":"Automated Testing","permalink":"/tags/automated-testing","description":"How to perform the automation of tests."},{"inline":false,"label":"ASP.NET","permalink":"/tags/asp-net","description":"The web framework built by Microsoft."}],"readingTime":4.05,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"instant-stubs-with-jsonnet","title":"Instant Stubs with JSON.Net (just add hot water)","authors":"johnnyreilly","tags":["automated testing","asp.net"],"hide_table_of_contents":false,"description":"A utility class can create stubs to test an untested system with complex I/O. Serializing complex data to JSON files eases the process."},"unlisted":false,"prevItem":{"title":"Inlining Angular Templates with WebPack and TypeScript","permalink":"/inlining-angular-templates-with-webpack"},"nextItem":{"title":"Concatting IEnumerables in C#","permalink":"/concatting-ienumerables-in-csharp"}}')}}]);