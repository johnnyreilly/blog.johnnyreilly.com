"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[72687],{73765:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>h});var t=o(85893),a=o(11151);const r={slug:"webpack-resolveloader-alias-with-query",title:"webpack: resolveLoader / alias with query / options",authors:"johnnyreilly",tags:["webpack"],hide_table_of_contents:!1,description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options."},s=void 0,i={permalink:"/webpack-resolveloader-alias-with-query",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2017-01-06-webpack-resolveloader-alias-with-query/index.md",source:"@site/blog/2017-01-06-webpack-resolveloader-alias-with-query/index.md",title:"webpack: resolveLoader / alias with query / options",description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options.",date:"2017-01-06T00:00:00.000Z",formattedDate:"January 6, 2017",tags:[{label:"webpack",permalink:"/tags/webpack"}],readingTime:1.38,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"webpack-resolveloader-alias-with-query",title:"webpack: resolveLoader / alias with query / options",authors:"johnnyreilly",tags:["webpack"],hide_table_of_contents:!1,description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options."},unlisted:!1,prevItem:{title:"Hands-free HTTPS",permalink:"/hands-free-https"},nextItem:{title:"webpack: configuring a loader with query / options",permalink:"/webpack-configuring-loader-with-query"}},l={authorsImageUrls:[void 0]},h=[];function d(e){const n={a:"a",code:"code",em:"em",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'Sometimes you write a post for the ages. Sometimes you write one you hope is out of date before you hit "publish". This is one of those.'}),"\n",(0,t.jsxs)(n.p,{children:["There's a ",(0,t.jsx)(n.a,{href:"https://github.com/webpack/enhanced-resolve/issues/41",children:"bug"})," in webpack's enhanced-resolve. It means that you cannot configure an aliased loader using the ",(0,t.jsx)(n.code,{children:"query"})," (or ",(0,t.jsx)(n.code,{children:"options"})," in the webpack 2 nomenclature). Let me illustrate; consider the following code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    loaders: [\n      {\n        test: /\\.ts$/,\n        loader: 'ts-loader',\n        query: {\n            entryFileIsJs: true\n        }\n      }\n    ]\n  }\n}\n\nmodule.exports.resolveLoader = { alias: { 'ts-loader': require('path').join(__dirname, \"../../index.js\")\n"})}),"\n",(0,t.jsxs)(n.p,{children:["At the time of writing, if you alias a loader as above, then the ",(0,t.jsx)(n.code,{children:"query"})," / ",(0,t.jsx)(n.code,{children:"options"})," will *",(0,t.jsx)(n.em,{children:"not"}),"* be passed along. This is bad, particularly given the requirement in webpack 2 that configuration is no longer possible through extending the ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/guides/migrating/#loader-configuration-is-through-options",children:(0,t.jsx)(n.code,{children:"webpack.config.js"})}),". So what to do? Well, when this was a problem previously the marvellous ",(0,t.jsx)(n.a,{href:"https://www.twitter.com/jbrantly",children:"James Brantly"})," had a ",(0,t.jsx)(n.a,{href:"https://github.com/webpack/webpack/issues/1289#issuecomment-125767499",children:"workaround"}),". I've taken that and run with it:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"var config = {\n  // ...\n  module: {\n    loaders: [\n      {\n        test: /\\.ts$/,\n        loader: 'ts-loader',\n        query: {\n          entryFileIsJs: true,\n        },\n      },\n    ],\n  },\n};\n\nmodule.exports = config;\n\nvar loaderAliasPath = require('path').join(__dirname, '../../../index.js');\nvar rules = config.module.loaders || config.module.rules;\nrules.forEach(function (rule) {\n  var options = rule.query || rule.options;\n  rule.loader = rule.loader.replace(\n    'ts-loader',\n    loaderAliasPath + (options ? '?' + JSON.stringify(options) : ''),\n  );\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This approach stringifies the ",(0,t.jsx)(n.code,{children:"query"})," / ",(0,t.jsx)(n.code,{children:"options"})," and suffixes it to the aliased path. This works as long as the options you're passing are JSON-able (yes it's a word)."]}),"\n",(0,t.jsx)(n.p,{children:"As I said earlier; hopefully by the time you read this the workaround will no longer be necessary again. But just in case...."})]})}function c(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,o)=>{o.d(n,{Z:()=>i,a:()=>s});var t=o(67294);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);