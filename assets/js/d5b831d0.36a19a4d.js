"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[26796],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var r=n(96540);const s={},o=r.createContext(s);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:t},e.children)}},51734:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var r=n(62106),s=n(74848),o=n(28453);const a={slug:"the-ternary-operator-meets-destructuring",title:"The Ternary Operator <3 Destructuring",authors:"johnnyreilly",tags:["typescript","javascript"],hide_table_of_contents:!1,description:"ES2015 destructuring allows setting multiple variables using the ternary operator. Change the return type of each branch to an object for this to work."},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Crowdfund You A Tuple",id:"crowdfund-you-a-tuple",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["I'm addicted to the ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator",children:"ternary operator"}),". For reasons I can't explain, I cannot get enough of:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const thisOrThat = someCondition ? 'this' : 'or that';\n"})}),"\n",(0,s.jsx)(t.p,{children:"The occasion regularly arises where I need to turn my lovely terse code into an if statement in order to set 2 variables instead of 1. I've been heartbroken; I hate doing:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"let legWear: string, coat: boolean;\nif (weather === 'good') {\n  legWear = 'shorts';\n  coat = false;\n} else {\n  legWear = 'jeans';\n  coat = true;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Just going from setting one variable to setting two has been really traumatic:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["I've had do stop using ",(0,s.jsx)(t.code,{children:"const"})," and moved to ",(0,s.jsx)(t.code,{children:"let"}),'. This has made my code less "truthful" in the sense that I never intend to reassign these variables again; they are intended to be immutable.']}),"\n",(0,s.jsxs)(t.li,{children:["I've gone from 1 line of code to ",(0,s.jsx)(t.em,{children:"9 lines of code"}),". That's 9x the code for increasing the number of variables in play by 1. That's... heavy."]}),"\n",(0,s.jsx)(t.li,{children:"This third point only applies if you're using TypeScript (and I am): I have to specify the types of my variables up front if I want type safety."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["ES2015 gives us another option. We can move back to the ternary operator if we change the return type of each branch to be an object sharing the same signature. Then, using destructuring, we can pull out those object properties into ",(0,s.jsx)(t.code,{children:"const"}),"s:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const { legWear, coat } =\n  weather === 'good'\n    ? { legWear: 'shorts', coat: false }\n    : { legWear: 'jeans', coat: true };\n"})}),"\n",(0,s.jsxs)(t.p,{children:["With this approach we're keeping usage of ",(0,s.jsx)(t.code,{children:"const"})," instead of ",(0,s.jsx)(t.code,{children:"let"})," and we're only marginally increasing the amount of code we're writing. If you're using TypeScript you're back to being able to rely on the compiler correctly inferring your types; you don't need to specify. Awesome."]}),"\n",(0,s.jsx)(t.h2,{id:"crowdfund-you-a-tuple",children:"Crowdfund You A Tuple"}),"\n",(0,s.jsx)(t.p,{children:"I thought I was done and then I saw this:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://twitter.com/johnny_reilly",children:"@johnny_reilly"}),' even neater with tuples: const [str, num] = test ? ["yes", 100] : ["no", 50];']}),"\n",(0,s.jsxs)(t.p,{children:["\u2014 Illustrated Pamphlet (@Rickenhacker) ",(0,s.jsx)(t.a,{href:"https://twitter.com/Rickenhacker/status/766913766323781632",children:"August 20, 2016"})]}),"\n"]}),"\n",(0,s.jsx)("script",{async:"",src:"//platform.twitter.com/widgets.js",charSet:"utf-8"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://twitter.com/Rickenhacker",children:"Daniel"})," helpfully points out that there's an even terser syntax available to us:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const [legWear, coat] =\n  weather === 'good' ? ['shorts', false] : ['jeans', true];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The above is ES2015 array destructuring. We get exactly the same effect but it's a little terser as we don't have to repeat the prop names as we do when using object destructuring. From a TypeScript perspective the assignment side of the above is a ",(0,s.jsx)(t.a,{href:"https://github.com/Microsoft/TypeScript/pull/428",children:"Tuple"})," which allows our type inference to flow through in the manner we'd hope."]}),"\n",(0,s.jsx)(t.p,{children:"Lovely. Thanks!"})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},62106:e=>{e.exports=JSON.parse('{"permalink":"/the-ternary-operator-meets-destructuring","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2016-08-19-the-ternary-operator-meets-destructuring/index.md","source":"@site/blog/2016-08-19-the-ternary-operator-meets-destructuring/index.md","title":"The Ternary Operator <3 Destructuring","description":"ES2015 destructuring allows setting multiple variables using the ternary operator. Change the return type of each branch to an object for this to work.","date":"2016-08-19T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."},{"inline":false,"label":"JavaScript","permalink":"/tags/javascript","description":"The JavaScript programming language."}],"readingTime":2.17,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"the-ternary-operator-meets-destructuring","title":"The Ternary Operator <3 Destructuring","authors":"johnnyreilly","tags":["typescript","javascript"],"hide_table_of_contents":false,"description":"ES2015 destructuring allows setting multiple variables using the ternary operator. Change the return type of each branch to an object for this to work."},"unlisted":false,"prevItem":{"title":"Integration Tests with SQL Server Database Snapshots","permalink":"/integration-tests-with-sql-server"},"nextItem":{"title":"Understanding webpack\'s DefinePlugin (and using with TypeScript)","permalink":"/using-webpacks-defineplugin-with-typescript"}}')}}]);