"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[77455],{66057:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(85893),i=n(11151);const o={slug:"typescript-unit-tests-with-debug-support",title:"TypeScript Unit Tests with Debug Support",authors:"johnnyreilly",tags:["typescript","automated testing"],image:"./title-image.png",description:"Unit tests are an important part of the development process. This post will outline how to write unit tests using TypeScript and how to debug them as well.",hide_table_of_contents:!1},r=void 0,a={permalink:"/typescript-unit-tests-with-debug-support",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2022-10-01-typescript-unit-tests-with-debug-support/index.md",source:"@site/blog/2022-10-01-typescript-unit-tests-with-debug-support/index.md",title:"TypeScript Unit Tests with Debug Support",description:"Unit tests are an important part of the development process. This post will outline how to write unit tests using TypeScript and how to debug them as well.",date:"2022-10-01T00:00:00.000Z",formattedDate:"October 1, 2022",tags:[{label:"typescript",permalink:"/tags/typescript"},{label:"automated testing",permalink:"/tags/automated-testing"}],readingTime:6.34,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"typescript-unit-tests-with-debug-support",title:"TypeScript Unit Tests with Debug Support",authors:"johnnyreilly",tags:["typescript","automated testing"],image:"./title-image.png",description:"Unit tests are an important part of the development process. This post will outline how to write unit tests using TypeScript and how to debug them as well.",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Bicep: Static Web Apps and Linked Backends",permalink:"/bicep-static-web-apps-linked-backends"},nextItem:{title:"Faster Docusaurus builds with swc-loader",permalink:"/faster-docusaurus-build-swc-loader"}},l={image:n(21897).Z,authorsImageUrls:[void 0]},c=[{value:"Unit Tests",id:"unit-tests",level:2},{value:"Setting up our TypeScript project",id:"setting-up-our-typescript-project",level:2},{value:"Setting up the Jest project",id:"setting-up-the-jest-project",level:2},{value:"Set up debugging support",id:"set-up-debugging-support",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.a)(),...e.components},{Head:o}=t;return o||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o,{children:(0,s.jsx)("link",{rel:"canonical",href:"https://meticulous.ai/blog/typescript-unit-tests-with-debugging/"})}),"\n",(0,s.jsx)(t.p,{children:"Unit tests are an important part of the development process. They are used to verify that the code is working as intended. This post will outline how to write unit tests using TypeScript and how to debug them as well."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"title image reading &quot;TypeScript Unit Tests with Debug Support&quot; with TypeScript and Jest logos",src:n(41427).Z+"",width:"1600",height:"900",loading:"eager",fetchpriority:"high"})}),"\n",(0,s.jsx)(t.h2,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,s.jsx)(t.p,{children:"When we are writing unit tests to verify system behaviour, we have to make choices. We need to choose the test framework that we'll use to run our tests. In the JavaScript world we'll be choosing from options including Jest, Mocha, tape, Jasmine and others. There are numerous other testing tools like Cypress and Playwright which cover broader automated testing needs, but we're intentionally just thinking about unit tests right now and so we'll exclude those."}),"\n",(0,s.jsx)(t.p,{children:"Of the various choices available, Jest is (at time of writing) very much the most popular. Since we have do not have a particular reason for favouring one of the frameworks that isn't as popular as Jest, that's what we'll use."}),"\n",(0,s.jsx)(t.p,{children:"Tests are a wonderful tool for asserting system behaviour. However, they can fail for mysterious reasons. When that happens, it can be helpful to see what the computer can see. It can be helpful to be able to debug your tests in the way you might hope to debug your other code."}),"\n",(0,s.jsx)(t.p,{children:"In this post:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"We'll set up a TypeScript Node.js project, containing some code we'd like to test."}),"\n",(0,s.jsx)(t.li,{children:"We'll configure our project to work with Jest and we'll write a test."}),"\n",(0,s.jsx)(t.li,{children:"We'll debug our unit test."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Let's begin."}),"\n",(0,s.jsx)(t.h2,{id:"setting-up-our-typescript-project",children:"Setting up our TypeScript project"}),"\n",(0,s.jsx)(t.p,{children:"First we'll create ourselves a new Node.js project:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"mkdir typescript-unit-tests-with-debug-support\ncd typescript-unit-tests-with-debug-support\nnpm init --yes\n"})}),"\n",(0,s.jsx)(t.p,{children:"At this point we have an empty Node.js project. Let's add TypeScript to it as a dependency and initialise our TypeScript project:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"npm install typescript\nnpx -p typescript tsc --init\n"})}),"\n",(0,s.jsx)(t.p,{children:"We now have a fully working TypeScript Node.js project and we're ready to start writing some code!"}),"\n",(0,s.jsxs)(t.p,{children:["This is a post about demonstrating unit testing with TypeScript. So naturally we need something to test. We're going write a simple module called ",(0,s.jsx)(t.code,{children:"greeter.ts"})," which has the following content:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"export function makeGreeting(name: string): string {\n  const lengthOfName = name.length;\n  const greeting = `Well hello there ${name}, I see your name is ${lengthOfName} characters long!`;\n  return greeting;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"greeter.ts"})," is a TypeScript file that contains a single simple function. The ",(0,s.jsx)(t.code,{children:"makeGreeting"})," function takes a string parameter and, over a number of lines, constructs a greeting string which the function returns. The nature of the greeting is inconsequential. However, remember later we want to be able to debug our test. We've intentionally written a function featuring more than one line of code. We've done this so we can demonstrate the benefits of debugging by showing the program state as it is in the process of executing."]}),"\n",(0,s.jsx)(t.h2,{id:"setting-up-the-jest-project",children:"Setting up the Jest project"}),"\n",(0,s.jsx)(t.p,{children:"The next step after setting up our TypeScript Node.js project, is adding tests, and the ability to run them, using Jest."}),"\n",(0,s.jsx)(t.p,{children:"First of all we're going to need to add Jest to our project and initially configure it:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"npm install --save-dev jest\nnpx jest --init\n"})}),"\n",(0,s.jsx)(t.p,{children:"As part of the initialisation you should be prompted with a number of questions:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"npx jest --init\n\nThe following questions will help Jest to create a suitable configuration for your project\n\n\u2714 Would you like to use Typescript for the configuration file? \u2026 no\n\u2714 Choose the test environment that will be used for testing \u203a node\n\u2714 Do you want Jest to add coverage reports? \u2026 no\n\u2714 Which provider should be used to instrument code for coverage? \u203a v8\n\u2714 Automatically clear mock calls, instances, contexts and results before every test? \u2026 no\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We'll select all the defaults; including ",(0,s.jsx)(t.em,{children:"not"})," using TypeScript for the configuration file. We don't require a configuration file written in TypeScript to be able to write TypeScript tests. The initialisation will create a ",(0,s.jsx)(t.code,{children:"jest.config.js"})," file which contains the configuration used to run our tests."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we'll update the ",(0,s.jsx)(t.code,{children:"scripts"})," section of our ",(0,s.jsx)(t.code,{children:"package.json"})," to invoke Jest:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'  "scripts": {\n    "test": "jest"\n  },\n'})}),"\n",(0,s.jsxs)(t.p,{children:["At this point we're in a place where we can run tests written in JavaScript. But we want to run tests written in TypeScript. ",(0,s.jsx)(t.a,{href:"https://jestjs.io/docs/getting-started#using-typescript",children:"Jest supports this scenario well"}),", using Babel. So we'll add the dependencies we need:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-typescript @types/jest\n"})}),"\n",(0,s.jsxs)(t.p,{children:["With all that done, let's see if we can write a test. We'll create a ",(0,s.jsx)(t.code,{children:"greeter.test.ts"})," file to sit alongside ",(0,s.jsx)(t.code,{children:"greeter.ts"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { makeGreeting } from './greeter';\n\ntest('given a name produces the expected greeting', () => {\n  expect(makeGreeting('George')).toBe(\n    'Well hello there George, I see your name is 6 characters long!',\n  );\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This simple test, invokes the ",(0,s.jsx)(t.code,{children:"makeGreeting"})," function in our ",(0,s.jsx)(t.code,{children:"greeter.ts"})," file and asserts the return value is as expected. Let us see if we can run our test with ",(0,s.jsx)(t.code,{children:"npm run test"}),":"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of tests running and passing in the terminal",src:n(83914).Z+"",width:"866",height:"370",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"Success! We've now created a TypeScript project, written a function, written a test for that function and we have the ability to run it."}),"\n",(0,s.jsx)(t.h2,{id:"set-up-debugging-support",children:"Set up debugging support"}),"\n",(0,s.jsxs)(t.p,{children:["The final thing we wanted to tackle was adding debug support. In times past, this was often quite tricky to configure. However, debugging has become much easier due to the excellent ",(0,s.jsx)(t.a,{href:"https://github.com/jest-community/vscode-jest",children:(0,s.jsx)(t.code,{children:"vscode-jest"})}),' project, which is dedicated to making "testing more intuitive and fun". In fact, with this extension the experience is now very "plug and play" which is a great thing.']}),"\n",(0,s.jsx)(t.p,{children:"Inside VS Code, we will install the vscode-jest extension:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of the VS Code Jest extension",src:n(58584).Z+"",width:"906",height:"352",loading:"lazy"})}),"\n",(0,s.jsxs)(t.p,{children:["Once it's installed, we'll need to restart VS Code, and we may also need to enter the ",(0,s.jsx)(t.code,{children:"Jest: Start All Runners"})," command in VS Codes power bar:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of the Jest: Start All Runners command in VS Code",src:n(45740).Z+"",width:"1192",height:"350",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"Once the Jest runners have started, we start to see the benefits that the VS Code Jest plugin offers. Where tests exist in our code, they are detected by the plugin and run. Depending upon whether tests are passing or failing we will be presented with a red cross or a green tick denoting failure or success directly alongside the code:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of the jest test explorer with a green tick next to a passing test",src:n(61886).Z+"",width:"2140",height:"406",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"Using the test explorer, it's possible to run tests on demand. Even more excitingly, it's now possible to debug them too. If you examine the test explorer and right / command click on a given test, you'll be presented with the option to debug a test:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of the context menu in the Jest explorer featuring the words &quot;Debug Test&quot;",src:n(89574).Z+"",width:"2140",height:"480",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"Excitingly this means exactly what we might hope. If we put breakpoints in our code, when the test runs we'll now hit them. We'll be able to debug and introspect each test that runs:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of a test being debugged",src:n(14522).Z+"",width:"2480",height:"480",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"If you look at the screenshot above you'll see we've stopped on a breakpoint, we're able to examine the context of the program at the point that it has paused. We can step further on in our code, we can do all the useful things that debugging affords us. We have succeeded in debugging."}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"In this piece we've taken a look at how to get up and running with a unit testable TypeScript project. Beyond that, we've demonstrated how we can debug our TypeScript tests using the VS Code editor."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://meticulous.ai/blog/typescript-unit-tests-with-debugging/",children:"This post was originally published on Meticulous."})})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},21897:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/title-image-0e63c04f8d1675d5dde527914ccc9f7f.png"},14522:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/screenshot-jest-debug-test-df3894e357383bcdfedfcaf1133309ce.png"},45740:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/screenshot-jest-start-all-runners-f2b658005aaa5058e5f53945e1833477.png"},89574:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/screenshot-jest-test-explorer-debug-test-e30494b6c7a343a98d906d146984f9b4.png"},61886:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/screenshot-jest-test-explorer-cf9d396c8212b3a48beb40625b8585f3.png"},83914:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/screenshot-of-tests-passing-0b849ef654b02c80b48a2d969237213b.png"},58584:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/screenshot-of-vscode-jest-d8ec4174a380e090da1608f22f7dde0d.png"},41427:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/title-image-0e63c04f8d1675d5dde527914ccc9f7f.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>r});var s=n(67294);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);