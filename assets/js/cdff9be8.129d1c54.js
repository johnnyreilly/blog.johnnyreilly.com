"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[5032],{28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>i});var t=o(96540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},29005:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>t,toc:()=>d});var t=o(37363),s=o(74848),a=o(28453);const r={slug:"webpack-resolveloader-alias-with-query",title:"webpack: resolveLoader / alias with query / options",authors:"johnnyreilly",tags:["webpack"],hide_table_of_contents:!1,description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options."},i=void 0,l={authorsImageUrls:[void 0]},d=[];function h(e){const n={a:"a",code:"code",em:"em",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:'Sometimes you write a post for the ages. Sometimes you write one you hope is out of date before you hit "publish". This is one of those.'}),"\n",(0,s.jsxs)(n.p,{children:["There's a ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/enhanced-resolve/issues/41",children:"bug"})," in webpack's enhanced-resolve. It means that you cannot configure an aliased loader using the ",(0,s.jsx)(n.code,{children:"query"})," (or ",(0,s.jsx)(n.code,{children:"options"})," in the webpack 2 nomenclature). Let me illustrate; consider the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    loaders: [\n      {\n        test: /\\.ts$/,\n        loader: 'ts-loader',\n        query: {\n            entryFileIsJs: true\n        }\n      }\n    ]\n  }\n}\n\nmodule.exports.resolveLoader = { alias: { 'ts-loader': require('path').join(__dirname, \"../../index.js\")\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At the time of writing, if you alias a loader as above, then the ",(0,s.jsx)(n.code,{children:"query"})," / ",(0,s.jsx)(n.code,{children:"options"})," will *",(0,s.jsx)(n.em,{children:"not"}),"* be passed along. This is bad, particularly given the requirement in webpack 2 that configuration is no longer possible through extending the ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/guides/migrating/#loader-configuration-is-through-options",children:(0,s.jsx)(n.code,{children:"webpack.config.js"})}),". So what to do? Well, when this was a problem previously the marvellous ",(0,s.jsx)(n.a,{href:"https://www.twitter.com/jbrantly",children:"James Brantly"})," had a ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/webpack/issues/1289#issuecomment-125767499",children:"workaround"}),". I've taken that and run with it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var config = {\n  // ...\n  module: {\n    loaders: [\n      {\n        test: /\\.ts$/,\n        loader: 'ts-loader',\n        query: {\n          entryFileIsJs: true,\n        },\n      },\n    ],\n  },\n};\n\nmodule.exports = config;\n\nvar loaderAliasPath = require('path').join(__dirname, '../../../index.js');\nvar rules = config.module.loaders || config.module.rules;\nrules.forEach(function (rule) {\n  var options = rule.query || rule.options;\n  rule.loader = rule.loader.replace(\n    'ts-loader',\n    loaderAliasPath + (options ? '?' + JSON.stringify(options) : ''),\n  );\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This approach stringifies the ",(0,s.jsx)(n.code,{children:"query"})," / ",(0,s.jsx)(n.code,{children:"options"})," and suffixes it to the aliased path. This works as long as the options you're passing are JSON-able (yes it's a word)."]}),"\n",(0,s.jsx)(n.p,{children:"As I said earlier; hopefully by the time you read this the workaround will no longer be necessary again. But just in case...."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},37363:e=>{e.exports=JSON.parse('{"permalink":"/webpack-resolveloader-alias-with-query","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2017-01-06-webpack-resolveloader-alias-with-query/index.md","source":"@site/blog/2017-01-06-webpack-resolveloader-alias-with-query/index.md","title":"webpack: resolveLoader / alias with query / options","description":"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options.","date":"2017-01-06T00:00:00.000Z","tags":[{"inline":false,"label":"webpack","permalink":"/tags/webpack","description":"The webpack module bundler."}],"readingTime":1.34,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"webpack-resolveloader-alias-with-query","title":"webpack: resolveLoader / alias with query / options","authors":"johnnyreilly","tags":["webpack"],"hide_table_of_contents":false,"description":"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options."},"unlisted":false,"prevItem":{"title":"Hands-free HTTPS","permalink":"/hands-free-https"},"nextItem":{"title":"webpack: configuring a loader with query / options","permalink":"/webpack-configuring-loader-with-query"}}')}}]);