"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[29468],{90067:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=n(74848),i=n(28453);const s={slug:"type-annotations-proposal-strong-types-weakly-held",title:"Type annotations: strong types, weakly held",authors:"johnnyreilly",tags:["typescript","javascript"],image:"./title-image.png",description:"Type annotations is a proposal which would allow for the inclusion of types in JavaScript code. Here is a description of the proposal and some thoughts.",hide_table_of_contents:!1},a=void 0,r={permalink:"/type-annotations-proposal-strong-types-weakly-held",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2022-04-16-type-annotations-proposal-strong-types-weakly-held/index.md",source:"@site/blog/2022-04-16-type-annotations-proposal-strong-types-weakly-held/index.md",title:"Type annotations: strong types, weakly held",description:"Type annotations is a proposal which would allow for the inclusion of types in JavaScript code. Here is a description of the proposal and some thoughts.",date:"2022-04-16T00:00:00.000Z",tags:[{label:"typescript",permalink:"/tags/typescript"},{label:"javascript",permalink:"/tags/javascript"}],readingTime:8.645,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"type-annotations-proposal-strong-types-weakly-held",title:"Type annotations: strong types, weakly held",authors:"johnnyreilly",tags:["typescript","javascript"],image:"./title-image.png",description:"Type annotations is a proposal which would allow for the inclusion of types in JavaScript code. Here is a description of the proposal and some thoughts.",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Upgrading to React 18 with TypeScript",permalink:"/upgrading-to-react-18-typescript"},nextItem:{title:"ESLint your C# in VS Code with Roslyn Analyzers",permalink:"/eslint-your-csharp-in-vs-code-with-roslyn-analyzers"}},l={image:n(48683).A,authorsImageUrls:[void 0]},c=[{value:"What is the proposal?",id:"what-is-the-proposal",level:2},{value:"What isn&#39;t it?",id:"what-isnt-it",level:2},{value:"Why do this at all?",id:"why-do-this-at-all",level:2},{value:"&quot;It&#39;s the JSDoc I always wanted!&quot;",id:"its-the-jsdoc-i-always-wanted",level:2},{value:"Controversy and Compromise",id:"controversy-and-compromise",level:2},{value:"Generic invocations and TypeScript",id:"generic-invocations-and-typescript",level:2},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{Head:s}=t;return s||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Recently, a new ECMAScript proposal called ",(0,o.jsx)(t.a,{href:"https://github.com/tc39/proposal-type-annotations",children:'"Type Annotations"'})," (originally named ",(0,o.jsx)(t.a,{href:"https://github.com/giltayar/proposal-types-as-comments",children:'"Types as Comments"'}),") was revealed. The purpose is to allow type annotations to be valid JavaScript syntax. Albeit syntax that is ignored by JavaScript engines. The proposal is being worked on by Gil Tayar, Daniel Rosenwasser, Romulo Cintra, Rob Palmer, and others. Many of these people are from TypeScript community - however this proposal intentionally does not exist to benefit TypeScript alone."]}),"\n",(0,o.jsx)(t.p,{children:"It's a contentious topic. As a regular (and longtime) TypeScript user, here's a description of the proposal and some thoughts."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"title image reading &quot;Type annotations: strong types, weakly held&quot; with the JavaScript logo",src:n(65056).A+"",width:"1600",height:"900",loading:"eager",fetchpriority:"high"})}),"\n",(0,o.jsx)(t.h2,{id:"what-is-the-proposal",children:"What is the proposal?"}),"\n",(0,o.jsx)(t.p,{children:"Types annotations is a proposal which would allow for the inclusion of types in JavaScript code. Consider the following piece of TypeScript:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"const theAnswer: number = 42;\n"})}),"\n",(0,o.jsx)(t.p,{children:"At present, this is not valid JavaScript. If you try and run the above in a JavaScript engine you'll get an error. Types are not part of JavaScript syntax."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"screenshot of const theAnswer: number = 42; entered into the Chrome devtools and responding with an error that says Uncaught SyntaxError: Missing initializer in const declaration",src:n(64941).A+"",width:"1542",height:"140",loading:"lazy"})}),"\n",(0,o.jsxs)(t.p,{children:["Interestingly, it's already possible to store types within JavaScript through a standard known as JSDoc. ",(0,o.jsx)(t.a,{href:"https://blog.logrocket.com/typescript-vs-jsdoc-javascript/",children:"I've written about how TypeScript and JSDoc connect before."}),", essentially the thing to note is that JSDoc amounts to storing type declarations in the context of JavaScript comments."]}),"\n",(0,o.jsx)(t.p,{children:"It's already possible to write our code sample in valid JavaScript expressing the types within JSDoc. It looks like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"/** @type {number} */\nconst theAnswer = 42;\n"})}),"\n",(0,o.jsx)(t.p,{children:"This works, but it took two lines of code instead of one. The proposal allows for types to be directly expressed; not written as comments. So rather than writing the JSDoc equivalent, imagine if JavaScript was happy with the following instead:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"const theAnswer: number = 42;\n"})}),"\n",(0,o.jsx)(t.p,{children:"That's what the proposal amounts to."}),"\n",(0,o.jsx)(t.h2,{id:"what-isnt-it",children:"What isn't it?"}),"\n",(0,o.jsx)(t.p,{children:"Now that we understand what the proposal is, let's consider what it isn't."}),"\n",(0,o.jsx)(t.p,{children:"Types annotations isn't an endorsement of a particular type system. Furthermore, it is not type checking in the browser or type checking in Node.js."}),"\n",(0,o.jsx)(t.p,{children:"Let's consider each of these. There's a number of languages which allow us to type check JavaScript. TypeScript, Flow, Hegel and others all play in this space. They are all similar, but different. They have different syntax and they do different things."}),"\n",(0,o.jsx)(t.p,{children:'What they have in common, is the space where types live in their syntax or grammar. The proposal essentially says "hey we might have different approaches to describing types, but we agree about where the types ought to live - let\'s standardise that".'}),"\n",(0,o.jsx)(t.p,{children:'This is why the original proposal name of "types as comments" is instructive; these types would be ignored by JavaScript runtimes. The fact they would be ignored is an indication that no existing type system would be "anointed" by this proposal.'}),"\n",(0,o.jsx)(t.p,{children:"Consider the following:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"const theAnswer: gibberish = 42;\n"})}),"\n",(0,o.jsx)(t.p,{children:"This is neither TypeScript or Flow. Both would complain about the above. JavaScript, if this proposal were adopted, would be entirely untroubled."}),"\n",(0,o.jsx)(t.p,{children:"To reiterate: the proposal is not an endorsement of any given type system and it follows that there is no runtime type checking being introduced to JavaScript."}),"\n",(0,o.jsx)(t.h2,{id:"why-do-this-at-all",children:"Why do this at all?"}),"\n",(0,o.jsxs)(t.p,{children:["It's worth taking a look at ",(0,o.jsx)(t.a,{href:"https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/",children:"Daniel Rosenwasser"}),"'s post where he announces the proposal. Daniel is part of the TypeScript team and one of champions of this proposal, along with ",(0,o.jsx)(t.a,{href:"https://twitter.com/robpalmer2",children:"Rob Palmer"})," at Bloomberg and ",(0,o.jsx)(t.a,{href:"https://twitter.com/romulocintra",children:"Romulo Cintra"})," at Igalia."]}),"\n",(0,o.jsx)(t.p,{children:"He says:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Today, you can create a .js file in your editor and start sprinkling in types in the form of JSDoc comments."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"/**\n * @param a {number}\n * @param b {number}\n */\nfunction add(a, b) {\n  return a + b;\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Because these are just comments, they don\u2019t change how your code runs at all \u2013 they\u2019re just a form of documentation, but TypeScript uses them to give you a better JavaScript editing experience ... This feature makes it incredibly convenient to get some of the TypeScript experience without a build step, and you can use it for small scripts, basic web pages, server code in Node.js, etc."}),"\n",(0,o.jsx)(t.p,{children:"Still, you\u2019ll notice that this is a little verbose \u2013 we love how lightweight the inner-loop is for writing JavaScript, but we\u2019re missing how convenient TypeScript makes it to just write types."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"So what if we had both?"})}),"\n",(0,o.jsx)(t.p,{children:"What if we could have something like TypeScript syntax which was totally ignored \u2013 sort of like comments \u2013 in JavaScript."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"function add(a: number, b: number) {\n  return a + b;\n}\n"})}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"What I take from this, is that JavaScript with types annotations, would be a more developer friendly JSDoc."}),"\n",(0,o.jsx)(t.h2,{id:"its-the-jsdoc-i-always-wanted",children:'"It\'s the JSDoc I always wanted!"'}),"\n",(0,o.jsx)(t.p,{children:"This idea really resonates with me. I'm a longtime user of JSDoc. Let me articulate why I find it useful."}),"\n",(0,o.jsxs)(t.p,{children:["What I wanted, way back before TypeScript existed, was JavaScript with static typing. TypeScript ",(0,o.jsx)(t.em,{children:"mostly"})," is that. At least in the way I choose to use it."]}),"\n",(0,o.jsxs)(t.p,{children:["I don't use ",(0,o.jsx)(t.code,{children:"enum"}),"s, ",(0,o.jsx)(t.code,{children:"namespace"}),"s, ",(0,o.jsx)(t.code,{children:"decorator"}),"s etc. This is significant as each of those features steps has an emit aspect; using one of these will require transpilation to create special JavaScript to represent a custom TypeScript implemented feature. All other TypeScript features are ",(0,o.jsx)(t.em,{children:"erased"})," by transpilation; there's no execution characteristics."]}),"\n",(0,o.jsxs)(t.p,{children:["So by subsetting the features of TypeScript, we can choose to use only those features that do not have an emit aspect. By making that choice, it's possible to use just JavaScript, if we're willing to commit to using JSDoc syntax within JavaScript ",(0,o.jsx)(t.em,{children:"instead"})," of TypeScript. There's many in the community who are doing this on sizeable projects like ",(0,o.jsx)(t.a,{href:"https://github.com/webpack/webpack",children:"webpack"})," already. We don't lose type checking, we don't lose refactoring possibilities thanks to editors like VS Code."]}),"\n",(0,o.jsxs)(t.p,{children:["JSDoc is great, but it's undeniably more verbose than writing TypeScript. If types annotations was to be adopted, we'd able to write TypeScript in our JavaScript files. We'd be able to use TypeScript to type check that ",(0,o.jsx)(t.strong,{children:"if we wanted to"}),". But we wouldn't need to transpile our code prior to running. We could run our source code directly. Brilliant!"]}),"\n",(0,o.jsx)(t.h2,{id:"controversy-and-compromise",children:"Controversy and Compromise"}),"\n",(0,o.jsx)(t.p,{children:'Up until now, as we\'ve looked at the proposal, the story has been one of JavaScript becoming "types tolerant". And as a consequence, the syntax of Flow / TypeScript / Hegel et al would in future being considered valid JavaScript.'}),"\n",(0,o.jsx)(t.p,{children:"This paints a picture of JavaScript, a dynamic language, being changed to accomodate the sensibilities of those who favour static typing. If you should glance at the discussions on Hacker News and in the issues of the proposal it's clear there's a very vocal section of JavaScript developers who consider this proposal to be thoroughly unwanted."}),"\n",(0,o.jsx)(t.p,{children:"Whilst it's unlikely that the most fervent dynamic language advocate will change their mind, it's worth considering the nuance of this proposal. In actual fact, the proposal is a two way street; to comply with types becoming JavaScript native, languages like TypeScript would likely make changes to accomodate."}),"\n",(0,o.jsx)(t.h2,{id:"generic-invocations-and-typescript",children:"Generic invocations and TypeScript"}),"\n",(0,o.jsxs)(t.p,{children:["There's a few cases which apply, the one that seems most significant is that of generic invocation. ",(0,o.jsx)(t.a,{href:"https://github.com/giltayar/proposal-types-as-comments#generic-invocations",children:"To quote the proposal"}),":"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["One can explicitly specify the type arguments of a generic function invocation or generic class instantiation ",(0,o.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/2/functions.html#specifying-type-arguments",children:"in TypeScript"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"// TypeScript\nadd<number>(4, 5);\nnew Point<bigint>(4n, 5n);\n"})}),"\n",(0,o.jsx)(t.p,{children:"The above syntax is already valid JavaScript that users may rely on, so we cannot use this syntax as-is."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["So if this proposal was to land, writing today's style TypeScript in JavaScript would ",(0,o.jsx)(t.em,{children:"not"})," work in the case of generic invocations."]}),"\n",(0,o.jsx)(t.p,{children:"If we read on in the proposal it says;"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["We expect some form of new syntax that could be used to resolve this ambiguity.\nNo specific solution is proposed at this point of time, but one example option is to use a syntactic prefix such as ",(0,o.jsx)(t.code,{children:"::"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"// Types as Comments - example syntax solution\nadd::<number>(4, 5)\nnew Point::<bigint>(4n, 5n)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["These type arguments (",(0,o.jsx)(t.code,{children:"::<type>"}),") would be ignored by the JavaScript runtime.\nIt would be reasonable for this non-ambiguous syntax to be adopted in TypeScript as well."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This last sentence is significant. Let's read it again:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"It would be reasonable for this non-ambiguous syntax to be adopted in TypeScript as well"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Whilst not being an absolute commitment, this certainly suggests that TypeScript would be willing to change its own syntax to align with something that was standardised as typed JavaScript."}),"\n",(0,o.jsx)(t.p,{children:"Speaking personally, I don't love the proposed new syntax; but I understand the rationale. Certainly a new generic invocation syntax is something I could come to terms with. It's good of the TypeScript team to be open to the idea of making changes to the language to align with the proposal. This is not zero cost to them. This demonstrates that to allow this proposal to land, there will be compromises on many sides. It's likely that Flow will be similarly affected also."}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"When you see the various discussions on this topic online, it's clear there are many strong feelings. The proposal hasn't even reached stage 1 (of the potential 4 stages required for adoption). This may be a feature that doesn't make it. Or perhaps takes a long time to land on a mutually agreed design."}),"\n",(0,o.jsx)(t.p,{children:"Speaking personally I'm hopeful that this does end up being part of the language. Not only do I like running raw JS, I see the benefits of being able to onboard people from JavaScript to TypeScript by allowing types to live directly in JavaScript."}),"\n",(0,o.jsx)(t.p,{children:"It's said that prediction is very difficult, especially if it's about the future. So it is hard to know for sure what the long term effects on the language and the ecosystem of this proposal might be. It would certainly lower the barrier to entry for using static typing with JavaScript, and as consequence, would likely lead to greater adoption and hence less bugs in userland. Time will tell."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://blog.logrocket.com/types-as-comments-strong-types-weakly-held/",children:"This post was originally published on LogRocket."})}),"\n",(0,o.jsx)(s,{children:(0,o.jsx)("link",{rel:"canonical",href:"https://blog.logrocket.com/types-as-comments-strong-types-weakly-held/"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},48683:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/title-image-84ae91cde9aba574acfb0a7501676727.png"},64941:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/screenshot-types-in-the-chrome-console-2f656d1328f435bddf88bb8b66369847.png"},65056:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/title-image-84ae91cde9aba574acfb0a7501676727.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(96540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);