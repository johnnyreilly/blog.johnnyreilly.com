"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[56890],{8284:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-f0945ac5da387c7202af084f33c85949.png"},16713:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/screenshot-passing-test-3be0cdc3300c87afdf9f101647414ed9.png"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}},63041:e=>{e.exports=JSON.parse('{"permalink":"/keeping-front-end-and-back-end-in-sync-with-nswag-generated-clients","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2025-10-12-keeping-front-end-and-back-end-in-sync-with-nswag-generated-clients/index.md","source":"@site/blog/2025-10-12-keeping-front-end-and-back-end-in-sync-with-nswag-generated-clients/index.md","title":"Keeping front end and back end in sync with NSwag generated clients","description":"By generating clients from OpenAPI specs, it is possible to have integration tests that check your front end and your back end are aligned. This post will show you how to do that using NSwag.","date":"2025-10-12T00:00:00.000Z","tags":[{"inline":false,"label":"Swagger","permalink":"/tags/swagger","description":"The Swagger API documentation framework - now known as OpenAPI."},{"inline":false,"label":"C#","permalink":"/tags/csharp","description":"The C# programming language."},{"inline":false,"label":"Azure","permalink":"/tags/azure","description":"The Microsoft cloud platform."},{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."}],"readingTime":5.77,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"keeping-front-end-and-back-end-in-sync-with-nswag-generated-clients","title":"Keeping front end and back end in sync with NSwag generated clients","authors":"johnnyreilly","tags":["swagger","c#","azure","typescript"],"image":"./title-image.png","hide_table_of_contents":false,"description":"By generating clients from OpenAPI specs, it is possible to have integration tests that check your front end and your back end are aligned. This post will show you how to do that using NSwag."},"unlisted":false,"prevItem":{"title":"Where AI-assisted coding accelerates development \u2014 and where it doesn\u2019t","permalink":"/ai-assisted-coding"},"nextItem":{"title":"Azure DevOps: merging pull requests with conventional commits","permalink":"/azure-devops-pull-requests-conventional-commits"}}')},69045:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-f0945ac5da387c7202af084f33c85949.png"},74481:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var i=n(63041),s=n(74848),a=n(28453);const r={slug:"keeping-front-end-and-back-end-in-sync-with-nswag-generated-clients",title:"Keeping front end and back end in sync with NSwag generated clients",authors:"johnnyreilly",tags:["swagger","c#","azure","typescript"],image:"./title-image.png",hide_table_of_contents:!1,description:"By generating clients from OpenAPI specs, it is possible to have integration tests that check your front end and your back end are aligned. This post will show you how to do that using NSwag."},o=void 0,c={image:n(69045).A,authorsImageUrls:[void 0]},l=[{value:"The scenario",id:"the-scenario",level:2},{value:"The integration test",id:"the-integration-test",level:2},{value:"Finishing up",id:"finishing-up",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["For many years I've been a big fan of using ",(0,s.jsx)(t.a,{href:"https://github.com/RicoSuter/NSwag",children:"NSwag"})," to generate TypeScript and CSharp clients for APIs. I've written about it before in ",(0,s.jsx)(t.a,{href:"/generate-typescript-and-csharp-clients-with-nswag",children:"Generate TypeScript and CSharp clients with NSwag"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"title image reading &quot;Keeping front end and back end in sync with NSwag generated clients&quot; with the Open API, TypeScript and C# logos",src:n(8284).A+"",width:"800",height:"450",loading:"lazy"})}),"\n",(0,s.jsxs)(t.p,{children:["You're likely aware of the popularity of excellent projects like ",(0,s.jsx)(t.a,{href:"https://trpc.io/",children:"tRPC"})," which provide a way to use TypeScript end-to-end. However, if you're working in a polyglot environment where your back end is written in C# or [insert other language here], and your front end is written in TypeScript, then cannot take advantage of that. However, by generating front end clients from a server's OpenAPI specs, it's possible to have integration tests that check your front end and your back end are aligned."]}),"\n",(0,s.jsx)(t.p,{children:"This post will show you how to do that using NSwag."}),"\n",(0,s.jsx)(t.h2,{id:"the-scenario",children:"The scenario"}),"\n",(0,s.jsx)(t.p,{children:"Let's talk about the kind of situation that I'm imagining. From reading the web, you'd think that every organisation is running both TypeScript on its front end and on its back end. In my experience, this is not the case. Many organisations have a particular technology stack on the back end - maybe C#/.NET - and a different one on the front end - generally TypeScript/JavaScript."}),"\n",(0,s.jsx)(t.p,{children:"The technique of generating clients from OpenAPI specs is useful in this scenario. It means that you can keep your front end and back end in sync, even if they are written in different languages. The source of truth is the Open API spec, which is typically generated from the back end code. The front end client code is generated from the Open API spec. And then, because TypeScript is compiled, you can do a compilation test to check that the front end code is in sync with the back end code."}),"\n",(0,s.jsx)(t.p,{children:"It's a simple idea but it is powerful. I typically achieve it in two steps:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Make sure your continuous integration (CI) process compiles the front end code."}),"\n",(0,s.jsx)(t.li,{children:"Add an integration test that checks that the generated client is up to date with the latest back end code."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Most people will have done the first step. If you have a strongly typed front end project that is compiled as part of your CI process, then you will get a compilation errors if have code that does not type check successfully."}),"\n",(0,s.jsx)(t.p,{children:"The second step is ensuring alignment between front and back ends. This is where you add an integration test that checks that the generated client is up to date with the back end. This is remarkably easy to achieve. You already have a mechanism for generating a TypeScript client from the back end code. You just need to generate the client code as part of your test, and then check that the generated code is the same as the already committed code."}),"\n",(0,s.jsx)(t.p,{children:"Let's see what that looks like."}),"\n",(0,s.jsx)(t.h2,{id:"the-integration-test",children:"The integration test"}),"\n",(0,s.jsxs)(t.p,{children:["I'm going to use ",(0,s.jsx)(t.a,{href:"https://vitest.dev/",children:"Vitest"})," for this example. I love it, you could use pretty much any test framework you like. Really we're just checking that one string is the same as another and so you could get by without any test framework at all if you fancied."]}),"\n",(0,s.jsxs)(t.p,{children:["In my example, I'll have a separate ",(0,s.jsx)(t.code,{children:"client-server-tests"})," project for the tests. Here's the ",(0,s.jsx)(t.code,{children:"package.json"})," for that project:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "name": "client-server-tests",\n  "version": "0.0.0",\n  "scripts": {\n    "copy-original-generated-client": "copyfiles --flat ../client-app/src/clients.ts tmp/",\n    "regenerate-generated-client": "cd ../../ && pnpm run generate-client",\n    "testprepare": "pnpm run copy-original-generated-client && pnpm run regenerate-generated-client",\n    "test:ci": "pnpm run testprepare && vitest run --reporter=default --reporter=junit --outputFile=reports/junit.xml",\n    "test": "pnpm run testprepare && vitest"\n  },\n  "devDependencies": {\n    "copyfiles": "^2.4.1",\n    "typescript": "^5.8.3",\n    "vite": "^6.3.6",\n    "vitest": "^3.2.4"\n  }\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"But you could fold this into your front end project directly if you prefer."}),"\n",(0,s.jsxs)(t.p,{children:["I'm not going to repeat the code of the previous post that demonstrated how to ",(0,s.jsx)(t.a,{href:"/generate-typescript-and-csharp-clients-with-nswag",children:"generate TypeScript clients with NSwag"})," - but please imagine that the code for the TypeScript client has been generated and is available in a front end project. The code above refers to the front end of that project as ",(0,s.jsx)(t.code,{children:"client-app"})," and the generated client code is in ",(0,s.jsx)(t.code,{children:"client-app/src/clients.ts"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For that project, the back end is in C#, but it could be in any language that can generate an OpenAPI spec. The important thing is that the OpenAPI spec is the source of truth for the API."}),"\n",(0,s.jsxs)(t.p,{children:["You'll notice that both the ",(0,s.jsx)(t.code,{children:"test:ci"})," and ",(0,s.jsx)(t.code,{children:"test"})," scripts run a ",(0,s.jsx)(t.code,{children:"testprepare"})," script first. This script does two things:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"It copies the currently checked-in generated client code to a temporary location."}),"\n",(0,s.jsx)(t.li,{children:"It regenerates the client code from the OpenAPI spec (which would override the checked-in code)."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This leaves us ready to do our comparison. We can write a test that checks that the generated code is up to date. Here's what that looks like:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { expect, test } from 'vitest';\nimport fs from 'fs';\n\ntest('generated-client', () => {\n  const committedClient = fs.readFileSync('tmp/clients.ts', 'utf8');\n  const newlyGeneratedClient = fs.readFileSync(\n    '../client-app/src/clients.ts',\n    'utf8',\n  );\n\n  expect(\n    committedClient,\n    \"try `pnpm run generate-client`; generated client doesn't match the server\",\n  ).toBe(newlyGeneratedClient);\n});\n"})}),"\n",(0,s.jsx)(t.p,{children:"This test simply compares the previously generated client code with the newly generated client code. If they don't match, the test fails and the message suggests running the client generation command. So as well as being a useful test, it also provides a helpful hint to the developer. Like so:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of failing test",src:n(80174).A+"",width:"1456",height:"490",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"Of course, you want to end up seeing a passing test:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"screenshot of passing test",src:n(16713).A+"",width:"650",height:"236",loading:"lazy"})}),"\n",(0,s.jsx)(t.h2,{id:"finishing-up",children:"Finishing up"}),"\n",(0,s.jsxs)(t.p,{children:["The last thing to do is to make sure that this test project is run as part of your CI process. I'm not going to show you how to do this, because it will depend on your CI system. But the idea is that you add a step to your CI process that installs your dependencies and runs the tests in the ",(0,s.jsx)(t.code,{children:"client-server-tests"})," project."]}),"\n",(0,s.jsx)(t.p,{children:"With that in place, you now have a way to ensure that your front end and back end are in sync. If someone makes a change to the back end that affects the OpenAPI spec, and they forget to regenerate the client code, the test will fail and they'll be prompted to run the client generation command."}),"\n",(0,s.jsx)(t.p,{children:"If the change that they made in some way breaks the front end code, then the front end build will fail because of the compilation errors. So you get two layers of protection."}),"\n",(0,s.jsx)(t.p,{children:"This is a simple but effective way to keep your front end and back end in sync, even if they are written in different languages."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},80174:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/screenshot-failing-test-a5daf2ac77c5b0549ab23de6fbfa8f59.png"}}]);