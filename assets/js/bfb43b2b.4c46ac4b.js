"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[17938],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var o=n(96540);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}},58052:e=>{e.exports=JSON.parse('{"permalink":"/template-tricks-for-dainty-dom","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2019-03-24-template-tricks-for-dainty-dom/index.md","source":"@site/blog/2019-03-24-template-tricks-for-dainty-dom/index.md","title":"Template Tricks for a Dainty DOM","description":"Wrapping data in HTML templates can help with performance. This trick kept rendering server-side but only rendered content when necessary.","date":"2019-03-24T00:00:00.000Z","tags":[],"readingTime":5.36,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"template-tricks-for-dainty-dom","title":"Template Tricks for a Dainty DOM","authors":"johnnyreilly","tags":[],"hide_table_of_contents":false,"description":"Wrapping data in HTML templates can help with performance. This trick kept rendering server-side but only rendered content when necessary."},"unlisted":false,"prevItem":{"title":"react-select with less typing lag","permalink":"/react-select-with-less-typing-lag"},"nextItem":{"title":"Google Analytics API and ASP.Net Core","permalink":"/google-analytics-api-and-aspnet-core"}}')},84871:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var o=n(58052),i=n(74848),a=n(28453);const s={slug:"template-tricks-for-dainty-dom",title:"Template Tricks for a Dainty DOM",authors:"johnnyreilly",tags:[],hide_table_of_contents:!1,description:"Wrapping data in HTML templates can help with performance. This trick kept rendering server-side but only rendered content when necessary."},l=void 0,r={authorsImageUrls:[void 0]},d=[{value:"&quot;Oh All Right; Just a Splash&quot;",id:"oh-all-right-just-a-splash",level:2},{value:"The DOM Bunker",id:"the-dom-bunker",level:2},{value:"Smuggling DOM in Templates",id:"smuggling-dom-in-templates",level:2},{value:"&quot;That Sounds Complicated...&quot;",id:"that-sounds-complicated",level:2},{value:"Do It Yourself",id:"do-it-yourself",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"I'm somewhat into code golf. Placing restrictions on what you're \"allowed\" to do in code and seeing what the happens as a result. I'd like to share with you something that came out of some recent dabblings."}),"\n",(0,i.jsx)(t.p,{children:"Typically I spend a good amount of time playing with TypeScript. Either working on build tools or making web apps with it. (Usually with a portion of React on the side.) This is something different."}),"\n",(0,i.jsxs)(t.p,{children:["I have a side project on the go which is essentially a mini analytics dashboard. For the purposes of this piece let's call it \"StatsDash\". When I was starting it I thought: let's try something different. Let's build StatsDash with HTML ",(0,i.jsx)(t.em,{children:"only"}),". The actual HTML is hand cranked by me and generated in ASP.Net Core / C# using a combination of LINQ and string interpolation. (Who needs Razor? \ud83d\ude0e) I'll say it's pretty fun - but the back end is not what I want to focus on."]}),"\n",(0,i.jsxs)(t.p,{children:["I got something up and running pretty quickly in pure HTML. The first lesson I learned was this: HTML alone is hella ugly. So I relaxed my criteria; I allowed CSS to come play as long as I didn't have to write any / much myself. There followed some experimentation with different CSS frameworks. For a while I rolled with Bootstrap (old school!), then Bulma and finally I settled on ",(0,i.jsx)(t.a,{href:"https://materializecss.com/",children:"Materialized"}),". Materialized is a heavily inspired by Google's Material Design and is hence quite beautiful. With my HTML and Materialize's CSS we were rolling. Beautiful stats - no JS."]}),"\n",(0,i.jsx)(t.h2,{id:"oh-all-right-just-a-splash",children:'"Oh All Right; Just a Splash"'}),"\n",(0,i.jsx)(t.p,{children:"Lovely as things were, StatsDash quickly got to the point where there was too much information on the screen. It was time to make some changes. If data is to convey a message, it must first be comprehensible."}),"\n",(0,i.jsxs)(t.p,{children:["I needed a way to hide and show data as people interacted with StatsDash. I wanted to achieve this ",(0,i.jsx)(t.em,{children:"without"})," starting to render on the client side and also without going back to the server each time."]}),"\n",(0,i.jsxs)(t.p,{children:["If you want interactions in your UI all roads lead to JS. It's certainly possible to do some tricks with CSS but that's a round of code golf I'm ill equipped to play. So, I took a look at what Materialized had to offer. Usefully it has a ",(0,i.jsx)(t.a,{href:"https://materializecss.com/modals.html",children:"Modal"})," component. With that in play I'd be able to separate the detailed information into different modals which the users could show and hide as required. Perfect!"]}),"\n",(0,i.jsx)(t.p,{children:"It required a little JS. What's a line or two between friends? Dear reader, I compromised once more."}),"\n",(0,i.jsx)(t.h2,{id:"the-dom-bunker",children:"The DOM Bunker"}),"\n",(0,i.jsx)(t.p,{children:'With my handy modals, StatsDash was now a one stop shop for a great deal of information. Info which took the form of DOM nodes. Lots of them. And by "lots of them" I want you to think along the lines of "space is big, really big...".'}),"\n",(0,i.jsx)(t.p,{children:"This was impacting users. Clicking to open a modal resulted in a noticeable lag. It would take 2+ seconds for the browser to respond. Users found themselves clicking multiple times; wondering why nothing seemed to occur. In the end the modal would shuffle into view. However, this wasn't the best experience. The lack of responsiveness was getting in the way of users enjoying all StatsDash had to offer."}),"\n",(0,i.jsx)(t.p,{children:"Running an audit of StatsDash in Chrome DevTools there was no doubt we had a DOM problem:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(99432).A+"",width:"640",height:"298",loading:"lazy"})}),"\n",(0,i.jsx)(t.p,{children:"What to do? I still didn't want to go back to the server on each click in StatsDash. And I didn't want to start writing rendering code on the client as well either. I have in the past mixed client and server side rendering and I know well that it's a first class ticket to a confusing codebase."}),"\n",(0,i.jsx)(t.h2,{id:"smuggling-dom-in-templates",children:"Smuggling DOM in Templates"}),"\n",(0,i.jsxs)(t.p,{children:["There's a mechanism that supports this use case directly: the ",(0,i.jsx)(t.code,{children:"&lt;template&gt;"})," element. ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template",children:"To quote MDN"}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["The HTML Content Template (",(0,i.jsx)(t.code,{children:"&lt;template&gt;"}),") element is a mechanism for holding client-side content that is not to be rendered when a page is loaded but may subsequently be instantiated during runtime using JavaScript."]}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Think of a template as a content fragment that is being stored for subsequent use in the document."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This is ",(0,i.jsx)(t.em,{children:"exactly"})," what I'm after. I can keep my rendering server side, but instead wrap content that isn't immediately visible to users inside a ",(0,i.jsx)(t.code,{children:"&lt;template&gt;"})," element and render that only when users need it."]}),"\n",(0,i.jsxs)(t.p,{children:["So in the case of my modals (where most of my DOM lives), I can tuck the contents of each modal into a ",(0,i.jsx)(t.code,{children:"&lt;template&gt;"})," element. Then, when the user clicks to open a modal we move that template content into the DOM so they can see it. Likewise, as they close a modal we can clear out the modal's DOM content to ease the load on the dear old browser."]}),"\n",(0,i.jsx)(t.h2,{id:"that-sounds-complicated",children:'"That Sounds Complicated..."'}),"\n",(0,i.jsxs)(t.p,{children:["It's not. Let me show you how easily this is accomplished. First of all, wrap all your modal contents into ",(0,i.jsx)(t.code,{children:"&lt;template&gt;"})," elements. They should look a little something like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-html",children:'<div>\n  <button data-target="modalId" class="btn modal-trigger">\n    Open the Modal!\n  </button>\n\n  <template>\n    \x3c!--\n        loads of DOM nodes\n        --\x3e\n  </template>\n\n  <div id="modalId" class="modal modal-fixed-footer"></div>\n</div>\n'})}),"\n",(0,i.jsx)(t.p,{children:"Next, where you initialise your modals you need to make a little tweak:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"document.addEventListener('DOMContentLoaded', function () {\n  M.Modal.init(document.querySelectorAll('.modal'), {\n    onOpenStart: (modalDiv) => {\n      const template = modalDiv.parentNode.querySelector('template');\n\n      modalDiv.appendChild(document.importNode(template.content, true));\n    },\n    onCloseEnd: (modalDiv) => {\n      while (modalDiv.firstChild) {\n        modalDiv.removeChild(modalDiv.firstChild);\n      }\n    },\n  });\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["That's it! As you can see, before we open our modals, the ",(0,i.jsx)(t.code,{children:"onOpenStart"})," callback will fire which creates the actual DOM elements based upon the ",(0,i.jsx)(t.code,{children:"template"}),". And when the modals finish closing the ",(0,i.jsx)(t.code,{children:"onCloseEnd"})," callback runs to remove those DOM elements once more."]}),"\n",(0,i.jsxs)(t.p,{children:["For this minimal change, the client gets a dramatically different user experience. StatsDash went from super laggy to satisfyingly fast. Using ",(0,i.jsx)(t.code,{children:"template"}),"s, The number of initial DOM nodes dropped from more than ",(0,i.jsx)(t.em,{children:"20,000"})," to ",(0,i.jsx)(t.em,{children:"200"}),". That's right \ud83d\udcaf times smaller!"]}),"\n",(0,i.jsx)(t.h2,{id:"do-it-yourself",children:"Do It Yourself"}),"\n",(0,i.jsx)(t.p,{children:"The code examples above rely upon the Materialize modals. However the principles used here are broadly applicable. It's easy for you to take the approach outlined here and apply it in a different situation."}),"\n",(0,i.jsxs)(t.p,{children:["If you're interested in some of the other exciting things you can do with templates then I recommend ",(0,i.jsx)(t.a,{href:"https://www.html5rocks.com/en/tutorials/webcomponents/template/",children:"Eric Bidelman's post on the topic"}),"."]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},99432:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/DOM-massive-9ed81ff6de342d3ac926256f9a8865f0.webp"}}]);