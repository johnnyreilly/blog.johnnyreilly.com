"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[94109],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=p(n),h=o,m=d["".concat(l,".").concat(h)]||d[h]||c[h]||i;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:o,s[1]=r;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},51877:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>p,toc:()=>d});n(67294);var a=n(3905);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const r={slug:"migrating-from-ts-node-to-bun",title:"Migrating from ts-node to Bun",authors:"johnnyreilly",tags:["Node.js","TypeScript"],image:"./title-image.png",description:"Migrating from ts-node to Bun is surprisingly easy - this post ports a console app from ts-node to Bun and compares performance.",hide_table_of_contents:!1},l=void 0,p={permalink:"/migrating-from-ts-node-to-bun",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-03-18-migrating-from-ts-node-to-bun/index.md",source:"@site/blog/2023-03-18-migrating-from-ts-node-to-bun/index.md",title:"Migrating from ts-node to Bun",description:"Migrating from ts-node to Bun is surprisingly easy - this post ports a console app from ts-node to Bun and compares performance.",date:"2023-03-18T00:00:00.000Z",formattedDate:"March 18, 2023",tags:[{label:"Node.js",permalink:"/tags/node-js"},{label:"TypeScript",permalink:"/tags/type-script"}],readingTime:9.245,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"migrating-from-ts-node-to-bun",title:"Migrating from ts-node to Bun",authors:"johnnyreilly",tags:["Node.js","TypeScript"],image:"./title-image.png",description:"Migrating from ts-node to Bun is surprisingly easy - this post ports a console app from ts-node to Bun and compares performance.",hide_table_of_contents:!1},prevItem:{title:"Playwright, GitHub Actions and Azure Static Web Apps staging environments",permalink:"/playwright-github-actions-and-azure-static-web-apps-staging-environments"},nextItem:{title:"Node.js 18, Axios and unsafe legacy renegotiation disabled",permalink:"/node-18-axios-and-unsafe-legacy-renegotiation-disabled"}},u={image:n(79436).Z,authorsImageUrls:[void 0]},d=[{value:"The ts-node app",id:"the-ts-node-app",level:2},{value:"Installing Bun",id:"installing-bun",level:2},{value:"Porting the install from yarn to bun",id:"porting-the-install-from-yarn-to-bun",level:2},{value:"From <code>@types/node</code> to <code>bun/types</code>",id:"from-typesnode-to-buntypes",level:2},{value:"<code>moduleResolution</code> with Bun",id:"moduleresolution-with-bun",level:2},{value:"File APIs with Bun",id:"file-apis-with-bun",level:2},{value:"Clarification on <code>fs.promises</code>",id:"clarification-on-fspromises",level:3},{value:"Running the app",id:"running-the-app",level:2},{value:"Top level <code>await</code> and Bun",id:"top-level-await-and-bun",level:2},{value:"GitHub Actions and Bun",id:"github-actions-and-bun",level:2},{value:"Performance comparison; Bun vs ts-node",id:"performance-comparison-bun-vs-ts-node",level:2},{value:"ts-node",id:"ts-node",level:3},{value:"Bun",id:"bun",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:d};function h(e){var{components:t}=e,r=s(e,["components"]);return(0,a.kt)("wrapper",i(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){o(e,t,n[t])}))}return e}({},c,r),{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"I've wanted to take a look at some of the alternative JavaScript runtimes for a while. The thing that has held me back is npm compatibility. I want to be able to run my code in a runtime that isn't Node.js and still be able to use npm packages. I've been using ",(0,a.kt)("a",{parentName:"p",href:"https://typestrong.org/ts-node/"},"ts-node")," for a long time now; it's what I reach for when I'm building any kind of console app. In this post I want to port a console app from ts-node to ",(0,a.kt)("a",{parentName:"p",href:"https://bun.sh/"},"Bun")," and see how easy it is."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"eager",fetchpriority:"high",alt:"title image reading &quot;From ts-node to Bun&quot;",src:n(79436).Z,width:"800",height:"450"})),(0,a.kt)("h2",{id:"the-ts-node-app"},"The ts-node app"),(0,a.kt)("p",null,"I have a ",(0,a.kt)("a",{parentName:"p",href:"https://johnnyreilly.com/"},"technical blog")," which is built on Docusaurus. When the Docusaurus build completes, a post processing script runs to do things like:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"update the ",(0,a.kt)("inlineCode",{parentName:"li"},"sitemap.xml")," to include the ",(0,a.kt)("inlineCode",{parentName:"li"},"lastmod")," date based on ",(0,a.kt)("a",{parentName:"li",href:"https://johnnyreilly.com/docusaurus-createfeeditems-api-git-commit-date"},"git commit date"),", and truncate the number of entries in the file"),(0,a.kt)("li",{parentName:"ul"},"patch the html files to use Cloudinary as an image CDN for open graph images")),(0,a.kt)("p",null,"These scripts are implemented as a simple ts-node console app. For historical reasons it's called ",(0,a.kt)("inlineCode",{parentName:"p"},"trim-xml")," (it originally just truncated the ",(0,a.kt)("inlineCode",{parentName:"p"},"sitemap.xml")," file). It's not a particularly good name but I'm not going to change it now. As the blog is open source, you can see the ","[code of ",(0,a.kt)("inlineCode",{parentName:"p"},"trim-xml")," here]","(",(0,a.kt)("a",{parentName:"p",href:"https://github.com/johnnyreilly/blog.johnnyreilly.com/tree/main/trim-xml%5D"},"https://github.com/johnnyreilly/blog.johnnyreilly.com/tree/main/trim-xml]"),"."),(0,a.kt)("p",null,"What we're interested in, is porting this app from ts-node to Bun. The app has a few dependencies; so npm compatibility is important to us. Let's see how it goes."),(0,a.kt)("h2",{id:"installing-bun"},"Installing Bun"),(0,a.kt)("p",null,"I installed Bun on my Ubuntu machine using the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"curl -fsSL https://bun.sh/install | bash\n")),(0,a.kt)("p",null,"Which resulted in the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'bun was installed successfully to ~/.bun/bin/bun\n\nAdded "~/.bun/bin" to $PATH in "~/.zshrc"\n\nTo get started, run:\n\n exec /usr/bin/zsh\n  bun --help\n')),(0,a.kt)("p",null,"I was a little weirded out by the inconsistent indentation in the output but I'm sure that's just a formatting issue. (I submitted a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/oven-sh/bun/pull/2175"},"PR to fix this"),".) When I ran the suggested commands it looked like bun was happy and healthy."),(0,a.kt)("h2",{id:"porting-the-install-from-yarn-to-bun"},"Porting the install from yarn to bun"),(0,a.kt)("p",null,"With bun in place I was ready to port the app. I opened up the (as I say, badly named) ",(0,a.kt)("inlineCode",{parentName:"p"},"trim-xml")," directory and triggered installation of the dependencies using ",(0,a.kt)("inlineCode",{parentName:"p"},"bun install"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cd trim-xml\nbun install\n")),(0,a.kt)("p",null,"Output looked like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"bun install v0.5.7 (5929daee)\n + @types/node@18.14.1\n + fast-xml-parser@4.1.2\n + simple-git@3.16.1\n + typescript@4.9.5\n\n 5 packages installed [2.34s]\n")),(0,a.kt)("p",null,"As well, a new ",(0,a.kt)("inlineCode",{parentName:"p"},"bun.lockb")," file had appeared in the directory alongside the ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json"),". Although I can't find any documentation on it, I'm guessing that this is the Bun equivalent of ",(0,a.kt)("inlineCode",{parentName:"p"},"package-lock.json")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"yarn.lock"),". It's a binary file, so you can't read it. I did find this ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/JacksonKearl/bun-lockb"},"project which allows you read bun.lockb files")," which looks like a useful way to solve that problem."),(0,a.kt)("p",null,"To avoid confusion, I also deleted the ",(0,a.kt)("inlineCode",{parentName:"p"},"yarn.lock")," file. Yay - I've installed things! And pretty fast! What next?"),(0,a.kt)("h2",{id:"from-typesnode-to-buntypes"},"From ",(0,a.kt)("inlineCode",{parentName:"h2"},"@types/node")," to ",(0,a.kt)("inlineCode",{parentName:"h2"},"bun/types")),(0,a.kt)("p",null,"As I looked at the output for the install I realised that the ",(0,a.kt)("inlineCode",{parentName:"p"},"@types/node")," package had been installed. The ",(0,a.kt)("inlineCode",{parentName:"p"},"@types/node")," package is a package that contains TypeScript definitions for the Node.js runtime. Given we're moving to using Bun, it seemed likely that I didn't need these. But I likely did need something that represented the Bun runtime types. (Which incidentally, I would imagine to be pretty similar to the Node.js runtime types.)"),(0,a.kt)("p",null,"I had a quick look at the Bun documentation and found the ",(0,a.kt)("a",{parentName:"p",href:"https://oven-sh.github.io/bun-types/"},(0,a.kt)("inlineCode",{parentName:"a"},"bun/types"))," package. I added it to my project, whilst removing ",(0,a.kt)("inlineCode",{parentName:"p"},"@types/node")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"bun remove @types/node\nbun remove ts-node\nbun add bun-types\n")),(0,a.kt)("p",null,"Output looked like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"bun remove v0.5.7 (5929daee)\n - @types/node\n\n 1 packages removed [3.00ms]\nbun remove v0.5.7 (5929daee)\n - ts-node\n\n 1 packages removed [843.00ms]\nbun add v0.5.7 (5929daee)\n\n installed bun-types@0.5.7\n\n\n 1 packages installed [1.97s]\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://oven-sh.github.io/bun-types/#usage"},"docs also say"),":"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Add this to your ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"jsconfig.json"),":"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "compilerOptions": {\n    "lib": ["ESNext"],\n    "module": "esnext",\n    "target": "esnext",\n    // "bun-types" is the important part\n    "types": ["bun-types"]\n  }\n}\n'))),(0,a.kt)("p",null,"I aligned my existing ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," with the above. For my console app this meant the following changes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'  {\n    "compilerOptions": {\n-      "target": "ES2022",\n+      "target": "esnext",\n-      // "lib": [],\n+      "lib": ["ESNext"],\n-      "module": "NodeNext",\n+      "module": "esnext",\n-      // "types": [],\n+      "types": ["bun-types"],\n    },\n  }\n')),(0,a.kt)("h2",{id:"moduleresolution-with-bun"},(0,a.kt)("inlineCode",{parentName:"h2"},"moduleResolution")," with Bun"),(0,a.kt)("p",null,"I'd imagined that at this point I'd be able to run the app, but when I navigated around in VS Code I saw that I had a bunch of errors. I was getting errors like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of VS Code saying &quot;Cannot find module &#39;fast-xml-parser&#39;. Did you mean to set the &#39;moduleResolution&#39; option to &#39;node&#39;, or to add aliases to the &#39;paths&#39; option?ts(2792)&quot;",src:n(42802).Z,width:"1270",height:"230"})),(0,a.kt)("p",null,"The error message was suggesting I needed to explicitly state that I wanted to use the Node.js module resolution algorithm. Whilst we're using Bun, we're porting a Node app - so this made sense. So I made one more change to the ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," to satisy this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'  {\n    "compilerOptions": {\n-      // "moduleResolution": "node",\n+      "moduleResolution": "Bundler",\n    },\n  }\n')),(0,a.kt)("p",null,"With that in place, the module resolution errors were... resolved. (Sorry.)"),(0,a.kt)("h2",{id:"file-apis-with-bun"},"File APIs with Bun"),(0,a.kt)("p",null,"However, I was still getting errors. This time they were about the ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/fs.html#promises-api"},(0,a.kt)("inlineCode",{parentName:"a"},"fs.promises")," API"),". I was getting errors like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"screenshot of errors in VS Code reporting the absence of the fs.promises API",src:n(68779).Z,width:"761",height:"165"})),(0,a.kt)("p",null,"It looked like the version of bun I was using didn't support that API. As I dug through my code I realised that I was using the ",(0,a.kt)("inlineCode",{parentName:"p"},"fs.promises")," API in a few places. I was using it in the following ways:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"await fs.promises.readdir")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"await fs.promises.readFile")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"await fs.promises.writeFile"))),(0,a.kt)("p",null,"For ",(0,a.kt)("inlineCode",{parentName:"p"},"fs.promises.readFile")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"fs.promises.writeFile")," I was able to replace them with the Bun equivalents ",(0,a.kt)("a",{parentName:"p",href:"https://bun.sh/docs/api/file-io#reading-files"},(0,a.kt)("inlineCode",{parentName:"a"},"Bun.file(path).text()"))," and ",(0,a.kt)("a",{parentName:"p",href:"https://bun.sh/docs/api/file-io#writing-files"},(0,a.kt)("inlineCode",{parentName:"a"},"Bun.write(path, content)"))," respectively:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"- `await fs.promises.readFile`\n+ `await Bun.file(path).text()`\n- `await fs.promises.writeFile(path, content)`\n+ `await Bun.write(path, content)`\n")),(0,a.kt)("p",null,"There appeared to be no Bun equivalent for ",(0,a.kt)("inlineCode",{parentName:"p"},"fs.promises.readdir"),", so I used the ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/fs.html#fsreaddirsyncpath-options"},"sync Node.js API"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"- `await fs.promises.readdir`\n+ `fs.readdirSync(path)`\n")),(0,a.kt)("p",null,"We now had code without any errors. (At least in VS Code as far as TypeScript was concerned. I had yet to run the app to see if it worked.)"),(0,a.kt)("h3",{id:"clarification-on-fspromises"},"Clarification on ",(0,a.kt)("inlineCode",{parentName:"h3"},"fs.promises")),(0,a.kt)("p",null,"I was tweeting about my findings as I wrote this, and ",(0,a.kt)("a",{parentName:"p",href:"https://twitter.com/jarredsumner/status/1629818921904902145"},"Jarred Sumner (who works on Bun) was kind enough to share")," that the ",(0,a.kt)("inlineCode",{parentName:"p"},"fs.promises")," API is implemented but the types aren't as yet."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"Screenshot of exchange on Twitter with Jarred responding &quot;it sort of exists, but looks like the types are out of date. I say sort of because, actually everything async is sync for node:fs and it just wraps in a Promise. If you use fs createReadStream / fs.createWriteStream or Bun.file(path).stream() it\u2019ll be concurrent / async&quot;",src:n(27476).Z,width:"558",height:"833"})),(0,a.kt)("h2",{id:"running-the-app"},"Running the app"),(0,a.kt)("p",null,"I now needed to do one more thing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'-    "start": "ts-node index.ts"\n+    "start": "bun index.ts"\n')),(0,a.kt)("p",null,"That's right; update the ",(0,a.kt)("inlineCode",{parentName:"p"},"start")," script in ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," to use ",(0,a.kt)("inlineCode",{parentName:"p"},"bun")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node"),". And now I was able to run the app with ",(0,a.kt)("inlineCode",{parentName:"p"},"bun start"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"Loading /home/john/code/github/blog.johnnyreilly.com/blog-website/build/sitemap.xml\nReducing 526 urls to 512 urls\n")),(0,a.kt)("p",null,"The first positive thing about what I saw, was that we appeared to have running code. Yay! The program also appeared to be executing instantaneously, which seemed surprising. I was expecting Bun to be faster, but this seemed too fast."),(0,a.kt)("p",null,"Also, we seemed to be lacking many of the log messages I'd expect. I was expecting to see about 1000 log messages. Something wasn't right."),(0,a.kt)("h2",{id:"top-level-await-and-bun"},"Top level ",(0,a.kt)("inlineCode",{parentName:"h2"},"await")," and Bun"),(0,a.kt)("p",null,"The issue was that my ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," function was asynchronous. However, because support for top level ",(0,a.kt)("inlineCode",{parentName:"p"},"await")," wasn't available in Node.js when I originally wrote the code, I'd called the ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," function synchronously. Fortunately Node didn't complain about that, and the program behaved in the way required."),(0,a.kt)("p",null,"However Bun looked like it was respecting the fact that ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," was asynchronous. That's why it was apparently executing so quickly; it wasn't waiting for the ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," method to complete before terminating."),(0,a.kt)("p",null,"To be honest, Bun's behaviour here is just right; the code as is didn't suggest that it was interested in waiting for the ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," function to complete. But it turns out that waiting is exactly the desired behaviour. To bring things right, we could use top level ",(0,a.kt)("inlineCode",{parentName:"p"},"await"),". So I made the following change to my ",(0,a.kt)("inlineCode",{parentName:"p"},"index.ts")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"- main();\n+ await main();\n")),(0,a.kt)("p",null,"And now I was getting the expected log messages; and the program appeared to be working as expected."),(0,a.kt)("h2",{id:"github-actions-and-bun"},"GitHub Actions and Bun"),(0,a.kt)("p",null,"I was now able to run the app locally. But I wanted to run it in GitHub Actions. I just needed to add the ",(0,a.kt)("inlineCode",{parentName:"p"},"setup-bun")," action to my workflow, so bun was available in the GitHub Actions environment:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- name: Setup bun \ud83d\udd27\n  uses: oven-sh/setup-bun@v1\n  with:\n    bun-version: latest\n")),(0,a.kt)("h2",{id:"performance-comparison-bun-vs-ts-node"},"Performance comparison; Bun vs ts-node"),(0,a.kt)("p",null,"I was expecting Bun to be faster than ts-node. Let's take a run of our app in GitHub Actions with ts-node and compare it to a run of our app with Bun:"),(0,a.kt)("h3",{id:"ts-node"},"ts-node"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"Post processing finished in 17.09 seconds\nDone in 19.52s.\n")),(0,a.kt)("h3",{id:"bun"},"Bun"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"Post processing finished in 12.367 seconds\nDone in 12.72s.\n")),(0,a.kt)("p",null,"I haven't done any formal benchmarking, but it looks like Bun is about 50% faster than ts-node for this usecase. That's pretty good. It's also worth expanding on how this breaks down."),(0,a.kt)("p",null,"You'll notice in the logs above there's two log entries:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'The "Post processing" reflects the time taken to run the ',(0,a.kt)("inlineCode",{parentName:"li"},"main")," function."),(0,a.kt)("li",{parentName:"ol"},'The "Done" reflects the time taken to run the ',(0,a.kt)("inlineCode",{parentName:"li"},"bun")," command end to end.")),(0,a.kt)("p",null,"What can we learn from this? First of all, running code in ts-node takes 17 seconds, compared to 12 seconds with Bun. ",(0,a.kt)("strong",{parentName:"p"},"So Bun is performing about 40% faster at running code.")),(0,a.kt)("p",null,"The end to end is 19 seconds with ts-node, compared to 14 seconds with Bun. ",(0,a.kt)("strong",{parentName:"p"},"So Bun is performing about 50% faster end to end.")," There's two parts to this; the time taken to compile the code and the time taken to start up. We're doing type checking with ts-node; which if deactivated would make a difference."),(0,a.kt)("p",null,"However, when you look at the difference between the end to end runtime and code runtime with Bun, it's a mere 0.353 seconds. ts-node clocks in at 2.43 seconds for the same. So ts-node is about 6.5 times slower at starting up. That's a pretty big difference; it's unlikely that all of this is TypeScript compilation; Node.js is fundamentally slower at getting going than Bun is."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"Moving from ts-node to Bun was a pretty easy process. I was able to do it in a few hours. I was able to run the app locally and in GitHub Actions. And I was able to run the app in less time."),(0,a.kt)("p",null,"This all makes me feel very positive about Bun. I'm looking forward to using it more in the future."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/migrating-typescript-app-node-js-bun/"},"This post was originally published on LogRocket.")),(0,a.kt)("head",null,(0,a.kt)("link",{rel:"canonical",href:"https://blog.logrocket.com/migrating-typescript-app-node-js-bun/"})))}h.isMDXComponent=!0},42802:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/screenshot-cannot-find-module-2c4a1e2ec791d0084998c18f3930a9bc.png"},68779:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/screenshot-file-apis-bff7e0019757fd8bacbd8d36107b013a.png"},27476:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/screenshot-tweet-fs-promises-exists-84f95682cf54e900231b5c959d974a95.png"},79436:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/title-image-59128fb2fcf34321698642211daaad26.png"}}]);