"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["33276"],{3013:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return a},default:function(){return d},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l}});var s=n(77610),r=n(85893),o=n(50065);let i={slug:"typescript-instance-methods",title:"TypeScript this is what I want! (the unfortunate neglect of Instance Methods / callback functions)",authors:"johnnyreilly",tags:["typescript"],hide_table_of_contents:!1,description:'TypeScripts "Instance Methods" feature solves the `this` keyword issues in classes, unlike prototype methods. It suggests using a combination of the two.'},a=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Instance Methods to the Rescue!",id:"instance-methods-to-the-rescue",level:2},{value:"<code>Greeter</code> with Instance Methods",id:"greeter-with-instance-methods",level:2},{value:"Updated 02/04/2014 - mixing and matching <code>prototype</code> and Instance Methods",id:"updated-02042014---mixing-and-matching-prototype-and-instance-methods",level:2}];function h(e){let t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["I was recently reading ",(0,r.jsx)(t.a,{href:"http://www.walkercoderanger.com/blog/2014/02/typescript-isnt-the-answer/",children:"Jeff Walker's blog post \"Why TypeScript Isn't the Answer\""}),". This is part of series in which Jeff goes through various compile-to-JavaScript technologies including TypeScript, CoffeeScript and Dart and explains his view of why he feels they don't quite hit the mark."]}),"\n",(0,r.jsx)(t.p,{children:"As a user (and big fan) of TypeScript I read the post with interest and picked up on one particular issue that Jeff mentions:"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["Classes make the unchanged behaviour of the ",(0,r.jsx)(t.code,{children:"this"})," keyword more confusing. For example, in a class like ",(0,r.jsx)(t.code,{children:"Greeter"})," from the ",(0,r.jsx)(t.a,{href:"http://www.typescriptlang.org/Playground",children:"TypeScript playground"}),", the use of ",(0,r.jsx)(t.code,{children:"this"})," is confusing:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    return 'Hello, ' + this.greeting;\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["One can\u2019t help but feel the ",(0,r.jsx)(t.code,{children:"this"})," keyword in the methods of ",(0,r.jsx)(t.code,{children:"Greeter"})," should always reference a ",(0,r.jsx)(t.code,{children:"Greeter"})," instance. However, the semantics of this are unchanged from JavaScript:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"var greeter = new Greeter('world');\nvar unbound = greeter.greet;\nalert(unbound());\n"})}),"\n",(0,r.jsx)(t.p,{children:"The above code displays \u201CHello, undefined\u201D instead of the naively expected \u201CHello, world\u201D."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Now Jeff is quite correct in everything he says above. However, he's also missing a trick. Or rather, he's missing out on a very useful feature of TypeScript."}),"\n",(0,r.jsx)(t.h2,{id:"instance-methods-to-the-rescue",children:"Instance Methods to the Rescue!"}),"\n",(0,r.jsxs)(t.p,{children:["Still in the early days of TypeScript, the issue Jeff raises had already been identified. (And for what it's worth, this issue wasn't there by mistake - remember TypeScript is quite deliberately a \"superset of JavaScript\".) Happily with the ",(0,r.jsx)(t.a,{href:"https://blogs.msdn.com/b/typescript/archive/2013/08/06/announcing-0-9-1.aspx",children:"release of TypeScript 0.9.1"}),' a nice remedy was included in the language in the form of "Instance Methods".']}),"\n",(0,r.jsxs)(t.p,{children:["Instance Methods are lexically scoped; bound to a specific instance of a JavaScript object. i.e. These methods are *",(0,r.jsx)(t.strong,{children:"not"}),"* vulnerable to the \u201CHello, undefined\u201D issue Jeff raises. To quote the blog post:"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["We've relaxed the restrictions on field initializers to now allow ",(0,r.jsx)(t.code,{children:"'this'"}),". This means that classes can now contain both methods on the prototype, and ",(0,r.jsx)(t.strong,{children:"callback functions on the instance"}),". The latter are particularly useful when you want to use a member on the class as a callback function, as in the code above. This lets you mix-n-match between \u2018closure\u2019 style and \u2018prototype\u2019 style class member patterns easily."]}),"\n"]}),"\n",(0,r.jsxs)(t.h2,{id:"greeter-with-instance-methods",children:[(0,r.jsx)(t.code,{children:"Greeter"})," with Instance Methods"]}),"\n",(0,r.jsxs)(t.p,{children:["So, if we take the ",(0,r.jsx)(t.code,{children:"Greeter"})," example, how do we apply Instance Methods to it? Well, like this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet = () => {\n    return 'Hello, ' + this.greeting;\n  };\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Can you tell the difference? It's subtle. That's right; the mere swapping out of ",(0,r.jsx)(t.code,{children:"()"})," with ",(0,r.jsx)(t.code,{children:"= () =&gt;"})," on the ",(0,r.jsx)(t.code,{children:"greet"})," method takes us from a ",(0,r.jsx)(t.code,{children:"prototype"})," method to an Instance Method."]}),"\n",(0,r.jsxs)(t.p,{children:["Observant readers will have noticed that we are using TypeScript / ",(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/arrow_functions",children:"ES6's Arrow Function syntax"}),". In fact with that in mind I could actually have gone super-terse if I was so inclined:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet = () => 'Hello, ' + this.greeting;\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"But either way, both of the above class declarations compile down to the following JavaScript:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"var Greeter = (function () {\n  function Greeter(message) {\n    var _this = this;\n    this.greet = function () {\n      return 'Hello, ' + _this.greeting;\n    };\n    this.greeting = message;\n  }\n  return Greeter;\n})();\n"})}),"\n",(0,r.jsx)(t.p,{children:"Which differs from the pre-Instance Methods generated JavaScript:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"var Greeter = (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  return Greeter;\n})();\n"})}),"\n",(0,r.jsxs)(t.p,{children:["As you can see the Instance Methods approach does *",(0,r.jsx)(t.strong,{children:"not"}),"* make use of the ",(0,r.jsx)(t.code,{children:"prototype"})," on ",(0,r.jsx)(t.code,{children:"Greeter"})," to add the method. (As the pre-Instance Methods ",(0,r.jsx)(t.code,{children:"greet()"})," declaration did.) Instead it creates a function directly on the created object and internally uses the ",(0,r.jsx)(t.code,{children:"_this"})," variable inside the Instance Methods. (",(0,r.jsx)(t.code,{children:"_this"})," being a previously captured instance of ",(0,r.jsx)(t.code,{children:"this"}),".)"]}),"\n",(0,r.jsx)(t.p,{children:"So with Instance Methods we can repeat Jeff's experiment from earlier:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"var greeter = new Greeter('world');\nvar bound = greeter.greet;\nalert(bound());\n"})}),"\n",(0,r.jsx)(t.p,{children:"But this time round the code displays \u201CHello, world\u201D and no longer \u201CHello, undefined\u201D."}),"\n",(0,r.jsxs)(t.h2,{id:"updated-02042014---mixing-and-matching-prototype-and-instance-methods",children:["Updated 02/04/2014 - mixing and matching ",(0,r.jsx)(t.code,{children:"prototype"})," and Instance Methods"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://twitter.com/bgever",children:"Bart Verkoeijen"})," made an excellent comment concerning the extra memory that Instance Methods require as opposed to ",(0,r.jsx)(t.code,{children:"prototype"})," methods. Not everyone reads the comments and so I thought I'd add a little suffix to my post."]}),"\n",(0,r.jsxs)(t.p,{children:["What I\u2019ve come to realise is that it comes down to problem that you\u2019re trying to solve. Instance methods are bulletproof in terms of relying on a specific instance of ",(0,r.jsx)(t.code,{children:"this"})," regardless of how a method is invoked. But for many of my use cases that\u2019s overkill. Let\u2019s take the original (",(0,r.jsx)(t.code,{children:"prototype"})," methods) ",(0,r.jsx)(t.code,{children:"Greeter"})," example:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"var Greeter = (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  return Greeter;\n})();\n\nvar greeter = new Greeter('world');\nvar greeter2 = new Greeter('universe');\n\nconsole.log(greeter.greet()); // Logs \"Hello, world\"\nconsole.log(greeter2.greet()); // Logs \"Hello, universe\"\n"})}),"\n",(0,r.jsxs)(t.p,{children:["As you can see above, provided I invoke my ",(0,r.jsx)(t.code,{children:"greet"})," method in the context of my created object then I can rely on ",(0,r.jsx)(t.code,{children:"this"})," being what I would hope."]}),"\n",(0,r.jsxs)(t.p,{children:["That being the case my general practice has not been to use exclusively Instance methods *",(0,r.jsx)(t.strong,{children:"or"}),"* ",(0,r.jsx)(t.code,{children:"prototype"})," methods. What I tend to do is start out only with ",(0,r.jsx)(t.code,{children:"prototype"})," methods on my classes and switch them over to be an Instance method if there is an actual need to ensure context. So my TypeScript classes tend to be a combination of ",(0,r.jsx)(t.code,{children:"prototype"})," methods and Instance methods."]}),"\n",(0,r.jsxs)(t.p,{children:["More often than not the ",(0,r.jsx)(t.code,{children:"prototype"})," methods are just fine. It tends to be where an object is interacting with some kind of presentation framework (Knockout / Angular etc) or being invoked as part of a callback (eg AJAX scenarios) where I need Instance methods."]})]})}function d(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},50065:function(e,t,n){n.d(t,{Z:function(){return a},a:function(){return i}});var s=n(67294);let r={},o=s.createContext(r);function i(e){let t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}},77610:function(e){e.exports=JSON.parse('{"permalink":"/typescript-instance-methods","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2014-04-01-typescript-instance-methods/index.md","source":"@site/blog/2014-04-01-typescript-instance-methods/index.md","title":"TypeScript this is what I want! (the unfortunate neglect of Instance Methods / callback functions)","description":"TypeScripts \\"Instance Methods\\" feature solves the `this` keyword issues in classes, unlike prototype methods. It suggests using a combination of the two.","date":"2014-04-01T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."}],"readingTime":4.97,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"typescript-instance-methods","title":"TypeScript this is what I want! (the unfortunate neglect of Instance Methods / callback functions)","authors":"johnnyreilly","tags":["typescript"],"hide_table_of_contents":false,"description":"TypeScripts \\"Instance Methods\\" feature solves the `this` keyword issues in classes, unlike prototype methods. It suggests using a combination of the two."},"unlisted":false,"prevItem":{"title":"TypeScript, JSDoc and Intellisense","permalink":"/typescript-jsdoc-and-intellisense"},"nextItem":{"title":"The Surprisingly Happy Tale of Visual Studio Online, Continous Integration and Chutzpah","permalink":"/the-surprisingly-happy-tale-of-visual"}}')}}]);