"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[48560],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=s(n),d=r,h=g["".concat(p,".").concat(d)]||g[d]||u[d]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[g]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},27106:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>g});n(67294);var a=n(3905);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const l={slug:"generate-typescript-and-csharp-clients-with-nswag",title:"NSwag: TypeScript and CSharp client generation based on an API",authors:"johnnyreilly",tags:["NSwag","Swagger","open-api","typescript","C#"],image:"./use-generated-client.gif",hide_table_of_contents:!1,description:"NSwag simplifies APIs by auto-generating OpenAPI specs and clients. Learn to create TypeScript clients from NSwag using a .NET console app."},p=void 0,s={permalink:"/generate-typescript-and-csharp-clients-with-nswag",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2021-03-06-generate-typescript-and-csharp-clients-with-nswag/index.md",source:"@site/blog/2021-03-06-generate-typescript-and-csharp-clients-with-nswag/index.md",title:"NSwag: TypeScript and CSharp client generation based on an API",description:"NSwag simplifies APIs by auto-generating OpenAPI specs and clients. Learn to create TypeScript clients from NSwag using a .NET console app.",date:"2021-03-06T00:00:00.000Z",formattedDate:"March 6, 2021",tags:[{label:"NSwag",permalink:"/tags/n-swag"},{label:"Swagger",permalink:"/tags/swagger"},{label:"open-api",permalink:"/tags/open-api"},{label:"typescript",permalink:"/tags/typescript"},{label:"C#",permalink:"/tags/c"}],readingTime:8.54,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"generate-typescript-and-csharp-clients-with-nswag",title:"NSwag: TypeScript and CSharp client generation based on an API",authors:"johnnyreilly",tags:["NSwag","Swagger","open-api","typescript","C#"],image:"./use-generated-client.gif",hide_table_of_contents:!1,description:"NSwag simplifies APIs by auto-generating OpenAPI specs and clients. Learn to create TypeScript clients from NSwag using a .NET console app."},prevItem:{title:"Managed Identity, Azure SQL and Entity Framework",permalink:"/managed-identity-azure-sql-entity-framework"},nextItem:{title:"Goodbye Client Affinity, Hello Data Protection with Azure",permalink:"/goodbye-client-affinity-hello-data-protection-with-azure"}},c={image:n(47350).Z,authorsImageUrls:[void 0]},g=[{value:"Create an API",id:"create-an-api",level:2},{value:"The client generator project",id:"the-client-generator-project",level:2},{value:"Building a &quot;make a client&quot; script",id:"building-a-make-a-client-script",level:2},{value:"Consume our generated API client",id:"consume-our-generated-api-client",level:2}],u={toc:g};function d(e){var{components:t}=e,l=o(e,["components"]);return(0,a.kt)("wrapper",i(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){r(e,t,n[t])}))}return e}({},u,l),{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Generating clients for APIs is a tremendous way to reduce the amount of work you have to do when you're building a project. Why handwrite that code when it can be auto-generated for you quickly and accurately by a tool like ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/RicoSuter/NSwag"},"NSwag"),"? To quote the docs:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The NSwag project provides tools to generate OpenAPI specifications from existing ASP.NET Web API controllers and client code from these OpenAPI specifications. The project combines the functionality of Swashbuckle (OpenAPI/Swagger generation) and AutoRest (client generation) in one toolchain.")),(0,a.kt)("p",null,"There's some great posts out there that show you how to generate the clients with NSwag using an ",(0,a.kt)("inlineCode",{parentName:"p"},"nswag.json")," file directly from a .NET project."),(0,a.kt)("p",null,"However, what if you want to use NSwag purely for its client generation capabilities? You may have an API written with another language / platform that exposes a Swagger endpoint, that you simply wish to create a client for. How do you do that? Also, if you want to do some special customisation of the clients you're generating, you may find yourself struggling to configure that in ",(0,a.kt)("inlineCode",{parentName:"p"},"nswag.json"),". In that case, it's possible to hook into NSwag directly to do this with a simple .NET console app."),(0,a.kt)("p",null,"This post will:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Create a .NET API which exposes a Swagger endpoint. (Alternatively, you could use any other Swagger endpoint; ",(0,a.kt)("a",{parentName:"li",href:"https://blog.logrocket.com/documenting-your-express-api-with-swagger/"},"for example an Express API"),".)"),(0,a.kt)("li",{parentName:"ul"},"Create a .NET console app which can create both TypeScript and CSharp clients from a Swagger endpoint."),(0,a.kt)("li",{parentName:"ul"},"Create a script which, when run, creates a TypeScript client."),(0,a.kt)("li",{parentName:"ul"},"Consume the API using the generated client in a simple TypeScript application.")),(0,a.kt)("p",null,"You will need both ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/en/"},"Node.js")," and the ",(0,a.kt)("a",{parentName:"p",href:"https://dotnet.microsoft.com/download"},".NET SDK")," installed."),(0,a.kt)("h2",{id:"create-an-api"},"Create an API"),(0,a.kt)("p",null,"We'll now create an API which exposes a ",(0,a.kt)("a",{parentName:"p",href:"https://swagger.io/resources/open-api/"},"Swagger / Open API")," endpoint. Whilst we're doing that we'll create a TypeScript React app which we'll use later on. We'll drop to the command line and enter the following commands which use the .NET SDK, node and the ",(0,a.kt)("inlineCode",{parentName:"p"},"create-react-app")," package:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"mkdir src\ncd src\nnpx create-react-app client-app --template typescript\nmkdir server-app\ncd server-app\ndotnet new api -o API\ncd API\ndotnet add package NSwag.AspNetCore\n")),(0,a.kt)("p",null,"We now have a .NET API with a dependency on NSwag. We'll start to use it by replacing the ",(0,a.kt)("inlineCode",{parentName:"p"},"Startup.cs")," that's been generated with the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace API\n{\n    public class Startup\n    {\n        const string ALLOW_DEVELOPMENT_CORS_ORIGINS_POLICY = "AllowDevelopmentSpecificOrigins";\n        const string LOCAL_DEVELOPMENT_URL = "http://localhost:3000";\n\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n\n            services.AddControllers();\n\n            services.AddCors(options => {\n                options.AddPolicy(name: ALLOW_DEVELOPMENT_CORS_ORIGINS_POLICY,\n                    builder => {\n                        builder.WithOrigins(LOCAL_DEVELOPMENT_URL)\n                            .AllowAnyMethod()\n                            .AllowAnyHeader()\n                            .AllowCredentials();\n                    });\n            });\n\n            // Register the Swagger services\n            services.AddSwaggerDocument();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure (IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n            else\n            {\n                app.UseExceptionHandler("/Error");\n                app.UseHsts ();\n                app.UseHttpsRedirection();\n            }\n\n            app.UseDefaultFiles();\n            app.UseStaticFiles();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            // Register the Swagger generator and the Swagger UI middlewares\n            app.UseOpenApi();\n            app.UseSwaggerUi3();\n\n            if (env.IsDevelopment())\n                app.UseCors(ALLOW_DEVELOPMENT_CORS_ORIGINS_POLICY);\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n')),(0,a.kt)("p",null,"The significant changes in the above ",(0,a.kt)("inlineCode",{parentName:"p"},"Startup.cs")," are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Exposing a Swagger endpoint with ",(0,a.kt)("inlineCode",{parentName:"li"},"UseOpenApi")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"UseSwaggerUi3"),". NSwag will automagically create Swagger endpoints in your application for all your controllers. The .NET template ships with a ",(0,a.kt)("inlineCode",{parentName:"li"},"WeatherForecastController"),"."),(0,a.kt)("li",{parentName:"ol"},"Allowing ",(0,a.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/aspnet/core/security/cors"},"Cross-Origin Requests (CORS)")," which is useful during development (and will facilitate a demo later).")),(0,a.kt)("p",null,"Back in the root of our project we're going to initialise an npm project. We're going to use this to put in place a number of handy ",(0,a.kt)("a",{parentName:"p",href:"https://docs.npmjs.com/cli/v6/using-npm/scripts"},(0,a.kt)("inlineCode",{parentName:"a"},"npm scripts"))," that will make our project easier to work with. So we'll ",(0,a.kt)("inlineCode",{parentName:"p"},"npm init")," and accept all the defaults."),(0,a.kt)("p",null,"Now we're going add some dependencies which our scripts will use: ",(0,a.kt)("inlineCode",{parentName:"p"},"npm install cpx cross-env npm-run-all start-server-and-test")),(0,a.kt)("p",null,"We'll also add ourselves some ",(0,a.kt)("inlineCode",{parentName:"p"},"scripts")," to our ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"scripts": {\n    "postinstall": "npm run install:client-app && npm run install:server-app",\n    "install:client-app": "cd src/client-app && npm install",\n    "install:server-app": "cd src/server-app/API && dotnet restore",\n    "build": "npm run build:client-app && npm run build:server-app",\n    "build:client-app": "cd src/client-app && npm run build",\n    "postbuild:client-app": "cpx \\"src/client-app/build/**/*.*\\" \\"src/server-app/API/wwwroot/\\"",\n    "build:server-app": "cd src/server-app/API && dotnet build --configuration release",\n    "start": "run-p start:client-app start:server-app",\n    "start:client-app": "cd src/client-app && npm start",\n    "start:server-app": "cross-env ASPNETCORE_URLS=http://*:5000 ASPNETCORE_ENVIRONMENT=Development dotnet watch --project src/server-app/API run --no-launch-profile"\n  }\n')),(0,a.kt)("p",null,"Let's walk through what the above scripts provide us with:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Running ",(0,a.kt)("inlineCode",{parentName:"li"},"npm install")," in the root of our project will not only install dependencies for our root ",(0,a.kt)("inlineCode",{parentName:"li"},"package.json"),", thanks to our ",(0,a.kt)("inlineCode",{parentName:"li"},"postinstall"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"install:client-app")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"install:server-app")," scripts it will install the React app and .NET app dependencies as well."),(0,a.kt)("li",{parentName:"ul"},"Running ",(0,a.kt)("inlineCode",{parentName:"li"},"npm run build")," will build our client and server apps."),(0,a.kt)("li",{parentName:"ul"},"Running ",(0,a.kt)("inlineCode",{parentName:"li"},"npm run start")," will start both our React app and our .NET app. Our React app will be started at ",(0,a.kt)("a",{parentName:"li",href:"http://localhost:3000"},"http://localhost:3000"),". Our .NET app will be started at ",(0,a.kt)("a",{parentName:"li",href:"http://localhost:5000"},"http://localhost:5000")," (some environment variables are passed to it with ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/kentcdodds/cross-env"},(0,a.kt)("inlineCode",{parentName:"a"},"cross-env"))," ).")),(0,a.kt)("p",null,"Once ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run start")," has been run, you will find a Swagger endpoint at ",(0,a.kt)("a",{parentName:"p",href:"http://localhost:5000/swagger"},"http://localhost:5000/swagger"),":"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"eager",fetchpriority:"high",alt:"swagger screenshot",src:n(73812).Z,width:"600",height:"362"})),(0,a.kt)("h2",{id:"the-client-generator-project"},"The client generator project"),(0,a.kt)("p",null,"Now we've scaffolded our Swagger-ed API, we want to put together the console app that will generate our typed clients."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cd src/server-app\ndotnet new console -o APIClientGenerator\ncd APIClientGenerator\ndotnet add package NSwag.CodeGeneration.CSharp\ndotnet add package NSwag.CodeGeneration.TypeScript\ndotnet add package NSwag.Core\n")),(0,a.kt)("p",null,"We now have a console app with dependencies on the code generation portions of NSwag. Now let's change up ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," to make use of this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing NJsonSchema;\nusing NJsonSchema.CodeGeneration.TypeScript;\nusing NJsonSchema.Visitors;\nusing NSwag;\nusing NSwag.CodeGeneration.CSharp;\nusing NSwag.CodeGeneration.TypeScript;\n\nnamespace APIClientGenerator\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            if (args.Length != 3)\n                throw new ArgumentException("Expecting 3 arguments: URL, generatePath, language");\n\n            var url = args[0];\n            var generatePath = Path.Combine(Directory.GetCurrentDirectory(), args[1]);\n            var language = args[2];\n\n            if (language != "TypeScript" && language != "CSharp")\n                throw new ArgumentException("Invalid language parameter; valid values are TypeScript and CSharp");\n\n            if (language == "TypeScript")\n                await GenerateTypeScriptClient(url, generatePath);\n            else\n                await GenerateCSharpClient(url, generatePath);\n        }\n\n        async static Task GenerateTypeScriptClient(string url, string generatePath) =>\n            await GenerateClient(\n                document: await OpenApiDocument.FromUrlAsync(url),\n                generatePath: generatePath,\n                generateCode: (OpenApiDocument document) =>\n                {\n                    var settings = new TypeScriptClientGeneratorSettings();\n\n                    settings.TypeScriptGeneratorSettings.TypeStyle = TypeScriptTypeStyle.Interface;\n                    settings.TypeScriptGeneratorSettings.TypeScriptVersion = 3.5M;\n                    settings.TypeScriptGeneratorSettings.DateTimeType = TypeScriptDateTimeType.String;\n\n                    var generator = new TypeScriptClientGenerator(document, settings);\n                    var code = generator.GenerateFile();\n\n                    return code;\n                }\n            );\n\n        async static Task GenerateCSharpClient(string url, string generatePath) =>\n            await GenerateClient(\n                document: await OpenApiDocument.FromUrlAsync(url),\n                generatePath: generatePath,\n                generateCode: (OpenApiDocument document) =>\n                {\n                    var settings = new CSharpClientGeneratorSettings\n                    {\n                        UseBaseUrl = false\n                    };\n\n                    var generator = new CSharpClientGenerator(document, settings);\n                    var code = generator.GenerateFile();\n                    return code;\n                }\n            );\n\n        private async static Task GenerateClient(OpenApiDocument document, string generatePath, Func<OpenApiDocument, string> generateCode)\n        {\n            Console.WriteLine($"Generating {generatePath}...");\n\n            var code = generateCode(document);\n\n            await System.IO.File.WriteAllTextAsync(generatePath, code);\n        }\n    }\n}\n')),(0,a.kt)("p",null,"We've created ourselves a simple .NET console application that creates TypeScript and CSharp clients for a given Swagger URL. It expects three arguments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"url")," ","-"," the url of the ",(0,a.kt)("inlineCode",{parentName:"li"},"swagger.json")," file to generate a client for."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"generatePath")," ","-"," the path where the generated client file should be placed, relative to this project."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"language")," ","-",' the language of the client to generate; valid values are "TypeScript" and "CSharp".')),(0,a.kt)("p",null,"To create a TypeScript client with it then we'd use the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet run --project src/server-app/APIClientGenerator http://localhost:5000/swagger/v1/swagger.json src/client-app/src/clients.ts TypeScript\n")),(0,a.kt)("p",null,"However, for this to run successfully, we'll first have to ensure the API is running. It would be great if we had a single command we could run that would:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"bring up the API"),(0,a.kt)("li",{parentName:"ul"},"generate a client"),(0,a.kt)("li",{parentName:"ul"},"bring down the API")),(0,a.kt)("p",null,"Let's make that."),(0,a.kt)("h2",{id:"building-a-make-a-client-script"},'Building a "make a client" script'),(0,a.kt)("p",null,"In the root of the project we're going to add the following ",(0,a.kt)("inlineCode",{parentName:"p"},"scripts"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"generate-client:server-app": "start-server-and-test generate-client:server-app:serve http-get://localhost:5000/swagger/v1/swagger.json generate-client:server-app:generate",\n"generate-client:server-app:serve": "cross-env ASPNETCORE_URLS=http://*:5000 ASPNETCORE_ENVIRONMENT=Development dotnet run --project src/server-app/API --no-launch-profile",\n"generate-client:server-app:generate": "dotnet run --project src/server-app/APIClientGenerator http://localhost:5000/swagger/v1/swagger.json src/client-app/src/clients.ts TypeScript",\n')),(0,a.kt)("p",null,"Let's walk through what's happening here. Running ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run generate-client:server-app")," will:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use the ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/bahmutov/start-server-and-test"},(0,a.kt)("inlineCode",{parentName:"a"},"start-server-and-test"))," package to spin up our server-app by running the ",(0,a.kt)("inlineCode",{parentName:"li"},"generate-client:server-app:serve")," script."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"start-server-and-test")," waits for the Swagger endpoint to start responding to requests. When it does start responding, ",(0,a.kt)("inlineCode",{parentName:"li"},"start-server-and-test")," runs the ",(0,a.kt)("inlineCode",{parentName:"li"},"generate-client:server-app:generate"),' script which runs our APIClientGenerator console app and provides it with the URL where our swagger can be found, the path of the file to generate and the language of "TypeScript"')),(0,a.kt)("p",null,"If you were wanting to generate a C# client (say if you were writing a ",(0,a.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/js-free-frontends-blazor/"},"Blazor")," app) then you could change the ",(0,a.kt)("inlineCode",{parentName:"p"},"generate-client:server-app:generate")," script as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"generate-client:server-app:generate": "dotnet run --project src/server-app/ApiClientGenerator http://localhost:5000/swagger/v1/swagger.json clients.cs CSharp",\n')),(0,a.kt)("h2",{id:"consume-our-generated-api-client"},"Consume our generated API client"),(0,a.kt)("p",null,"Let's run the ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run generate-client:server-app")," command. It creates a ",(0,a.kt)("inlineCode",{parentName:"p"},"clients.ts")," file which nestles nicely inside our ",(0,a.kt)("inlineCode",{parentName:"p"},"client-app"),". We're going to exercise that in a moment. First of all, let's enable proxying from our ",(0,a.kt)("inlineCode",{parentName:"p"},"client-app")," to our ",(0,a.kt)("inlineCode",{parentName:"p"},"server-app")," following the instructions in the ",(0,a.kt)("a",{parentName:"p",href:"https://create-react-app.dev/docs/proxying-api-requests-in-development/"},"Create React App docs")," and adding the following to our ",(0,a.kt)("inlineCode",{parentName:"p"},"client-app/package.json"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"proxy": "http://localhost:5000"\n')),(0,a.kt)("p",null,"Now let's start our apps with ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run start"),". We'll then replace the contents of ",(0,a.kt)("inlineCode",{parentName:"p"},"App.tsx")," with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import React from "react";\nimport "./App.css";\nimport { WeatherForecast, WeatherForecastClient } from "./clients";\n\nfunction App() {\n  const [weather, setWeather] = React.useState<WeatherForecast[] | null>();\n  React.useEffect(() => {\n    async function loadWeather() {\n      const weatherClient = new WeatherForecastClient(/* baseUrl */ "");\n      const forecast = await weatherClient.get();\n      setWeather(forecast);\n    }\n    loadWeather();\n  }, [setWeather]);\n\n  return (\n    <div className="App">\n      <header className="App-header">\n        {weather ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Date</th>\n                <th>Summary</th>\n                <th>Centigrade</th>\n                <th>Fahrenheit</th>\n              </tr>\n            </thead>\n            <tbody>\n              {weather.map(({ date, summary, temperatureC, temperatureF }) => (\n                <tr key={date}>\n                  <td>{new Date(date).toLocaleDateString()}</td>\n                  <td>{summary}</td>\n                  <td>{temperatureC}</td>\n                  <td>{temperatureF}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        ) : (\n          <p>Loading weather...</p>\n        )}\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n')),(0,a.kt)("p",null,"Inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"React.useEffect")," above you can see we create a new instance of the auto-generated ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecastClient"),". We then call ",(0,a.kt)("inlineCode",{parentName:"p"},"weatherClient.get()")," which sends the ",(0,a.kt)("inlineCode",{parentName:"p"},"GET")," request to the server to acquire the data and provides it in a strongly typed fashion (",(0,a.kt)("inlineCode",{parentName:"p"},"get()")," returns an array of ",(0,a.kt)("inlineCode",{parentName:"p"},"WeatherForecast"),"). This is then displayed on the page like so:"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"load data from server",src:n(47350).Z,width:"600",height:"354"})),(0,a.kt)("p",null,"As you an see we're loading data from the server using our auto-generated client. We're reducing the amount of code we have to write ",(0,a.kt)("em",{parentName:"p"},"and")," we're reducing the likelihood of errors."),(0,a.kt)("p",null,"This post was originally posted on ",(0,a.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/"},"LogRocket"),"."),(0,a.kt)("head",null,(0,a.kt)("link",{rel:"canonical",href:"https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/"})))}d.isMDXComponent=!0},73812:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/swagger-44c75962c8d5a84333bfbcd776308ad9.webp"},47350:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/use-generated-client-68121118d8862aee3faf83860aeb6de9.gif"}}]);