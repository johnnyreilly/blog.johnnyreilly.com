"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["88117"],{7663:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return a},default:function(){return l},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return d}});var s=t(34835),i=t(85893),o=t(50065);let r={slug:"using-reflection-to-identify-unwanted-dependencies",title:"Using Reflection to Identify Unwanted Dependencies",authors:"johnnyreilly",tags:["asp.net"],hide_table_of_contents:!1,description:"Learn how to identify unwelcome dependencies in complex web apps by walking a dependency tree using reflection-based tests."},a=void 0,p={authorsImageUrls:[void 0]},d=[];function c(e){let n={code:"code",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"I having a web app which is fairly complex. It's made up of services, controllers and all sorts of things. So far, so unremarkable. However, I needed to ensure that the controllers did not attempt to access the database via any of their dependencies. Or their dependencies, dependencies. Or their dependencies. You get my point."}),"\n",(0,i.jsx)(n.p,{children:"The why is not important here. What's significant is the idea of walking a dependency tree and identifying, via a reflection based test, when such unwelcome dependencies occur, and where."}),"\n",(0,i.jsx)(n.p,{children:"When they do occur the test should fail, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"[xUnit.net 00:00:01.6766691]     My.Web.Tests.HousekeepingTests.My_Api_Controllers_do_not_depend_upon_the_database [FAIL]\n[xUnit.net 00:00:01.6782295]       Expected dependsUponTheDatabase.Any() to be False because My.Api.Controllers.ThingyController depends upon the database through My.Data.Services.OohItsAService, but found True.\n"})}),"\n",(0,i.jsx)(n.p,{children:"What follows is an example of how you can accomplish this. It is exceedingly far from the most beautiful code I've ever written. But it works. One reservation I have about it is that it doesn't use the Dependency Injection mechanism used at runtime (AutoFac). If I had more time I would amend the code to use that instead; it would become an easier test to read if I did. Also it would better get round the limitations of the code below. Essentially the approach relies on the assumption of there being 1 interface and 1 implementation. That's often not true in complex systems. But this is good enough to roll with for now."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing FluentAssertions;\nusing My.Data;\nusing My.Web.Controllers;\nusing Xunit;\n\nnamespace My.Web.Tests {\n    public class OiYouThereGetOutTests {\n        [Fact]\n        public void My_Controllers_do_not_depend_upon_the_database() {\n            var myConcreteTypes = GetMyAssemblies()\n                .SelectMany(assembly => assembly.GetTypes())\n                .ToArray();\n\n            var controllerTypes = typeof(My.Web.Startup).Assembly.GetTypes()\n                .Where(myWebType =>\n                    myWebType != typeof(Microsoft.AspNetCore.Mvc.Controller) &&\n                    typeof(Microsoft.AspNetCore.Mvc.Controller).IsAssignableFrom(myWebType));\n\n            foreach (var controllerType in controllerTypes) {\n                var allTheTypes = GetDependentTypes(controllerType, myConcreteTypes);\n                allTheTypes.Count.Should().BeGreaterThan(0);\n                var dependsUponTheDatabase = allTheTypes.Where(keyValue => keyValue.Key == typeof(MyDbContext));\n                dependsUponTheDatabase.Any().Should().Be(false, because: $"{controllerType} depends upon the database through {string.Join(", ", dependsUponTheDatabase.Select(dod => dod.Value))}");\n            }\n        }\n\n        private static Dictionary<Type, Type> GetDependentTypes(Type type, Type[] typesToCheck, Dictionary<Type, Type> typesSoFar = null) {\n            var types = typesSoFar ?? new Dictionary<Type, Type>();\n            foreach (var constructor in type.GetConstructors().Where(ctor => ctor.IsPublic)) {\n                foreach (var parameter in constructor.GetParameters()) {\n                    if (parameter.ParameterType.IsInterface) {\n                        if (parameter.ParameterType.IsGenericType) {\n                            foreach (var genericType in parameter.ParameterType.GenericTypeArguments) {\n                                AddIfMissing(types, genericType, type);\n                            }\n                        } else {\n                            var typesImplementingInterface = TypesImplementingInterface(parameter.ParameterType, typesToCheck);\n                            foreach (var typeImplementingInterface in typesImplementingInterface) {\n                                AddIfMissing(types, typeImplementingInterface, type);\n                                AddIfMissing(types, GetDependentTypes(typeImplementingInterface, typesToCheck, types).Keys.ToList(), type);\n                            }\n                        }\n                    } else {\n                        AddIfMissing(types, parameter.ParameterType, type);\n                        AddIfMissing(types, GetDependentTypes(parameter.ParameterType, typesToCheck, types).Keys.ToList(), type);\n                    }\n                }\n            }\n            return types;\n        }\n\n        private static void AddIfMissing(Dictionary<Type, Type> types, Type typeToAdd, Type parentType) {\n            if (!types.Keys.Contains(typeToAdd))\n                types.Add(typeToAdd, parentType);\n        }\n\n        private static void AddIfMissing(Dictionary<Type, Type> types, IList<Type> typesToAdd, Type parentType) {\n            foreach (var typeToAdd in typesToAdd) {\n                AddIfMissing(types, typeToAdd, parentType);\n            }\n        }\n\n        private static Type[] TypesImplementingInterface(Type interfaceType, Type[] typesToCheck) =>\n            typesToCheck.Where(type => !type.IsInterface && interfaceType.IsAssignableFrom(type)).ToArray();\n\n        private static bool IsRealClass(Type testType) =>\n            testType.IsAbstract == false &&\n            testType.IsGenericType == false &&\n            testType.IsGenericTypeDefinition == false &&\n            testType.IsInterface == false;\n\n        private static Assembly[] GetMyAssemblies() =>\n            AppDomain\n            .CurrentDomain\n            .GetAssemblies()\n            // Not strictly necessary but it reduces the amount of types returned\n            .Where(assembly => assembly.GetName().Name.StartsWith("My"))\n            .ToArray();\n    }\n}\n'})})]})}function l(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},50065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return r}});var s=t(67294);let i={},o=s.createContext(i);function r(e){let n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},34835:function(e){e.exports=JSON.parse('{"permalink":"/using-reflection-to-identify-unwanted-dependencies","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2018-04-28-using-reflection-to-identify-unwanted-dependencies/index.md","source":"@site/blog/2018-04-28-using-reflection-to-identify-unwanted-dependencies/index.md","title":"Using Reflection to Identify Unwanted Dependencies","description":"Learn how to identify unwelcome dependencies in complex web apps by walking a dependency tree using reflection-based tests.","date":"2018-04-28T00:00:00.000Z","tags":[{"inline":false,"label":"ASP.NET","permalink":"/tags/asp-net","description":"The web framework built by Microsoft."}],"readingTime":2.545,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"using-reflection-to-identify-unwanted-dependencies","title":"Using Reflection to Identify Unwanted Dependencies","authors":"johnnyreilly","tags":["asp.net"],"hide_table_of_contents":false,"description":"Learn how to identify unwelcome dependencies in complex web apps by walking a dependency tree using reflection-based tests."},"unlisted":false,"prevItem":{"title":"Compromising: A Guide for Developers","permalink":"/compromising-guide-for-developers"},"nextItem":{"title":"It\'s Not Dead 2: mobx-react-devtools and the undead","permalink":"/its-not-dead-2-mobx-react-devtools-and-the-undead"}}')}}]);