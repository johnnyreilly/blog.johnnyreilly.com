"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[91391],{27441:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>g});var o=n(85893),s=n(11151);const i={slug:"snapshot-log-tests-dotnet",title:"Snapshot log tests in .NET",authors:"johnnyreilly",tags:["asp.net","c#","automated testing"],image:"./title-image.png",description:"This post demonstrates how to write high quality and low effort log assertions using snapshot testing.",hide_table_of_contents:!1},a=void 0,r={permalink:"/snapshot-log-tests-dotnet",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-12-20-snapshot-log-tests-dotnet/index.md",source:"@site/blog/2023-12-20-snapshot-log-tests-dotnet/index.md",title:"Snapshot log tests in .NET",description:"This post demonstrates how to write high quality and low effort log assertions using snapshot testing.",date:"2023-12-20T00:00:00.000Z",formattedDate:"December 20, 2023",tags:[{label:"asp.net",permalink:"/tags/asp-net"},{label:"c#",permalink:"/tags/c"},{label:"automated testing",permalink:"/tags/automated-testing"}],readingTime:4.785,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"snapshot-log-tests-dotnet",title:"Snapshot log tests in .NET",authors:"johnnyreilly",tags:["asp.net","c#","automated testing"],image:"./title-image.png",description:"This post demonstrates how to write high quality and low effort log assertions using snapshot testing.",hide_table_of_contents:!1},unlisted:!1,nextItem:{title:"Overview of Bun, a JavaScript runtime",permalink:"/bun-overview"}},l={image:n(30273).Z,authorsImageUrls:[void 0]},g=[{value:"How to test <code>ILogger</code>?",id:"how-to-test-ilogger",level:2},{value:".NET and <code>FakeLogger</code>",id:"net-and-fakelogger",level:2},{value:"How to test <code>ILogger</code> with Snapshooter?",id:"how-to-test-ilogger-with-snapshooter",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Writing tests is important. The easier it is to write tests, the more likely they'll be written. I've long loved snapshot testing for this reason. Snapshot testing takes away the need to manually write verification code in your tests. Instead, you write tests that compare the output of a call to your method with JSON serialised output you've generated on a previous occasion. This approach takes less time to write, less time to maintain, and the solid readability of JSON makes it more likely you'll pick up on bugs. It's so much easier to scan JSON than it is a list of assertions."}),"\n",(0,o.jsx)(t.p,{children:"Loving snapshot testing as I do, I want to show you how to write high quality and low effort log assertions using snapshot testing. The behaviour of logging code is really important; it's this that we tend to rely upon when debugging production issues. But how do you test logging code? Well, you could write a bunch of assertions that check how your logger is used. But that's a lot of work, it's not super readable and it's not fun. (Always remember: if it's not fun, you're doing it wrong.)"}),"\n",(0,o.jsx)(t.p,{children:"Instead, we'll achieve this using snapshot testing."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"title image reading &quot;Snapshot log tests in .NET&quot; with the .NET logo",src:n(95004).Z+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,o.jsxs)(t.p,{children:["I've written previously about ",(0,o.jsx)(t.a,{href:"/snapshot-testing-for-c",children:"manually implementing snapshot testing with .NET"}),". That was great, but I subsequently moved to use the excellent ",(0,o.jsx)(t.a,{href:"https://github.com/SwissLife-OSS/snapshooter",children:"Snapshooter"})," instead. In this post we'll use that. I'm using XUnit as my test framework; but Snapshooter also supports MSTest and NUnit if they are your preference."]}),"\n",(0,o.jsxs)(t.h2,{id:"how-to-test-ilogger",children:["How to test ",(0,o.jsx)(t.code,{children:"ILogger"}),"?"]}),"\n",(0,o.jsxs)(t.p,{children:["Before we get into the details of how to test logging code, let's first consider how we might test a method that uses ",(0,o.jsx)(t.code,{children:"ILogger"}),". Here's a simple example:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:'using Microsoft.Extensions.Logging;\n\nnamespace MyApp.Tests.Services;\n\npublic class GreetingService(ILogger<GreetingService> log)\n{\n    private readonly ILogger<GreetingService> _log = log;\n\n    public string GetGreeting(string name)\n    {\n        _log.LogInformation($"Greeting {{{nameof(name)}}}", name);\n\n        return $"Hello, {name}!";\n    }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["If we look at the class above, we can see it has a dependency on ",(0,o.jsx)(t.code,{children:"ILogger<GreetingService>"}),". This is a common pattern in .NET applications. The ",(0,o.jsx)(t.code,{children:"ILogger"})," interface is used to write log messages. I wouldn't be surprised if it's the most commonly used interface in .NET applications."]}),"\n",(0,o.jsxs)(t.p,{children:["If we execute the ",(0,o.jsx)(t.code,{children:"GetGreeting"})," method above, we'll both get a greeting returned and a log message will be written. In order that we can test this method, we need to be able to verify that the log message was written correctly. We're going to do that by making use of a fake logger:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"using Microsoft.Extensions.Logging;\n\nnamespace MyApp.Tests.TestUtilities;\n\npublic record LogEntry(LogLevel Level, string Message, Exception? Exception);\n\npublic class FakeLogger<T> : ILogger<T>\n{\n    public List<LogEntry> Entries { get; } = [];\n\n    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => NullScope.Instance;\n\n    public bool IsEnabled(LogLevel logLevel) => true;\n\n    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter) =>\n        Entries.Add(new LogEntry(logLevel, formatter(state, exception), exception));\n\n    /// <summary>\n    /// Reference: https://github.com/aspnet/Logging/blob/master/src/Microsoft.Extensions.Logging.Abstractions/Internal/NullScope.cs\n    /// </summary>\n    sealed class NullScope : IDisposable\n    {\n        public static NullScope Instance { get; } = new NullScope();\n\n        private NullScope()\n        {\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This fake logger is a simple implementation of ",(0,o.jsx)(t.code,{children:"ILogger<T>"}),". It's a fake because it doesn't actually write anything to a log. Instead, it records the log messages it's asked to write in a list of ",(0,o.jsx)(t.code,{children:"LogEntry"})," objects. We can then use this list to verify that the log messages were written correctly. It's inspired by ",(0,o.jsx)(t.a,{href:"https://pnguyen.io/posts/verify-ilogger-call-in-dotnet-core/",children:"this post"})," but takes it further by keeping a full record of each call."]}),"\n",(0,o.jsxs)(t.h2,{id:"net-and-fakelogger",children:[".NET and ",(0,o.jsx)(t.code,{children:"FakeLogger"})]}),"\n",(0,o.jsxs)(t.p,{children:["After writing this post I came to learn that as of .NET 8, there is a ",(0,o.jsx)(t.code,{children:"FakeLogger"})," built in. You can read more about that here: ",(0,o.jsx)(t.a,{href:"https://devblogs.microsoft.com/dotnet/fake-it-til-you-make-it-to-production/#logging-fake",children:"https://devblogs.microsoft.com/dotnet/fake-it-til-you-make-it-to-production/#logging-fake"})]}),"\n",(0,o.jsx)(t.p,{children:"I'll update this post to use that directly at some point if it works in the way that I hope."}),"\n",(0,o.jsxs)(t.h2,{id:"how-to-test-ilogger-with-snapshooter",children:["How to test ",(0,o.jsx)(t.code,{children:"ILogger"})," with Snapshooter?"]}),"\n",(0,o.jsxs)(t.p,{children:["Now that we have a fake logger, we can use it to test our ",(0,o.jsx)(t.code,{children:"GetGreeting"})," method. Here's how we might do that:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:'public class GreetingServiceTests\n{\n    [Fact]\n    public void GetGreeting_greets_and_logs()\n    {\n        // Arrange\n        var log = new FakeLogger<GreetingService>();\n\n        var greetingService = new GreetingService(log);\n\n        // Act\n        var greeting = greetingService.GetGreeting("John");\n\n        // Assert\n        Snapshot.Match(new { log, greeting });\n    }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Here, we create an instance of ",(0,o.jsx)(t.code,{children:"FakeLogger<GreetingService>"})," and pass it into the ",(0,o.jsx)(t.code,{children:"GreetingService"})," constructor. We then call ",(0,o.jsx)(t.code,{children:"GetGreeting"})," and finally we use Snapshooter to verify that the log messages were written correctly and that the greeting generated is what we expect."]}),"\n",(0,o.jsxs)(t.p,{children:["When the test is first run, a ",(0,o.jsx)(t.code,{children:"GreetingServiceTests.GetGreeting_greets_and_logs.snap"})," snapshot is created. This snapshot contains the serialised ",(0,o.jsx)(t.code,{children:"log"})," and ",(0,o.jsx)(t.code,{children:"greeting"})," objects. Subsequent runs of the test will compare the current output with the snapshot. If the output matches the snapshot, the test passes. If it doesn't, the test fails. Here is what the contents of the snapshot should look like:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'{\n  "log": {\n    "Entries": [\n      {\n        "Level": "Information",\n        "Message": "Greeting John",\n        "Exception": null\n      }\n    ]\n  },\n  "greeting": "Hello, John!"\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["And that's it, we're done! We've tested our logging code with minimal effort; the only assertion we wrote was ",(0,o.jsx)(t.code,{children:"Snapshot.Match(new { log, greeting })"}),". If we change behaviour of the ",(0,o.jsx)(t.code,{children:"GetGreeting"})," method, the test will fail. We can then update the snapshot and we're good to go."]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"In this post we've seen how to use Snapshooter to test logging code. This approach is easy to implement, easy to maintain and easy to read. Significantly: it involves very little work on our part. If you're not already using snapshot testing, I hope this post has inspired you to give it a try. If you are already using snapshot testing, I hope this post has inspired you to use it to test your logging code."})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},30273:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/title-image-86eb28c76643a3ea99cad34ff1006d94.png"},95004:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/title-image-86eb28c76643a3ea99cad34ff1006d94.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>a});var o=n(67294);const s={},i=o.createContext(s);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);