"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[67069],{5045:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-1ab82b471ea6afa313c1a6fb09361acd.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}},29948:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-1ab82b471ea6afa313c1a6fb09361acd.png"},86058:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>m});var i=n(86466),s=n(74848),o=n(28453);const a={slug:"azure-devops-pull-requests-conventional-commits",title:"Azure DevOps: merging pull requests with conventional commits",authors:"johnnyreilly",tags:["typescript","azure devops","node.js"],image:"./title-image.png",hide_table_of_contents:!1,description:"How to merge a pull request in Azure DevOps and maintain a git commit history of conventional commits, using the Azure DevOps API and build validations."},r=void 0,l={image:n(29948).A,authorsImageUrls:[void 0]},m=[];function c(e){const t={a:"a",img:"img",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"There was a time in my life when I didn't really care about commit messages. I would just write whatever I felt like, and it was fine. Over time, I learned that good commit messages are important for understanding the history of a project, especially when working in a team. And also, because I tend to forget what I've been working on surprisingly quickly."}),"\n",(0,s.jsxs)(t.p,{children:["There's also more technical reasons to care about commit messages. For example, if you're using a tool like ",(0,s.jsx)(t.a,{href:"https://semantic-release.gitbook.io/semantic-release/",children:"semantic-release"}),' to automate your release process, it relies on conventional commit messages to determine the next version number and generate release notes. It turns out that Azure DevOps has some challenges when it comes to maintaining a git commit history of conventional commits, especially when merging pull requests. By default, Azure DevOps uses a commit strategy that creates a merge commit with a message like "Merge PR 123: Title of pull request". This is acts against conventional commits.']}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"title image reading &quot;Azure DevOps: merging pull requests with conventional commits&quot; with an Azure DevOps logo",src:n(5045).A+"",width:"800",height:"450",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"You can use the UI to change the commit message when completing a pull request, but it's very easy to forget to do this. And if you're using squash merges, you lose the individual commit messages from the feature branch, which can be a problem if you're trying to maintain a history of conventional commits."}),"\n",(0,s.jsx)(t.p,{children:"There is a way to bend Azure DevOps to our will; to allow us to control our commit messages. In this post, I'll show you how to do just that using the Azure DevOps API, some TypeScript and build validations. The fact this mechanism lives in a build validation means you cannot forget to set the commit message. That's the feature."}),"\n",(0,s.jsx)(t.p,{children:"This post is not, in fact, specifically about using conventional commits. That's just a common use case. Rather this post is about being able to control the commit message when merging pull requests in Azure DevOps."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},86466:e=>{e.exports=JSON.parse('{"permalink":"/azure-devops-pull-requests-conventional-commits","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2025-08-29-azure-devops-pull-requests-conventional-commits/index.md","source":"@site/blog/2025-08-29-azure-devops-pull-requests-conventional-commits/index.md","title":"Azure DevOps: merging pull requests with conventional commits","description":"How to merge a pull request in Azure DevOps and maintain a git commit history of conventional commits, using the Azure DevOps API and build validations.","date":"2025-08-29T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."},{"inline":false,"label":"Azure DevOps","permalink":"/tags/azure-devops","description":"The Azure DevOps suite of tools."},{"inline":false,"label":"Node.js","permalink":"/tags/node-js","description":"The Node.js runtime."}],"readingTime":8.29,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"azure-devops-pull-requests-conventional-commits","title":"Azure DevOps: merging pull requests with conventional commits","authors":"johnnyreilly","tags":["typescript","azure devops","node.js"],"image":"./title-image.png","hide_table_of_contents":false,"description":"How to merge a pull request in Azure DevOps and maintain a git commit history of conventional commits, using the Azure DevOps API and build validations."},"unlisted":false,"prevItem":{"title":"Keeping front end and back end in sync with NSwag generated clients","permalink":"/keeping-front-end-and-back-end-in-sync-with-nswag-generated-clients"},"nextItem":{"title":"Azure DevOps: merging pull requests and setting autocomplete with the API","permalink":"/azure-devops-api-pull-requests-merge-set-autocomplete"}}')}}]);