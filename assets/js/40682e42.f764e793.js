"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["57844"],{75080:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return r},default:function(){return d},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return p}});var i=t(77238),s=t(85893),a=t(50065);let o={slug:"smuggling-gitignore-npmrc-in-npm-packages",title:"Smuggling .gitignore, .npmrc and friends in npm packages",authors:"johnnyreilly",tags:["node.js"],image:"./title-image.png",hide_table_of_contents:!1,description:"The npm publish command will not just package up .gitignore and .npmrc files. This post shows how to use zipping and unzipping with postinstall and prepare scripts to include these files into your npm package."},r=void 0,l={image:t(42125).Z,authorsImageUrls:[void 0]},p=[{value:"A little backstory",id:"a-little-backstory",level:2},{value:"<code>prepare</code> and <code>postinstall</code> scripts",id:"prepare-and-postinstall-scripts",level:2},{value:"<code>prepare.js</code>",id:"preparejs",level:2},{value:"<code>postinstall.js</code>",id:"postinstalljs",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["I recently needed to include a number of ",(0,s.jsx)(n.code,{children:".gitignore"})," and ",(0,s.jsx)(n.code,{children:".npmrc"})," files in an npm package. I was surprised to find that the ",(0,s.jsx)(n.code,{children:"npm publish"})," command strips these out of the published package by default. As a consequence, This broke my package, and so I needed to find a way to get round this shortcoming."]}),"\n",(0,s.jsxs)(n.p,{children:["I ended up using zipping and unzipping with ",(0,s.jsx)(n.code,{children:"postinstall"})," and ",(0,s.jsx)(n.code,{children:"prepare"})," scripts to include these files into my npm package."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"title image reading &quot;Smuggling dotfiles in npm packages&quot; with the Node.js and npm logos",src:t(45330).Z+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,s.jsxs)(n.p,{children:["This post shows how to use zipping and unzipping with ",(0,s.jsx)(n.code,{children:"postinstall"})," and ",(0,s.jsx)(n.code,{children:"prepare"})," scripts to include these files into your npm package."]}),"\n",(0,s.jsx)(n.h2,{id:"a-little-backstory",children:"A little backstory"}),"\n",(0,s.jsxs)(n.p,{children:['I\'m currently beavering away on a "create-*-app" tool that generates new projects from a number of available templates. That tool takes the form of a CLI tool built with TypeScript, published as a package to an npm registry and consumed with ',(0,s.jsx)(n.code,{children:"npx"}),". Significantly, the templates that ship with the CLI take the form of a ",(0,s.jsx)(n.code,{children:"templates"})," folder in the package, and the folders in those templates include ",(0,s.jsx)(n.code,{children:".npmrc"})," and ",(0,s.jsx)(n.code,{children:".gitignore"})," files; which are key to the functionality of the templates."]}),"\n",(0,s.jsxs)(n.p,{children:["When publishing my npm package, I discovered that the ",(0,s.jsx)(n.code,{children:".npmrc"})," and ",(0,s.jsx)(n.code,{children:".gitignore"})," files in subfolders were being stripped from the package. After a little research, I happened upon this ",(0,s.jsx)(n.a,{href:"https://github.com/npm/npm/issues/3763",children:"GitHub issue about npm"})," which describes some of the behaviour I was seeing. After a touch more digging, I came to understand that this behaviour is a result of npm treating the ",(0,s.jsx)(n.code,{children:".gitignore"})," and ",(0,s.jsx)(n.code,{children:".npmrc"})," files as configuration files rather than part of the package's intended content."]}),"\n",(0,s.jsx)(n.p,{children:"However, given these files are essential to the templates' functionality, I needed to find a way to include them in the package."}),"\n",(0,s.jsxs)(n.p,{children:["I mused with explicitly including the specific files in the ",(0,s.jsx)(n.code,{children:"files"})," section of the ",(0,s.jsx)(n.code,{children:"package.json"}),' file, but this would have been a maintenance headache. I wanted a more automated solution. Given that I have a single "special" folder called ',(0,s.jsx)(n.code,{children:"templates"})," that contains all the templates, I pondered whether I could zip the folder on publish and unzip it on install. This would allow me to include the ",(0,s.jsx)(n.code,{children:".gitignore"})," and ",(0,s.jsx)(n.code,{children:".npmrc"})," files in the templates and have them copied into the new project when the template was used. And if there was another other curious behaviour around publishing, this solution should cover that too."]}),"\n",(0,s.jsxs)(n.h2,{id:"prepare-and-postinstall-scripts",children:[(0,s.jsx)(n.code,{children:"prepare"})," and ",(0,s.jsx)(n.code,{children:"postinstall"})," scripts"]}),"\n",(0,s.jsxs)(n.p,{children:["I achieved this by using ",(0,s.jsx)(n.code,{children:"prepare"})," and ",(0,s.jsx)(n.code,{children:"postinstall"})," scripts in the ",(0,s.jsx)(n.code,{children:"package.json"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"prepare"})," and ",(0,s.jsx)(n.code,{children:"postinstall"})," scripts are two of the lifecycle scripts that npm runs when installing a package. The ",(0,s.jsx)(n.code,{children:"prepare"})," script runs before the package is packaged and published, and the ",(0,s.jsx)(n.code,{children:"postinstall"})," script runs after the package is installed. I opted to use these scripts to zip and unzip the ",(0,s.jsx)(n.code,{children:"templates"})," folder in my package."]}),"\n",(0,s.jsxs)(n.p,{children:["I performed the actual zipping and unzipping with some Node.js scripts. We'll look into the implementation of these scripts in a moment, but first please note the scripts we added to the ",(0,s.jsx)(n.code,{children:"package.json"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'  "scripts": {\n    "postinstall": "node ./scripts/postinstall.js",\n    "prepare": "node ./scripts/prepare.js"\n  },\n'})}),"\n",(0,s.jsxs)(n.p,{children:["These scripts contain the paths to the Node.js scripts that perform the zipping and unzipping. The ",(0,s.jsx)(n.code,{children:"postinstall"})," script runs after the package is installed, and the ",(0,s.jsx)(n.code,{children:"prepare"})," script runs before the package is packaged and published."]}),"\n",(0,s.jsxs)(n.p,{children:["When it comes to zipping and unzipping, I used the ",(0,s.jsx)(n.a,{href:"https://github.com/cthackers/adm-zip",children:(0,s.jsx)(n.code,{children:"adm-zip"})})," package. This package provides a simple API for zipping and unzipping files and folders."]}),"\n",(0,s.jsx)(n.h2,{id:"preparejs",children:(0,s.jsx)(n.code,{children:"prepare.js"})}),"\n",(0,s.jsxs)(n.p,{children:["We'll first look at the ",(0,s.jsx)(n.code,{children:"prepare.js"})," script. This script zips the ",(0,s.jsx)(n.code,{children:"templates"})," folder in the package into a ",(0,s.jsx)(n.code,{children:"templates.zip"})," file. The script then writes the zip file to the package's root directory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import AdmZip from 'adm-zip';\nimport fs from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\nfunction packTemplates() {\n  console.log('prepare running - packing templates');\n\n  const templatesZipPath = fileURLToPath(\n    new URL('../templates.zip', import.meta.url),\n  );\n  const templatesDir = fileURLToPath(new URL('../templates', import.meta.url));\n\n  const zip = new AdmZip();\n\n  console.log(`removing existing ${templatesZipPath}`);\n  fs.rmSync(templatesZipPath, {\n    force: true,\n  });\n\n  console.log(`adding ${templatesDir} to zip file`);\n  zip.addLocalFolder(templatesDir);\n\n  console.log(`writing zip to ${templatesZipPath}`);\n  zip.writeZip(templatesZipPath);\n}\n\npackTemplates();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It also removes any existing ",(0,s.jsx)(n.code,{children:"templates.zip"})," file in the package's root directory before creating a new one. This is to ensure that the zip file is always up to date."]}),"\n",(0,s.jsx)(n.h2,{id:"postinstalljs",children:(0,s.jsx)(n.code,{children:"postinstall.js"})}),"\n",(0,s.jsxs)(n.p,{children:["Now we'll look at the ",(0,s.jsx)(n.code,{children:"postinstall.js"})," script. This script unzips the ",(0,s.jsx)(n.code,{children:"templates.zip"})," file in the package into a ",(0,s.jsx)(n.code,{children:"templates"})," folder. The script then writes the unzipped folder to the package's root directory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import AdmZip from 'adm-zip';\nimport fs from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\nfunction extractTemplates() {\n  console.log('postinstall running - extracting templates');\n  const templatesZipPath = fileURLToPath(\n    new URL('../templates.zip', import.meta.url),\n  );\n  const templatesDir = fileURLToPath(new URL('../templates', import.meta.url));\n\n  let templatesExistsAlready = true;\n  try {\n    fs.accessSync(templatesDir);\n  } catch {\n    templatesExistsAlready = false;\n  }\n\n  if (templatesExistsAlready) {\n    console.log('templates already extracted');\n    return;\n  }\n\n  console.log(`extracting from ${templatesZipPath} to ${templatesDir}`);\n\n  const extractZip = new AdmZip(templatesZipPath);\n  extractZip.extractAllTo(templatesDir, /* overwrite */ false);\n\n  console.log('templates extracted');\n}\n\nextractTemplates();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You'll notice that the script checks whether the ",(0,s.jsx)(n.code,{children:"templates"})," folder already exists before unzipping the ",(0,s.jsx)(n.code,{children:"templates.zip"})," file. This is to ensure that the folder is only unzipped once."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["So here we have a method for including ",(0,s.jsx)(n.code,{children:".gitignore"})," and ",(0,s.jsx)(n.code,{children:".npmrc"})," files in an npm package. By using zipping and unzipping with ",(0,s.jsx)(n.code,{children:"postinstall"})," and ",(0,s.jsx)(n.code,{children:"prepare"})," scripts, we can include these files in the package and have them copied into the new project when the package is installed."]}),"\n",(0,s.jsxs)(n.p,{children:["My example is a ",(0,s.jsx)(n.code,{children:"templates"})," folder - yours could be anything. And likewise if you have other files that are being stripped from your package, you could use this method to include them too."]})]})}function d(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},42125:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/title-image-8561ca58b004dee58e58697a4bf27a8e.png"},45330:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/title-image-8561ca58b004dee58e58697a4bf27a8e.png"},50065:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return o}});var i=t(67294);let s={},a=i.createContext(s);function o(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},77238:function(e){e.exports=JSON.parse('{"permalink":"/smuggling-gitignore-npmrc-in-npm-packages","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2024-12-22-smuggling-gitignore-npmrc-in-npm-packages/index.md","source":"@site/blog/2024-12-22-smuggling-gitignore-npmrc-in-npm-packages/index.md","title":"Smuggling .gitignore, .npmrc and friends in npm packages","description":"The npm publish command will not just package up .gitignore and .npmrc files. This post shows how to use zipping and unzipping with postinstall and prepare scripts to include these files into your npm package.","date":"2024-12-22T00:00:00.000Z","tags":[{"inline":false,"label":"Node.js","permalink":"/tags/node-js","description":"The Node.js runtime."}],"readingTime":4.64,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"smuggling-gitignore-npmrc-in-npm-packages","title":"Smuggling .gitignore, .npmrc and friends in npm packages","authors":"johnnyreilly","tags":["node.js"],"image":"./title-image.png","hide_table_of_contents":false,"description":"The npm publish command will not just package up .gitignore and .npmrc files. This post shows how to use zipping and unzipping with postinstall and prepare scripts to include these files into your npm package."},"unlisted":false,"prevItem":{"title":"Slash command your deployment with GitHub Actions","permalink":"/slash-command-your-deployment-with-github-actions"},"nextItem":{"title":"npx and Azure Artifacts: the secret CLI delivery mechanism","permalink":"/npx-and-azure-artifacts-the-secret-cli-delivery-mechanism"}}')}}]);