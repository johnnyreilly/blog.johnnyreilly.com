"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["70253"],{38872:function(e,n,o){o.r(n),o.d(n,{assets:function(){return c},contentTitle:function(){return r},default:function(){return d},frontMatter:function(){return a},metadata:function(){return s},toc:function(){return l}});var s=o(78182),t=o(85893),i=o(50065);let a={slug:"finding-webpack-4-use-map",title:"Finding webpack 4 (use a Map)",authors:"johnnyreilly",tags:["webpack"],hide_table_of_contents:!1,description:'webpack 4s new plugin architecture requires migrating from "kebab-case" to "camelCase". A migration guide for plugins and loaders is available.'},r=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Update: 03/02/2018",id:"update-03022018",level:2},{value:"webpack 4",id:"webpack-4",level:2},{value:"Plugins",id:"plugins",level:2},{value:"Custom Hooks",id:"custom-hooks",level:2},{value:"Loaders",id:"loaders",level:2},{value:"I need a <code>Map</code>",id:"i-need-a-map",level:2},{value:"Happy Porting!",id:"happy-porting",level:2}];function h(e){let n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"update-03022018",children:"Update: 03/02/2018"}),"\n",(0,t.jsxs)(n.p,{children:["Tobias Koppers has written a migration guide for plugins / loaders as well - take a read ",(0,t.jsx)(n.a,{href:"https://medium.com/webpack/webpack-4-migration-guide-for-plugins-loaders-20a79b927202",children:"here"}),". It's very useful."]}),"\n",(0,t.jsx)(n.h2,{id:"webpack-4",children:"webpack 4"}),"\n",(0,t.jsxs)(n.p,{children:["webpack 4 is on the horizon. ",(0,t.jsx)(n.a,{href:"https://medium.com/webpack/webpack-4-beta-try-it-today-6b1d27d7d7e2",children:"The beta dropped last Friday"}),". So what do you, as a plugin / loader author need to do? What needs to change to make your loader / plugin webpack 4 friendly?"]}),"\n",(0,t.jsxs)(n.p,{children:["This is a guide that should inform you about the changes you might need to make. It's based on my own experiences migrating ",(0,t.jsx)(n.a,{href:"https://github.com/TypeStrong/ts-loader",children:(0,t.jsx)(n.code,{children:"ts-loader"})})," and the ",(0,t.jsx)(n.a,{href:"https://github.com/Realytics/fork-ts-checker-webpack-plugin",children:(0,t.jsx)(n.code,{children:"fork-ts-checker-webpack-plugin"})}),". If you'd like to see this in action then take a look at the PRs related to these. The ts-loader PR can be found ",(0,t.jsx)(n.a,{href:"https://github.com/TypeStrong/ts-loader/pull/710",children:"here"}),". The fork-ts-checker-webpack-plugin PR can be found ",(0,t.jsx)(n.a,{href:"https://github.com/Realytics/fork-ts-checker-webpack-plugin/pull/93",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"plugins",children:"Plugins"}),"\n",(0,t.jsxs)(n.p,{children:["One of the notable changes to webpack with v4 is the change to the plugin architecture. In terms of implications it's worth reading the comments made by ",(0,t.jsx)(n.a,{href:"https://twitter.com/wsokra",children:"Tobias Koppers"}),(0,t.jsx)(n.a,{href:"https://github.com/webpack/webpack/issues/6244#issuecomment-357502113",children:"here"})," and ",(0,t.jsx)(n.a,{href:"https://github.com/webpack/webpack/issues/6064#issuecomment-349405474",children:"here"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Previously, if your plugin was tapping into a compiler hook you'd write code that looked something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler.plugin('watch-close', () => {\n  // do your thing here\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"With webpack 4 things done changed. You'd now write something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler.hooks.watchClose.tap(\n  'name-to-identify-your-plugin-goes-here',\n  () => {\n    // do your thing here\n  },\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Hopefully that's fairly clear; we're using the new ",(0,t.jsx)(n.code,{children:"hooks"})," property and tapping into our event of choice by ",(0,t.jsx)(n.code,{children:"camelCasing"})," what was previously ",(0,t.jsx)(n.code,{children:"kebab-cased"}),". So in this case ",(0,t.jsx)(n.code,{children:"plugin('watch-close' =&gt; hooks.watchClose.tap"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"In the example above we were attaching to a sync hook. Now let's look at an async hook:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler.plugin('watch-run', (watching, callback) => {\n  // do your thing here\n  callback();\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"This would change to be:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler.hooks.watchRun.tapAsync(\n  'name-to-identify-your-plugin-goes-here',\n  (compiler, callback) => {\n    // do your thing here\n    callback();\n  },\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that rather than using ",(0,t.jsx)(n.code,{children:"tap"})," here, we're using ",(0,t.jsx)(n.code,{children:"tapAsync"}),". If you're more into promises there's a ",(0,t.jsx)(n.code,{children:"tapPromise"})," you could use instead."]}),"\n",(0,t.jsx)(n.h2,{id:"custom-hooks",children:"Custom Hooks"}),"\n",(0,t.jsx)(n.p,{children:"Prior to webpack 4, you could use your own custom hooks within your plugin. Usage was as simple as this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler.applyPluginsAsync('fork-ts-checker-service-before-start', () => {\n  // do your thing here\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can still use custom hooks with webpack 4, but there's a little more ceremony involved. Essentially, you need to tell webpack up front what you're planning. Not hard, I promise you."}),"\n",(0,t.jsxs)(n.p,{children:["First of all, you'll need to add the package ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/tapable",children:(0,t.jsx)(n.code,{children:"tapable"})})," as a dependency. Then, inside your plugin you'll need to import the type of hook that you want to use; in the case of the ",(0,t.jsx)(n.code,{children:"fork-ts-checker-webpack-plugin"})," we used both a sync and an async hook:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const AsyncSeriesHook = require('tapable').AsyncSeriesHook;\nconst SyncHook = require('tapable').SyncHook;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then, inside your ",(0,t.jsx)(n.code,{children:"apply"})," method you need to register your hooks:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"if (\n  this.compiler.hooks.forkTsCheckerServiceBeforeStart ||\n  this.compiler.hooks.forkTsCheckerCancel ||\n  // other hooks...\n  this.compiler.hooks.forkTsCheckerEmit\n) {\n  throw new Error('fork-ts-checker-webpack-plugin hooks are already in use');\n}\nthis.compiler.hooks.forkTsCheckerServiceBeforeStart = new AsyncSeriesHook([]);\n\nthis.compiler.hooks.forkTsCheckerCancel = new SyncHook([]);\n// other sync hooks...\nthis.compiler.hooks.forkTsCheckerDone = new SyncHook([]);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you're interested in backwards compatibility then you should use the ",(0,t.jsx)(n.code,{children:"_pluginCompat"})," to wire that in:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler._pluginCompat.tap('fork-ts-checker-webpack-plugin', (options) => {\n  switch (options.name) {\n    case 'fork-ts-checker-service-before-start':\n      options.async = true;\n      break;\n    case 'fork-ts-checker-cancel':\n    // other sync hooks...\n    case 'fork-ts-checker-done':\n      return true;\n  }\n  return undefined;\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With your registration in place, you just need to replace your calls to ",(0,t.jsx)(n.code,{children:"compiler.applyPlugins('sync-hook-name', "})," and ",(0,t.jsx)(n.code,{children:"compiler.applyPluginsAsync('async-hook-name', "})," with calls to ",(0,t.jsx)(n.code,{children:"compiler.hooks.syncHookName.call("})," and ",(0,t.jsx)(n.code,{children:"compiler.hooks.asyncHookName.callAsync("}),". So to migrate our ",(0,t.jsx)(n.code,{children:"fork-ts-checker-service-before-start"})," hook we'd write:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.compiler.hooks.forkTsCheckerServiceBeforeStart.callAsync(() => {\n  // do your thing here\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"loaders",children:"Loaders"}),"\n",(0,t.jsxs)(n.p,{children:["Loaders are impacted by the changes to the plugin architecture. Mostly this means applying the same plugin changes as discussed above. ",(0,t.jsx)(n.code,{children:"ts-loader"})," hooks into 2 plugin events:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"loader._compiler.plugin('after-compile' /* callback goes here */);\nloader._compiler.plugin('watch-run' /* callback goes here */);\n"})}),"\n",(0,t.jsx)(n.p,{children:"With webpack 4 these become:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"loader._compiler.hooks.afterCompile.tapAsync(\n  'ts-loader' /* callback goes here */,\n);\nloader._compiler.hooks.watchRun.tapAsync('ts-loader' /* callback goes here */);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note again, we're using the string ",(0,t.jsx)(n.code,{children:'"ts-loader"'})," to identify our loader."]}),"\n",(0,t.jsxs)(n.h2,{id:"i-need-a-map",children:["I need a ",(0,t.jsx)(n.code,{children:"Map"})]}),"\n",(0,t.jsxs)(n.p,{children:["When I initially ported to webpack 4, ",(0,t.jsx)(n.code,{children:"ts-loader"})," simply wasn't working. In the end I tied this down to problems in our ",(0,t.jsx)(n.code,{children:"watch-run"})," callback. There's 2 things of note here."]}),"\n",(0,t.jsxs)(n.p,{children:["Firstly, as per ",(0,t.jsx)(n.a,{href:"https://github.com/webpack/webpack/releases/tag/v4.0.0-beta.0",children:"the changelog"}),", the ",(0,t.jsx)(n.code,{children:"watch-run"})," hook now has the ",(0,t.jsx)(n.code,{children:"Compiler"})," as the first parameter. Previously this was a subproperty on the supplied ",(0,t.jsx)(n.code,{children:"watching"})," parameter. So swapping over to use the compiler directly was necessary. Incidentally, ",(0,t.jsx)(n.code,{children:"ts-loader"})," previously made use of the ",(0,t.jsx)(n.code,{children:"watching.startTime"})," property that was supplied in webpack's 1, 2 and 3. It seems to be coping without it; so hopefully that's fine."]}),"\n",(0,t.jsxs)(n.p,{children:["Secondly, with webpack 4 it's \"ES2015 all the things!\" That is to say, with webpack now requiring a minimum of node 6, the codebase is free to start using ES2015. So if you're a consumer of ",(0,t.jsx)(n.code,{children:"compiler.fileTimestamps"})," (and ",(0,t.jsx)(n.code,{children:"ts-loader"})," is) then it's time to make a change to cater for the different API that a ",(0,t.jsx)(n.code,{children:"Map"})," offers instead of indexing into an object literal with a ",(0,t.jsx)(n.code,{children:"string"})," key."]}),"\n",(0,t.jsx)(n.p,{children:"What this means is, code that would once have looked like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"Object.keys(watching.compiler.fileTimestamps)\n  .filter(\n    (filePath) =>\n      watching.compiler.fileTimestamps[filePath] > lastTimes[filePath],\n  )\n  .forEach((filePath) => {\n    lastTimes[filePath] = times[filePath];\n    // ...\n  });\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now looks more like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"for (const [filePath, date] of compiler.fileTimestamps) {\n  if (date > lastTimes.get(filePath)) {\n    continue;\n  }\n\n  lastTimes.set(filePath, date);\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"happy-porting",children:"Happy Porting!"}),"\n",(0,t.jsx)(n.p,{children:"I hope your own port to webpack 4 goes well. Do let me know if there's anything I've missed out / any inaccuracies etc and I'll update this guide."})]})}function d(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},50065:function(e,n,o){o.d(n,{Z:function(){return r},a:function(){return a}});var s=o(67294);let t={},i=s.createContext(t);function a(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},78182:function(e){e.exports=JSON.parse('{"permalink":"/finding-webpack-4-use-map","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2018-01-29-finding-webpack-4-use-map/index.md","source":"@site/blog/2018-01-29-finding-webpack-4-use-map/index.md","title":"Finding webpack 4 (use a Map)","description":"webpack 4s new plugin architecture requires migrating from \\"kebab-case\\" to \\"camelCase\\". A migration guide for plugins and loaders is available.","date":"2018-01-29T00:00:00.000Z","tags":[{"inline":false,"label":"webpack","permalink":"/tags/webpack","description":"The webpack module bundler."}],"readingTime":4.55,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"finding-webpack-4-use-map","title":"Finding webpack 4 (use a Map)","authors":"johnnyreilly","tags":["webpack"],"hide_table_of_contents":false,"description":"webpack 4s new plugin architecture requires migrating from \\"kebab-case\\" to \\"camelCase\\". A migration guide for plugins and loaders is available."},"unlisted":false,"prevItem":{"title":"ts-loader 4 / fork-ts-checker-webpack-plugin 0.4","permalink":"/ts-loader-400-fork-ts-checker-webpack"},"nextItem":{"title":"webpack 4 - ts-loader / fork-ts-checker-webpack-plugin betas","permalink":"/webpack-4-ts-loader-fork-ts-checker"}}')}}]);