"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["48914"],{47636:function(e,r,n){n.r(r),n.d(r,{assets:function(){return a},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return c}});var s=n(41054),l=n(85893),t=n(50065);let i={slug:"nullable-reference-types-csharp-strictnullchecks",title:"Nullable reference types; CSharp's very own strictNullChecks",authors:"johnnyreilly",tags:["c#"],hide_table_of_contents:!1,description:"C# introduces nullable reference types similar to TypeScripts `strictNullChecks`. Enabling raises warnings and solves null reference risks."},o=void 0,a={authorsImageUrls:[void 0]},c=[{value:"Turning on nullable reference types",id:"turning-on-nullable-reference-types",level:2},{value:"Fail the build with <code>WarningsAsErrors</code>",id:"fail-the-build-with-warningsaserrors",level:2},{value:"What do they mean?",id:"what-do-they-mean",level:2},{value:"Widening the type to include <code>null</code>",id:"widening-the-type-to-include-null",level:2}];function d(e){let r={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(r.p,{children:["'Tis the season to play with new compiler settings! I'm a very keen TypeScript user and have been merrily using ",(0,l.jsx)(r.a,{href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#--strictnullchecks",children:(0,l.jsx)(r.code,{children:"strictNullChecks"})})," since it shipped. I was dimly aware that C# was also getting a similar feature by the name of ",(0,l.jsx)(r.a,{href:"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/nullable-reference-types",children:"nullable reference types"}),"."]}),"\n",(0,l.jsx)(r.p,{children:"It's only now that I've got round to taking at look at this marvellous feature. I thought I'd share what moving to nullable reference types looked like for me; and what code changes I found myself making as a consequence."}),"\n",(0,l.jsx)(r.h2,{id:"turning-on-nullable-reference-types",children:"Turning on nullable reference types"}),"\n",(0,l.jsxs)(r.p,{children:["To turn on nullable reference types in a C# project you should pop open the ",(0,l.jsx)(r.code,{children:".csproj"})," file and ensure it contains a ",(0,l.jsx)(r.code,{children:"<Nullable>enable</Nullable>"}),". So if you had a .NET Core 3.1 codebase it might look like this:"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-xml",children:"<PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n    <Nullable>enable</Nullable>\n</PropertyGroup>\n"})}),"\n",(0,l.jsx)(r.p,{children:"When you compile from this point forward, possible null reference types are reported as warnings. Consider this C#:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-cs",children:'[ApiController]\npublic class UserController : ControllerBase\n{\n    private readonly ILogger<UserController> _logger;\n\n    public UserController(ILogger<UserController> logger)\n    {\n        _logger = logger;\n    }\n\n    [AllowAnonymous]\n    [HttpGet("UserName")]\n    public string GetUserName()\n    {\n        if (User.Identity.IsAuthenticated) {\n            _logger.LogInformation("{User} is getting their username", User.Identity.Name);\n            return User.Identity.Name;\n        }\n\n        _logger.LogInformation("The user is not authenticated");\n        return null;\n    }\n}\n'})}),"\n",(0,l.jsxs)(r.p,{children:["A ",(0,l.jsx)(r.code,{children:"dotnet build"})," results in this:"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-shell",children:"dotnet build --configuration release\n\nMicrosoft (R) Build Engine version 16.7.1+52cd83677 for .NET\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Determining projects to restore...\n  Restored /Users/jreilly/code/app/src/server-app/Server/app.csproj (in 471 ms).\nControllers/UserController.cs(38,24): warning CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\nControllers/UserController.cs(42,20): warning CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\n  app -> /Users/jreilly/code/app/src/server-app/Server/bin/release/netcoreapp3.1/app.dll\n  app -> /Users/jreilly/code/app/src/server-app/Server/bin/release/netcoreapp3.1/app.Views.dll\n\nBuild succeeded.\n\nControllers/UserController.cs(38,24): warning CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\nControllers/UserController.cs(42,20): warning CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\n    2 Warning(s)\n    0 Error(s)\n"})}),"\n",(0,l.jsxs)(r.p,{children:["You see the two ",(0,l.jsx)(r.code,{children:'"Possible null reference return."'})," warnings? Bingo"]}),"\n",(0,l.jsxs)(r.h2,{id:"fail-the-build-with-warningsaserrors",children:["Fail the build with ",(0,l.jsx)(r.code,{children:"WarningsAsErrors"})]}),"\n",(0,l.jsxs)(r.p,{children:["This is good - information is being surfaced up. But it's a warning. I could ignore it. I like compilers to get really up in my face and force me to make a change. I'm not into warnings; I'm into errors. Know what works for you. If you're similarly minded, you can upgrade nullable reference warnings to errors by tweaking the ",(0,l.jsx)(r.code,{children:".csproj"})," a touch further. Add yourself a ",(0,l.jsx)(r.code,{children:"<WarningsAsErrors>nullable</WarningsAsErrors>"})," element. So maybe your ",(0,l.jsx)(r.code,{children:".csproj"})," now looks like this:"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-xml",children:"<PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n    <Nullable>enable</Nullable>\n    <WarningsAsErrors>nullable</WarningsAsErrors>\n</PropertyGroup>\n"})}),"\n",(0,l.jsxs)(r.p,{children:["And a ",(0,l.jsx)(r.code,{children:"dotnet build"})," will result in this:"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-shell",children:"dotnet build --configuration release\n\nMicrosoft (R) Build Engine version 16.7.1+52cd83677 for .NET\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Determining projects to restore...\n  Restored /Users/jreilly/code/app/src/server-app/Server/app.csproj (in 405 ms).\nControllers/UserController.cs(38,24): error CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\nControllers/UserController.cs(42,20): error CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\n\nBuild FAILED.\n\nControllers/UserController.cs(38,24): error CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\nControllers/UserController.cs(42,20): error CS8603: Possible null reference return. [/Users/jreilly/code/app/src/server-app/Server/app.csproj]\n    0 Warning(s)\n    2 Error(s)\n"})}),"\n",(0,l.jsx)(r.p,{children:"Yay! Errors!"}),"\n",(0,l.jsx)(r.h2,{id:"what-do-they-mean",children:"What do they mean?"}),"\n",(0,l.jsxs)(r.p,{children:['"',(0,l.jsx)(r.code,{children:"Possible null reference return"}),"\" isn't the clearest of errors. What does that actually amount to? Well, it amounts to the compiler saying \"you're a liar! (maybe)\". Let's look again at the code where this error is reported:"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-cs",children:'[AllowAnonymous]\n[HttpGet("UserName")]\npublic string GetUserName()\n{\n    if (User.Identity.IsAuthenticated) {\n        _logger.LogInformation("{User} is getting their username", User.Identity.Name);\n        return User.Identity.Name;\n    }\n\n    _logger.LogInformation("The user is not authenticated");\n    return null;\n}\n'})}),"\n",(0,l.jsxs)(r.p,{children:["We're getting that error reported where we're returning ",(0,l.jsx)(r.code,{children:"null"})," and where we're returning ",(0,l.jsx)(r.code,{children:"User.Identity.Name"})," which ",(0,l.jsx)(r.em,{children:"may"})," be ",(0,l.jsx)(r.code,{children:"null"}),". And we're getting that because as far as the compiler is concerned ",(0,l.jsx)(r.code,{children:"string"})," has changed. Before we turned on nullable reference types the compiler considered ",(0,l.jsx)(r.code,{children:"string"})," to mean ",(0,l.jsx)(r.code,{children:"string"})," ",(0,l.jsx)(r.em,{children:"OR"}),(0,l.jsx)(r.code,{children:"null"}),". Now, ",(0,l.jsx)(r.code,{children:"string"})," means ",(0,l.jsx)(r.code,{children:"string"}),"."]}),"\n",(0,l.jsxs)(r.p,{children:["This is the same sort of behaviour as TypeScripts ",(0,l.jsx)(r.code,{children:"strictNullChecks"}),". With TypeScript, before you turn on ",(0,l.jsx)(r.code,{children:"strictNullChecks"}),", as far as the compiler is concerned, ",(0,l.jsx)(r.code,{children:"string"})," means ",(0,l.jsx)(r.code,{children:"string"}),(0,l.jsx)(r.em,{children:"OR"}),(0,l.jsx)(r.code,{children:"null"}),(0,l.jsx)(r.em,{children:"OR"}),(0,l.jsx)(r.code,{children:"undefined"})," (JavaScript didn't feel one null-ish value was enough and so has two - don't ask). Once ",(0,l.jsx)(r.code,{children:"strictNullChecks"})," is on, ",(0,l.jsx)(r.code,{children:"string"})," means ",(0,l.jsx)(r.code,{children:"string"}),"."]}),"\n",(0,l.jsxs)(r.p,{children:["It's a lot clearer. And that's why the compiler is getting antsy. The method signature is ",(0,l.jsx)(r.code,{children:"string"}),", but it can see ",(0,l.jsx)(r.code,{children:"null"})," potentially being returned. It doesn't like it. By and large that's good. We want the compiler to notice this as that's the entire point. We want to catch accidental ",(0,l.jsx)(r.code,{children:"null"}),"s before they hit a user. This is ",(0,l.jsx)(r.em,{children:"great"}),"! However, what do you do if have a method (as we do) that legitimately returns a ",(0,l.jsx)(r.code,{children:"string"})," or ",(0,l.jsx)(r.code,{children:"null"}),"?"]}),"\n",(0,l.jsxs)(r.h2,{id:"widening-the-type-to-include-null",children:["Widening the type to include ",(0,l.jsx)(r.code,{children:"null"})]}),"\n",(0,l.jsx)(r.p,{children:"We change the signature from this:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-cs",children:"public string GetUserName()\n"})}),"\n",(0,l.jsx)(r.p,{children:"To this:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-cs",children:"public string? GetUserName()\n"})}),"\n",(0,l.jsxs)(r.p,{children:["That's right, the simple addition of ",(0,l.jsx)(r.code,{children:"?"})," marks a reference type (like a string) as potentially being ",(0,l.jsx)(r.code,{children:"null"}),". Adding that means that we're potentially returning ",(0,l.jsx)(r.code,{children:"null"}),", but we're sure about it; there's intention here - it's not accidental. Wonderful!"]})]})}function p(e={}){let{wrapper:r}={...(0,t.a)(),...e.components};return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},50065:function(e,r,n){n.d(r,{Z:function(){return o},a:function(){return i}});var s=n(67294);let l={},t=s.createContext(l);function i(e){let r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),s.createElement(t.Provider,{value:r},e.children)}},41054:function(e){e.exports=JSON.parse('{"permalink":"/nullable-reference-types-csharp-strictnullchecks","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2020-12-20-nullable-reference-types-csharp-strictnullchecks/index.md","source":"@site/blog/2020-12-20-nullable-reference-types-csharp-strictnullchecks/index.md","title":"Nullable reference types; CSharp\'s very own strictNullChecks","description":"C# introduces nullable reference types similar to TypeScripts `strictNullChecks`. Enabling raises warnings and solves null reference risks.","date":"2020-12-20T00:00:00.000Z","tags":[{"inline":false,"label":"C#","permalink":"/tags/csharp","description":"The C# programming language."}],"readingTime":3.86,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"nullable-reference-types-csharp-strictnullchecks","title":"Nullable reference types; CSharp\'s very own strictNullChecks","authors":"johnnyreilly","tags":["c#"],"hide_table_of_contents":false,"description":"C# introduces nullable reference types similar to TypeScripts `strictNullChecks`. Enabling raises warnings and solves null reference risks."},"unlisted":false,"prevItem":{"title":"Make Microsoft.Identity.Web respond with 403 forbidden instead of a 302 redirect","permalink":"/how-to-make-azure-ad-403"},"nextItem":{"title":"azure-pipelines-task-lib and isOutput setVariable","permalink":"/azure-pipelines-task-lib-and-isoutput-setvariable"}}')}}]);