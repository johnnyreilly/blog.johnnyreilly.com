"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["42666"],{84458:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return l}});var i=t(17092),r=t(85893),a=t(50065);let o={slug:"dotnet-imemorycache-getorcreatefortimespanasync",title:"IMemoryCache and GetOrCreateForTimeSpanAsync",authors:"johnnyreilly",tags:["asp.net"],description:"IMemoryCache is a tremendous caching mechanism for .NET. This post demonstrates how to write a helper to allow you to get or create an item for a given TimeSpan.",hide_table_of_contents:!1},s=void 0,c={authorsImageUrls:[void 0]},l=[{value:"TimeSpan, TimeSpan Expiration Y&#39;all",id:"timespan-timespan-expiration-yall",level:2}];function h(e){let n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["One thing that ASP.Net Core really got right was caching. ",(0,r.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/aspnet/core/performance/caching/memory",children:(0,r.jsx)(n.code,{children:"IMemoryCache"})})," is a caching implementation that does just what I want."]}),"\n",(0,r.jsx)(n.h2,{id:"timespan-timespan-expiration-yall",children:"TimeSpan, TimeSpan Expiration Y'all"}),"\n",(0,r.jsxs)(n.p,{children:["To make usage of the ",(0,r.jsx)(n.code,{children:"IMemoryCache"})," ",(0,r.jsx)(n.em,{children:"even"})," more lovely I've written an extension method. I follow pretty much one cache strategy: ",(0,r.jsx)(n.code,{children:"SetAbsoluteExpiration"})," and I just vary the expiration by an amount of time. This extension method implements that in a simple way; I call it ",(0,r.jsx)(n.code,{children:"GetOrCreateForTimeSpanAsync"})," - catchy right? It looks like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:"using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Caching.Memory;\n\nnamespace My.Helpers {\n\n    public static class CacheHelpers {\n\n        public static async Task<TItem?> GetOrCreateForTimeSpanAsync<TItem>(\n            this IMemoryCache cache,\n            string key,\n            Func<Task<TItem?>> itemGetterAsync,\n            TimeSpan timeToCache\n        ) {\n            if (!cache.TryGetValue(key, out object? result))\n            {\n                result = await itemGetterAsync();\n                if (result == null)\n                    return default(TItem);\n\n                var cacheEntryOptions = new MemoryCacheEntryOptions()\n                    .SetAbsoluteExpiration(timeToCache);\n\n                cache.Set(key, result, cacheEntryOptions);\n            }\n\n            return (TItem)result;\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Usage looks like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:'private Task<SuperInterestingThing> GetSuperInterestingThingFromCache(Guid superInterestingThingId) =>\n    _cache.GetOrCreateForTimeSpanAsync(\n        key: $"{nameof(MyClass)}:GetSuperInterestingThing:{superInterestingThingId}",\n        itemGetterAsync: () => GetSuperInterestingThing(superInterestingThingId),\n        timeToCache: TimeSpan.FromMinutes(5)\n    );\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Where ",(0,r.jsx)(n.code,{children:"_cache"})," is an instance of ",(0,r.jsx)(n.code,{children:"IMemoryCache"})," that can be dependency injected into your class. This helper allows the consumer to provide three things:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"key"})," key for the item to be cached with"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"itemGetterAsync"})," which is the method that is used to retrieve a new value if an item cannot be found in the cache"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"timeToCache"})," which is the period of time that an item should be cached"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If an item can't be looked up by the ",(0,r.jsx)(n.code,{children:"itemGetterAsync"})," then ",(0,r.jsx)(n.em,{children:"nothing"})," will be cached and a the ",(0,r.jsx)(n.code,{children:"default"})," value of the expected type will be returned. This is important because lookups can fail, and there's nothing worse than a lookup failing and you caching ",(0,r.jsx)(n.code,{children:"null"})," as a result."]}),"\n",(0,r.jsx)(n.p,{children:"Go on, ask me how I know."}),"\n",(0,r.jsxs)(n.p,{children:["This is a simple, clear and helpful API which makes interacting with ",(0,r.jsx)(n.code,{children:"IMemoryCache"})," even more lovely than it was."]})]})}function m(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},50065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return o}});var i=t(67294);let r={},a=i.createContext(r);function o(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},17092:function(e){e.exports=JSON.parse('{"permalink":"/dotnet-imemorycache-getorcreatefortimespanasync","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2018-12-10-dotnet-imemorycache-getorcreatefortimespanasync/index.md","source":"@site/blog/2018-12-10-dotnet-imemorycache-getorcreatefortimespanasync/index.md","title":"IMemoryCache and GetOrCreateForTimeSpanAsync","description":"IMemoryCache is a tremendous caching mechanism for .NET. This post demonstrates how to write a helper to allow you to get or create an item for a given TimeSpan.","date":"2018-12-10T00:00:00.000Z","tags":[{"inline":false,"label":"ASP.NET","permalink":"/tags/asp-net","description":"The web framework built by Microsoft."}],"readingTime":1.565,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"dotnet-imemorycache-getorcreatefortimespanasync","title":"IMemoryCache and GetOrCreateForTimeSpanAsync","authors":"johnnyreilly","tags":["asp.net"],"description":"IMemoryCache is a tremendous caching mechanism for .NET. This post demonstrates how to write a helper to allow you to get or create an item for a given TimeSpan.","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"You Might Not Need thread-loader","permalink":"/you-might-not-need-thread-loader"},"nextItem":{"title":"Snapshot Testing for C#","permalink":"/snapshot-testing-for-c"}}')}}]);