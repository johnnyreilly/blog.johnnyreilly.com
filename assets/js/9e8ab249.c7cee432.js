"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[97305],{1739:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=n(74848),a=n(28453);const s={slug:"unit-testing-angular-controller-with",title:"Unit Testing an Angular Controller with Jasmine",authors:"johnnyreilly",tags:["angularjs","automated testing"],hide_table_of_contents:!1,description:"John shares how they wrote unit tests for an Angular controller in Proverb using Jasmine 2.0, with heavily annotated JavaScript tests."},i=void 0,r={permalink:"/unit-testing-angular-controller-with",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2014-09-10-unit-testing-angular-controller-with/index.md",source:"@site/blog/2014-09-10-unit-testing-angular-controller-with/index.md",title:"Unit Testing an Angular Controller with Jasmine",description:"John shares how they wrote unit tests for an Angular controller in Proverb using Jasmine 2.0, with heavily annotated JavaScript tests.",date:"2014-09-10T00:00:00.000Z",tags:[{inline:!1,label:"Angular JS",permalink:"/tags/angularjs",description:"The original Angular JS framework."},{inline:!1,label:"Automated Testing",permalink:"/tags/automated-testing",description:"How to perform the automation of tests."}],readingTime:7.71,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"unit-testing-angular-controller-with",title:"Unit Testing an Angular Controller with Jasmine",authors:"johnnyreilly",tags:["angularjs","automated testing"],hide_table_of_contents:!1,description:"John shares how they wrote unit tests for an Angular controller in Proverb using Jasmine 2.0, with heavily annotated JavaScript tests."},unlisted:!1,prevItem:{title:"Journalling the Migration of Jasmine Tests to TypeScript",permalink:"/migrating-jasmine-tests-to-typescript"},nextItem:{title:"Running JavaScript Unit Tests in AppVeyor",permalink:"/running-javascript-unit-tests-in-appveyor"}},l={authorsImageUrls:[void 0]},c=[{value:"What I&#39;m Testing",id:"what-im-testing",level:2},{value:"sagesDetail.ts",id:"sagesdetailts",level:3},{value:"sageDetail.js",id:"sagedetailjs",level:3},{value:"Now for the Tests",id:"now-for-the-tests",level:2},{value:"Jasmine tests for sageDetail.js",id:"jasmine-tests-for-sagedetailjs",level:3}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Anyone who reads my blog will know that I have been long in the habit of writing unit tests for my C# code. I'm cool like that. However, it took me a while to get up and running writing unit tests for my JavaScript code. I finally ",(0,o.jsx)(t.a,{href:"/the-surprisingly-happy-tale-of-visual",children:"got there"})," using a combination of Jasmine 2.0 and Chutzpah. (Jasmine being my test framework and Chutzpah being my test runner.)"]}),"\n",(0,o.jsx)(t.p,{children:"I'm getting properly into the habit of testing my JavaScript. I won't pretend it's been particularly fun but I firmly believe it will end up being useful... That's what I tell myself during the long dark tea-times of the soul anyway."}),"\n",(0,o.jsxs)(t.p,{children:["I have a side project called ",(0,o.jsx)(t.a,{href:"https://github.com/johnnyreilly/Proverb",children:"Proverb"}),". It doesn't do anything in particular - for the most part it's a simple application that displays the collected wise sayings of a team that I used to be part of. There's not much to it - a bit of CRUD, a dashboard. Not much more. Because of the project's simplicity it's ideal to use Proverb's underlying idea when trying out new technologies / frameworks. ",(0,o.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Paul_Halmos",children:"The best way to learn is to do"}),'. So if I want to learn "X", then building Proverb using "X" is a good way to go.']}),"\n",(0,o.jsxs)(t.p,{children:["I digress already. I had a version of Proverb built using a combination of ",(0,o.jsx)(t.a,{href:"https://github.com/johnnyreilly/Proverb/tree/master/AngularTypeScript",children:"AngularJS and TypeScript"}),". I had written the Angular side of Proverb without any tests. Now I was able to write JavaScript tests for my Angular code that's just what I set out to do. It should prove something of a of ",(0,o.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Kata_(programming)",children:"Code Kata"})," too."]}),"\n",(0,o.jsx)(t.p,{children:"Whilst I'm at it I thought it might prove helpful if I wrote up how I approached writing unit tests for a single Angular controller. So here goes."}),"\n",(0,o.jsx)(t.h2,{id:"what-im-testing",children:"What I'm Testing"}),"\n",(0,o.jsxs)(t.p,{children:["I have an Angular controller called ",(0,o.jsx)(t.code,{children:"sagesDetail"}),". It powers this screen:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(49812).A+"",width:"640",height:"319",loading:"eager",fetchpriority:"high"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"sagesDetail"})," is a very simple controller. It does these things:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:'Load the "sage" (think of it as just a "user") and make it available on the controller so it can be bound to the view.'}),"\n",(0,o.jsx)(t.li,{children:"Set the view title."}),"\n",(0,o.jsx)(t.li,{children:"Log view activation."}),"\n",(0,o.jsxs)(t.li,{children:["Expose a ",(0,o.jsx)(t.code,{children:"gotoEdit"})," method which, when called, redirects the user to the edit screen."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The controller is written in TypeScript and looks like this:"}),"\n",(0,o.jsx)(t.h3,{id:"sagesdetailts",children:"sagesDetail.ts"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"module controllers {\n  'use strict';\n\n  var controllerId = 'sageDetail';\n\n  interface sageDetailRouteParams extends ng.route.IRouteParamsService {\n    id: string;\n  }\n\n  class SageDetail {\n    log: loggerFunction;\n    sage: sage;\n    title: string;\n\n    static $inject = ['$location', '$routeParams', 'common', 'datacontext'];\n    constructor(\n      private $location: ng.ILocationService,\n      private $routeParams: sageDetailRouteParams,\n      private common: common,\n      private datacontext: datacontext,\n    ) {\n      this.sage = undefined;\n      this.title = 'Sage Details';\n\n      this.log = common.logger.getLogFn(controllerId);\n\n      this.activate();\n    }\n\n    // Prototype methods\n\n    activate() {\n      var id = parseInt(this.$routeParams.id, 10);\n      var dataPromises: ng.IPromise<any>[] = [\n        this.datacontext.sage\n          .getById(id, true)\n          .then((data) => (this.sage = data)),\n      ];\n\n      this.common\n        .activateController(dataPromises, controllerId, this.title)\n        .then(() => {\n          this.log('Activated Sage Details View');\n          this.title = 'Sage Details: ' + this.sage.name;\n        });\n    }\n\n    gotoEdit() {\n      this.$location.path('/sages/edit/' + this.sage.id);\n    }\n  }\n\n  angular.module('app').controller(controllerId, SageDetail);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"When compiled to JavaScript it looks like this:"}),"\n",(0,o.jsx)(t.h3,{id:"sagedetailjs",children:"sageDetail.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"var controllers;\n(function (controllers) {\n  'use strict';\n\n  var controllerId = 'sageDetail';\n\n  var SageDetail = (function () {\n    function SageDetail($location, $routeParams, common, datacontext) {\n      this.$location = $location;\n      this.$routeParams = $routeParams;\n      this.common = common;\n      this.datacontext = datacontext;\n      this.sage = undefined;\n      this.title = 'Sage Details';\n\n      this.log = common.logger.getLogFn(controllerId);\n\n      this.activate();\n    }\n    // Prototype methods\n    SageDetail.prototype.activate = function () {\n      var _this = this;\n      var id = parseInt(this.$routeParams.id, 10);\n      var dataPromises = [\n        this.datacontext.sage.getById(id, true).then(function (data) {\n          return (_this.sage = data);\n        }),\n      ];\n\n      this.common\n        .activateController(dataPromises, controllerId, this.title)\n        .then(function () {\n          _this.log('Activated Sage Details View');\n          _this.title = 'Sage Details: ' + _this.sage.name;\n        });\n    };\n\n    SageDetail.prototype.gotoEdit = function () {\n      this.$location.path('/sages/edit/' + this.sage.id);\n    };\n    SageDetail.$inject = ['$location', '$routeParams', 'common', 'datacontext'];\n    return SageDetail;\n  })();\n\n  angular.module('app').controller(controllerId, SageDetail);\n})(controllers || (controllers = {}));\n//# sourceMappingURL=sageDetail.js.map\n"})}),"\n",(0,o.jsx)(t.h2,{id:"now-for-the-tests",children:"Now for the Tests"}),"\n",(0,o.jsxs)(t.p,{children:["I haven't yet made the move of switching over my Jasmine tests from JavaScript to TypeScript. (It's on my list but there's only so many things you can do at once...) For that reason the tests you'll see here are straight JavaScript. Below you will see the tests for the ",(0,o.jsx)(t.code,{children:"sageDetail"})," controller."]}),"\n",(0,o.jsx)(t.p,{children:"I have put very comments in the test code to make clear the intent to you, dear reader. Annotated the life out of them. Naturally I wouldn't expect a test to be so heavily annotated in a typical test suite - and you can be sure mine normally aren't!"}),"\n",(0,o.jsx)(t.h3,{id:"jasmine-tests-for-sagedetailjs",children:"Jasmine tests for sageDetail.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"describe('Proverb.Web -> app-> controllers ->', function () {\n  // Before each test runs we're going to need ourselves an Angular App to test - go fetch!\n  beforeEach(function () {\n    module('app'); // module is an alias for <a href=\"https://docs.angularjs.org/api/ngMock/function/angular.mock.module\">angular.mock.module</a>\n  });\n\n  // Tests for the sageDetail controller\n  describe('sageDetail ->', function () {\n    // Declare describe-scoped variables\n    var $rootScope,\n      getById_deferred, // deferred used for promises\n      $location,\n      $routeParams_stub,\n      common,\n      datacontext, // controller dependencies\n      sageDetailController; // the controller\n\n    // Before each test runs set up the controller using inject - an alias for <a href=\"https://docs.angularjs.org/api/ngMock/function/angular.mock.inject\">angular.mock.inject</a>\n    beforeEach(inject(function (\n      _$controller_,\n      _$rootScope_,\n      _$q_,\n      _$location_,\n      _common_,\n      _datacontext_,\n    ) {\n      // Note how each parameter is prefixed and suffixed with \"_\" - this an Angular nicety\n      // which allows you to have variables in your tests with the original reference name.\n      // So here we assign the injected parameters to the describe-scoped variables:\n      $rootScope = _$rootScope_;\n      $q = _$q_;\n      $location = _$location_;\n      common = _common_;\n      datacontext = _datacontext_;\n\n      // Our controller has a dependency on an \"id\" property passed on the $routeParams\n      // We're going to stub this out with a JavaScript object literal\n      $routeParams_stub = { id: '10' };\n\n      // Our controller depends on a promise returned from this function: datacontext.sage.getById\n      // Well strictly speaking it also uses a promise for activateController but since the activateController\n      // promise just wraps the getById promise it will be resolved when the getById promise is.\n      // Here we create a deferred representing the getById promise which we can resolve as we need to\n      getById_deferred = $q.defer();\n\n      // set up a spy on datacontext.sage.getById and set it to return the promise of getById_deferred\n      // this allows us to #1 detect that getById has been called\n      // and #2 resolve / reject our promise as our test requires using getById_deferred\n      spyOn(datacontext.sage, 'getById').and.returnValue(\n        getById_deferred.promise,\n      );\n\n      // set up a spy on common.activateController and set it to call through\n      // this allows us to detect that activateController has been called whilst\n      // maintaining existing controller functionality\n      spyOn(common, 'activateController').and.callThrough();\n\n      // set up spys on common.logger.getLogFn and $location.path so we can detect they have been called\n      spyOn(common.logger, 'getLogFn').and.returnValue(\n        jasmine.createSpy('log'),\n      );\n      spyOn($location, 'path').and.returnValue(jasmine.createSpy('path'));\n\n      // create a sageDetail controller and inject the dependencies we have set up\n      sageDetailController = _$controller_('sageDetail', {\n        $location: $location,\n        $routeParams: $routeParams_stub,\n        common: common,\n        datacontext: datacontext,\n      });\n    }));\n\n    // Tests for the controller state at the point of the sageDetail controller's creation\n    // ie before the getById / activateController promises have been resolved\n    // So this tests the constructor (function) and the activate function up to the point\n    // of the promise calls\n    describe('on creation ->', function () {\n      it(\"controller should have a title of 'Sage Details'\", function () {\n        // tests this code has executed:\n        // this.title = \"Sage Details\";\n        expect(sageDetailController.title).toBe('Sage Details');\n      });\n\n      it('controller should have no sage', function () {\n        // tests this code has executed:\n        // this.sage = undefined;\n        expect(sageDetailController.sage).toBeUndefined();\n      });\n\n      it('datacontext.sage.getById should be called', function () {\n        // tests this code has executed:\n        // this.datacontext.sage.getById(id, true)\n        expect(datacontext.sage.getById).toHaveBeenCalledWith(10, true);\n      });\n    });\n\n    // Tests for the controller state at the point of the resolution of the getById promise\n    // ie after the getById / activateController promises have been resolved\n    // So this tests the constructor (function) and the activate function after the point\n    // of the promise calls\n    describe('activateController ->', function () {\n      var sage_stub;\n      beforeEach(function () {\n        // Create a sage stub which will be used when resolving the getById promise\n        sage_stub = { name: 'John' };\n      });\n\n      it('should set sages to be the resolved promise values', function () {\n        // Resolve the getById promise with the sage stub\n        getById_deferred.resolve(sage_stub);\n        $rootScope.$digest(); // So Angular processes the resolved promise\n\n        // tests this code has executed:\n        // this.sage = data\n        expect(sageDetailController.sage).toBe(sage_stub);\n      });\n\n      it(\"should log 'Activated Sage Details View' and set title with name\", function () {\n        // Resolve the getById promise with the sage stub\n        getById_deferred.resolve(sage_stub);\n        $rootScope.$digest(); // So Angular processes the resolved promise\n\n        // tests this code has executed:\n        // this.log(\"Activated Sage Details View\");\n        // this.title = \"Sage Details: \" + this.sage.name;\n        expect(sageDetailController.log).toHaveBeenCalledWith(\n          'Activated Sage Details View',\n        );\n        expect(sageDetailController.title).toBe(\n          'Sage Details: ' + sage_stub.name,\n        );\n      });\n    });\n\n    // Tests for the gotoEdit function on the controller\n    // Note that this will only be called *after* a controller has been created\n    // and it depends upon a sage having first been loaded\n    describe('gotoEdit ->', function () {\n      var sage_stub;\n      beforeEach(function () {\n        // Create a sage stub which will be used when resolving the getById promise\n        sage_stub = { id: 20 };\n      });\n\n      it('should set $location.path to edit URL', function () {\n        // Resolve the getById promise with the sage stub\n        getById_deferred.resolve(sage_stub);\n        $rootScope.$digest(); // So Angular processes the resolved promise\n\n        sageDetailController.gotoEdit();\n\n        // tests this code has executed:\n        // this.$location.path(\"/sages/edit/\" + this.sage.id);\n        expect($location.path).toHaveBeenCalledWith(\n          '/sages/edit/' + sage_stub.id,\n        );\n      });\n    });\n  });\n});\n"})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},49812:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/sageDetailScreen-4bfe2805dcd359ed1871fb34960eeb93.webp"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var o=n(96540);const a={},s=o.createContext(a);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);