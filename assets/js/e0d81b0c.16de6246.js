"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["791"],{80956:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return i},toc:function(){return o}});var i=t(12088),d=t(85893),r=t(50065);let s={slug:"mui-react-tree-view-check-children-uncheck-parents",title:"MUI React Tree View: check children, uncheck parents",authors:"johnnyreilly",tags:["react","mui"],image:"./title-image.png",hide_table_of_contents:!1,description:"Learn how to use the MUI treeview component with behaviour that selects child nodes when parents are select and deselects parent nodes when children are deselected."},l=void 0,c={image:t(86925).Z,authorsImageUrls:[void 0]},o=[{value:"The default behaviour and the desired behaviour",id:"the-default-behaviour-and-the-desired-behaviour",level:2},{value:"The code",id:"the-code",level:2},{value:"Conclusion",id:"conclusion",level:2}];function a(e){let n={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.p,{children:["Every now and then, I need to use a treeview component in a React application. The Material-UI (MUI) library provides a ",(0,d.jsx)(n.a,{href:"https://mui.com/x/react-tree-view/",children:"treeview component"})," that is very useful. However, some of the default behaviours of the component differ from that which you typically find in a treeview component. I'm speaking, of course, about node selection. I'm used to a treeview component that, when a parent node is selected, auto selects the child nodes underneath. And by turn, when nodes are deselected, the parent nodes get deselected."]}),"\n",(0,d.jsx)(n.p,{children:"This post documents how to implement this behaviour with the MUI treeview component."}),"\n",(0,d.jsxs)(n.p,{children:["Since initially writing this, I've learned that it is likely that the kind of behaviour I'm hand-rolling here, will natively land in the component. So, all being well, what follows should become unnecessary! To track native support ",(0,d.jsx)(n.a,{href:"https://github.com/mui/mui-x/issues/12883",children:"watch this GitHub issue"}),"."]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.img,{alt:"title image reading &quot;MUI React Tree View: check children, uncheck parents&quot; with the MUI logo",src:t(30515).Z+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,d.jsx)(n.h2,{id:"the-default-behaviour-and-the-desired-behaviour",children:"The default behaviour and the desired behaviour"}),"\n",(0,d.jsx)(n.p,{children:"By default, the MUI treeview component checks and unchecks nodes individually. Each node is an island; when a node is selected or deselected, it has no bearing on any other nodes."}),"\n",(0,d.jsx)(n.p,{children:"What I'd rather is some relationship between parent and child nodes during selection / deselection. The behaviour I'd like has the following characteristics:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"when a parent node is selected, all child nodes are selected"}),"\n",(0,d.jsx)(n.li,{children:"when a parent node is deselected, all child nodes are deselected"}),"\n",(0,d.jsx)(n.li,{children:"when a child node is deselected, the parent node is deselected, and any children are deselected also"}),"\n",(0,d.jsx)(n.li,{children:"finally, if all children are selected, the parent node should be selected."}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"This is the behaviour that I'm used to in a treeview component. In action it looks like this:"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.img,{alt:"animated gif demonstrating new behaviour",src:t(2147).Z+"",width:"2000",height:"1360",loading:"lazy"})}),"\n",(0,d.jsx)(n.h2,{id:"the-code",children:"The code"}),"\n",(0,d.jsx)(n.p,{children:"We can implement this behaviour by tracking the selected nodes and then determining which nodes should be selected based on the current selection. The code below demonstrates how to do this:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-tsx",children:"import * as React from 'react';\nimport Box from '@mui/material/Box';\nimport { RichTreeView } from '@mui/x-tree-view/RichTreeView';\nimport { TreeViewBaseItem } from '@mui/x-tree-view/models';\n\nconst MUI_X_PRODUCTS: TreeViewBaseItem[] = [\n  {\n    id: 'grid',\n    label: 'Data Grid',\n    children: [\n      { id: 'grid-community', label: '@mui/x-data-grid' },\n      { id: 'grid-pro', label: '@mui/x-data-grid-pro' },\n      { id: 'grid-premium', label: '@mui/x-data-grid-premium' },\n    ],\n  },\n  {\n    id: 'pickers',\n    label: 'Date and Time Pickers',\n    children: [\n      { id: 'pickers-community', label: '@mui/x-date-pickers' },\n      { id: 'pickers-pro', label: '@mui/x-date-pickers-pro' },\n    ],\n  },\n  {\n    id: 'charts',\n    label: 'Charts',\n    children: [{ id: 'charts-community', label: '@mui/x-charts' }],\n  },\n  {\n    id: 'tree-view',\n    label: 'Tree View',\n    children: [{ id: 'tree-view-community', label: '@mui/x-tree-view' }],\n  },\n];\n\nfunction getParentNode(\n  items: TreeViewBaseItem[],\n  id: string,\n): TreeViewBaseItem | undefined {\n  for (const item of items) {\n    if (item.children) {\n      if (item.children.some((child) => child.id === id)) {\n        // The current item is the parent of the supplied id\n        return item;\n      } else {\n        // Recursively call the function for the children of the current item\n        const parentNode = getParentNode(item.children, id);\n        if (parentNode) {\n          return parentNode;\n        }\n      }\n    }\n  }\n\n  // No parent found\n  return undefined;\n}\n\nfunction getAllParentIds(items: TreeViewBaseItem[], id: string) {\n  const parentIds: string[] = [];\n  let parent = getParentNode(items, id);\n  while (parent) {\n    parentIds.push(parent.id);\n    parent = getParentNode(items, parent.id);\n  }\n  return parentIds;\n}\n\nfunction getSelectedIdsAndChildrenIds(\n  items: TreeViewBaseItem[],\n  selectedIds: string[],\n) {\n  const selectedIdIncludingChildrenIds = new Set([...selectedIds]);\n\n  for (const item of items) {\n    if (selectedIds.includes(item.id)) {\n      // Add the current item's id to the result array\n      selectedIdIncludingChildrenIds.add(item.id);\n\n      // Recursively call the function for the children of the current item\n      if (item.children) {\n        const childrenIds = item.children.map((child) => child.id);\n        const childrenSelectedIds = getSelectedIdsAndChildrenIds(\n          item.children,\n          childrenIds,\n        );\n        childrenSelectedIds.forEach((selectedId) =>\n          selectedIdIncludingChildrenIds.add(selectedId),\n        );\n      }\n    } else if (item.children) {\n      // walk the children to see if selections lay in there also\n      const childrenSelectedIds = getSelectedIdsAndChildrenIds(\n        item.children,\n        selectedIds,\n      );\n      childrenSelectedIds.forEach((selectedId) =>\n        selectedIdIncludingChildrenIds.add(selectedId),\n      );\n    }\n  }\n\n  return [...Array.from(selectedIdIncludingChildrenIds)];\n}\n\nfunction determineIdsToSet(\n  items: TreeViewBaseItem[],\n  newIds: string[],\n  currentIds: string[],\n) {\n  const isDeselectingNode = currentIds.length > newIds.length;\n  if (isDeselectingNode) {\n    const removed = currentIds.filter((id) => !newIds.includes(id))[0];\n\n    const parentIdsToRemove = getAllParentIds(items, removed);\n\n    const childIdsToRemove = getSelectedIdsAndChildrenIds(items, [removed]);\n\n    const newIdsWithParentsAndChildrenRemoved = newIds.filter(\n      (id) => !parentIdsToRemove.includes(id) && !childIdsToRemove.includes(id),\n    );\n\n    return newIdsWithParentsAndChildrenRemoved;\n  }\n\n  const added = newIds.filter((id) => !currentIds.includes(id))[0];\n  const idsToSet = getSelectedIdsAndChildrenIds(items, newIds);\n  let parent = getParentNode(items, added);\n  while (parent) {\n    const childIds = parent.children?.map((node) => node.id) ?? [];\n    const allChildrenSelected = childIds.every((id) => idsToSet.includes(id));\n    if (allChildrenSelected) {\n      idsToSet.push(parent.id);\n      parent = getParentNode(items, parent.id);\n    } else {\n      break;\n    }\n  }\n  return idsToSet;\n}\n\nexport default function CheckboxSelection() {\n  const [selectedIds, setSelectedIds] = React.useState<string[]>([]);\n\n  const handleSelectedItemsChange = (\n    _event: React.SyntheticEvent,\n    ids: string[],\n  ) => {\n    setSelectedIds(determineIdsToSet(MUI_X_PRODUCTS, ids, selectedIds));\n  };\n\n  return (\n    <Box sx={{ height: 264, flexGrow: 1, maxWidth: 400 }}>\n      <RichTreeView\n        defaultExpandedItems={MUI_X_PRODUCTS.map((x) => x.id)}\n        multiSelect={true}\n        checkboxSelection={true}\n        selectedItems={selectedIds}\n        onSelectedItemsChange={handleSelectedItemsChange}\n        items={MUI_X_PRODUCTS}\n      />\n    </Box>\n  );\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["You'll see above that we're using the ",(0,d.jsx)(n.code,{children:"RichTreeView"})," component from ",(0,d.jsx)(n.code,{children:"@mui/x-tree-view"}),". We're setting it to ",(0,d.jsx)(n.code,{children:"multiSelect"})," and ",(0,d.jsx)(n.code,{children:"checkboxSelection"})," to allow for multiple selections and to show checkboxes next to each node. We're also tracking the selected nodes in the ",(0,d.jsx)(n.code,{children:"selectedIds"})," state variable."]}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"handleSelectedItemsChange"})," function is called whenever the selection changes. It determines which nodes should be selected based on the current selection and the new selection. The ",(0,d.jsx)(n.code,{children:"determineIdsToSet"})," function is responsible for this logic."]}),"\n",(0,d.jsx)(n.p,{children:"The first thing it does is determine if a node is being deselected or selected, by comparing the length of the current selection with the new selection. If a node is being deselected, it finds the parent and child nodes of the deselected node and removes them from the new selection. If a node is being selected, it selects all the children of that node. It also finds the parent node and checks if all child nodes are selected. If they are, it selects the parent node."}),"\n",(0,d.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,d.jsx)(n.p,{children:"The code above demonstrates how to implement a treeview component with parent-child node selection behaviour. This behaviour is, in my opinion, more intuitive and user-friendly than the default behaviour of the MUI treeview component."}),"\n",(0,d.jsxs)(n.p,{children:["You can also see this code in action ",(0,d.jsx)(n.a,{href:"https://stackblitz.com/edit/mui-react-tree-view-check-children-uncheck-parents?file=Demo.tsx",children:"on StackBlitz"}),"."]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}},86925:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/title-image-0461be933e2465270577c307ebf0afd5.png"},30515:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/title-image-0461be933e2465270577c307ebf0afd5.png"},2147:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/treeview-demo-951556826e0d9183d1fa0aa14e99ec2d.gif"},50065:function(e,n,t){t.d(n,{Z:function(){return l},a:function(){return s}});var i=t(67294);let d={},r=i.createContext(d);function s(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},12088:function(e){e.exports=JSON.parse('{"permalink":"/mui-react-tree-view-check-children-uncheck-parents","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2024-05-25-mui-react-tree-view-check-children-uncheck-parents/index.md","source":"@site/blog/2024-05-25-mui-react-tree-view-check-children-uncheck-parents/index.md","title":"MUI React Tree View: check children, uncheck parents","description":"Learn how to use the MUI treeview component with behaviour that selects child nodes when parents are select and deselects parent nodes when children are deselected.","date":"2024-05-25T00:00:00.000Z","tags":[{"inline":false,"label":"React","permalink":"/tags/react","description":"The React library."},{"inline":false,"label":"MUI","permalink":"/tags/mui","description":"The MUI / Material UI component library."}],"readingTime":4.98,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"mui-react-tree-view-check-children-uncheck-parents","title":"MUI React Tree View: check children, uncheck parents","authors":"johnnyreilly","tags":["react","mui"],"image":"./title-image.png","hide_table_of_contents":false,"description":"Learn how to use the MUI treeview component with behaviour that selects child nodes when parents are select and deselects parent nodes when children are deselected."},"unlisted":false,"prevItem":{"title":"Dual Publishing ESM and CJS Modules with tsup and Are the Types Wrong?","permalink":"/dual-publishing-esm-cjs-modules-with-tsup-and-are-the-types-wrong"},"nextItem":{"title":"Serialising ASP.NET method calls for later execution","permalink":"/serialising-aspnet-method-calls-for-later-execution"}}')}}]);