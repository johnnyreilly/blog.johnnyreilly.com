"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[8749],{115:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/RTL-9.1.2-4958d9388edcebc443db644b11100c15.webp"},17359:e=>{e.exports=JSON.parse('{"permalink":"/symbiotic-definitely-typed","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2019-08-17-symbiotic-definitely-typed/index.md","source":"@site/blog/2019-08-17-symbiotic-definitely-typed/index.md","title":"Symbiotic Definitely Typed","description":"New approach by `react-testing-library` improves TypeScript experience. Type definitions are maintained separately for `@testing-library/react`.","date":"2019-08-17T00:00:00.000Z","tags":[{"inline":false,"label":"Definitely Typed","permalink":"/tags/definitely-typed","description":"The Definitely Typed project for TypeScript type definitions"},{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."}],"readingTime":6.26,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"symbiotic-definitely-typed","title":"Symbiotic Definitely Typed","authors":"johnnyreilly","tags":["definitely typed","typescript"],"hide_table_of_contents":false,"description":"New approach by `react-testing-library` improves TypeScript experience. Type definitions are maintained separately for `@testing-library/react`."},"unlisted":false,"prevItem":{"title":"Coming Soon: Definitely Typed","permalink":"/coming-soon-definitely-typed"},"nextItem":{"title":"ASP.NET Core authentication: hard-coding a claim in development","permalink":"/asp-net-authentication-hard-coding-claims"}}')},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>a});var n=i(96540);const s={},o=n.createContext(s);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(o.Provider,{value:t},e.children)}},28493:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/hang-on-lads-ive-got-a-great-idea-d944cc3f086e9be5f2bab9d4b8d005dc.webp"},38066:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>n,toc:()=>l});var n=i(17359),s=i(74848),o=i(28453);const r={slug:"symbiotic-definitely-typed",title:"Symbiotic Definitely Typed",authors:"johnnyreilly",tags:["definitely typed","typescript"],hide_table_of_contents:!1,description:"New approach by `react-testing-library` improves TypeScript experience. Type definitions are maintained separately for `@testing-library/react`."},a=void 0,d={authorsImageUrls:[void 0]},l=[{value:"Update: Use a Loose Version Range in <code>package.json</code>",id:"update-use-a-loose-version-range-in-packagejson",level:2},{value:"Updated 2: Further Discussions!",id:"updated-2-further-discussions",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:'I did ponder calling this post "how to enable a good TypeScript developer experience for npm modules that aren\'t written in TypeScript"... Not exactly pithy though.'}),"\n",(0,s.jsx)(t.p,{children:"Definitely Typed is the resource which allows developers to use TypeScript with existing JavaScript libraries that ship without their own type definitions."}),"\n",(0,s.jsxs)(t.p,{children:["DT began as a way to enable interop between JS and TS. When DT started, everything on npm was JavaScript. Over time it has become more common for libraries (eg ",(0,s.jsx)(t.a,{href:"https://github.com/mobxjs/mobx",children:"Mobx"})," / ",(0,s.jsx)(t.a,{href:"https://github.com/angular/angular",children:"Angular"}),") to be written (or rewritten) in TypeScript. For publishing, they are compiled down to JS with perfect type definitions generated from the TypeScript alongside the compiled JavaScript. These libraries do not need to exist in Definitely Typed anymore."]}),"\n",(0,s.jsxs)(t.p,{children:["Another pattern that has emerged over time is that of type definitions being removed from Definitely Typed to live and be maintained alongside the libraries they support. An example of this is ",(0,s.jsx)(t.a,{href:"https://github.com/moment/moment",children:"MomentJS"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["This week, I think for the first time, there emerged another approach. ",(0,s.jsx)(t.a,{href:"https://kentcdodds.com/",children:"Kent C Dodds"}),"' ",(0,s.jsx)(t.code,{children:"react-testing-library"})," had started out with the MomentJS approach of hosting type definitions alongside the JavaScript source code. ",(0,s.jsx)(t.a,{href:"https://github.com/testing-library/react-testing-library/pull/437",children:"Alex Krolic raised a PR which proposed removing the type definitions from the RTL repo in favor of having the community maintain them at DefinitelyTyped."})]}),"\n",(0,s.jsx)(t.p,{children:"I'll directly quote Kent's explanation of the motivation for this:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"We were getting a lot of drive-by contributions to the TypeScript typings and many pull requests would either sit without being reviewed by someone who knows TypeScript well enough, or be merged by a maintainer who just hoped the contributor knew what they were doing. This resulted in a poor experience for TypeScript users who could experience type definition churn and delays, and it became a burden on project maintainers as well (most of us don't know TypeScript very well). Moving the type definitions to DefinitelyTyped puts the maintenance in much more capable hands."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"I have to admit I was reticent about this idea in the first place. I like the idea that types ship with the package they support. It's a good developer experience; users install your package and it works with TypeScript straight out of the box. However Alex's PR addressed a real issue: what do you do when the authors of a package aren't interested / equipped / don't have the time to support TypeScript? Or don't want to deal with the noise of TypeScript related PRs which aren't relevant to them. What then?"}),"\n",(0,s.jsx)(t.p,{children:"Alex was saying, let's not force it. Let the types and the library be maintained separately. This can and is done well already; React is a case in point. The React team does not work on the type definitions for React, that's done (excellently) by a crew of dedicated React lovers in Definitely Typed."}),"\n",(0,s.jsxs)(t.p,{children:["It's a fair point. The thing that was sad about this move was that the developer experience was going to have more friction. Users would have to ",(0,s.jsx)(t.code,{children:"yarn add -D @testing-library/react"})," and then subsequently ",(0,s.jsx)(t.code,{children:"yarn add -D @types/testing-library__react"})," to get the types."]}),"\n",(0,s.jsxs)(t.p,{children:["This two step process isn't the end of the world, but it does make it marginally harder for TypeScript users to get up and running. It reduces the developer joy. As a side note, this is made more unlovely by ",(0,s.jsx)(t.code,{children:"@testing-library/react"})," being a scoped package. ",(0,s.jsx)(t.a,{href:"https://stackoverflow.com/questions/47296731/how-can-i-install-typescript-declarations-for-scoped-namespaced-packages-via-ty",children:"Types for a scoped package have a quirky convention for publishing."})," A fictional scoped package of ",(0,s.jsx)(t.code,{children:"@foo/bar"})," would be published to npm as: ",(0,s.jsx)(t.code,{children:"@types/foo__bar"}),". This is functional but non-obvious; it's tricky to discover. A two step process instead of a one step process is a non-useful friction that it would be great to eliminate."]}),"\n",(0,s.jsxs)(t.p,{children:["Fortunately, Kent and ",(0,s.jsx)(t.a,{href:"https://github.com/FredyC",children:"Daniel K"})," had one of these moments:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:i(28493).A+"",width:"640",height:"271",loading:"lazy"})}),"\n",(0,s.jsxs)(t.p,{children:["Kent suggested that at the same time as dropping the type definitions that were shipped with the library, we try making ",(0,s.jsx)(t.code,{children:"@types/testing-library__react"})," a dependency of ",(0,s.jsx)(t.code,{children:"@testing-library/react"}),". This would mean that people installing ",(0,s.jsx)(t.code,{children:"@testing-library/react"})," would get ",(0,s.jsx)(t.code,{children:"@types/testing-library__react"})," installed ",(0,s.jsx)(t.em,{children:"automatically"}),". So from the developers point of view, it's as though the type definitions shipped with the package directly."]}),"\n",(0,s.jsxs)(t.p,{children:["To cut a long story short reader, that's what happened. If you're using ",(0,s.jsx)(t.code,{children:"@testing-library/react"})," from 9.1.2 you're getting Definitely Typed under the covers. This was ",(0,s.jsx)(t.a,{href:"https://github.com/testing-library/react-testing-library/pull/437#issuecomment-521763117",children:"nicely illustrated by Kent"})," showing what the TypeScript consumption experience looked like before the Definitely Typed switch:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:i(54770).A+"",width:"640",height:"385",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"And here's what it looked like after:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:i(115).A+"",width:"640",height:"403",loading:"lazy"})}),"\n",(0,s.jsx)(t.p,{children:"Identical! i.e it worked. I grant you this is one of the more boring before / after comparisons there is\u2026 But hopefully you can see it demonstrates that this is giving us exactly what we need."}),"\n",(0,s.jsx)(t.p,{children:"To quote Kent once more:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"By adding the type definitions to the dependencies of React Testing Library, the experience for users is completely unchanged. So it's a huge improvement for the maintenance of the type definitions without any breaking changes for the users of those definitions."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This is clearly an approach that's useful; it adds value. It would be tremendous to see other libraries that aren't written in TypeScript but would like to enable a good TypeScript experience for those people that do use TS also adopting this approach."}),"\n",(0,s.jsxs)(t.h2,{id:"update-use-a-loose-version-range-in-packagejson",children:["Update: Use a Loose Version Range in ",(0,s.jsx)(t.code,{children:"package.json"})]}),"\n",(0,s.jsxs)(t.p,{children:["When I ",(0,s.jsx)(t.a,{href:"https://twitter.com/johnny_reilly/status/1162843916661592064",children:"tweeted this article"})," it prompted this helpful response from ",(0,s.jsx)(t.a,{href:"https://twitter.com/atcb",children:"Andrew Branch"})," of the TypeScript team:"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"> use a loose version range This is my advice as well and should probably be mentioned in the article TBH."}),"\n",(0,s.jsxs)(t.p,{children:["\u2014 Kent C. Dodds (@kentcdodds) ",(0,s.jsx)(t.a,{href:"https://twitter.com/kentcdodds/status/1162876792287293440?ref_src=twsrc%5Etfw",children:"August 18, 2019"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Andrew makes the useful point that if you are adding support for TypeScript via an ",(0,s.jsx)(t.code,{children:"@types/..."})," dependency then it's wise to do so with a loose version range. ",(0,s.jsx)(t.a,{href:"https://github.com/testing-library/react-testing-library/blob/c4ba755e42938018ec67dbc716037cfafca15e03/package.json#L46",children:"In the case of RTL we did it like this:"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'"@types/testing-library__react": "^9.1.0"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["i.e. Any type definition with a version of ",(0,s.jsx)(t.code,{children:"9.1"})," or greater (whilst still lower than ",(0,s.jsx)(t.code,{children:"10.0.0"}),") is considered valid. You could go even looser than that. If you really don't want to think about TypeScript beyond adding the dependency then a completely loose version range would do:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'"@types/testing-library__react": "*"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This will always install the latest version of the ",(0,s.jsx)(t.code,{children:"@types/testing-library__react"})," dependency and (importantly) allow users to override if there's a problematic ",(0,s.jsx)(t.code,{children:"@types/testing-library__react"})," out there. This level of looseness is not really advised though. As in the scenario when a library (and associated type definitions) do a major release, users of the old major would get the wrong definitions by default when installing or upgrading (in range)."]}),"\n",(0,s.jsxs)(t.p,{children:["Probably the most helpful approach is the approach followed by RTL; fixing the major version but allowing all minor and patch releases ",(0,s.jsx)(t.em,{children:"inside"})," a major version."]}),"\n",(0,s.jsx)(t.h2,{id:"updated-2-further-discussions",children:"Updated 2: Further Discussions!"}),"\n",(0,s.jsxs)(t.p,{children:["The technique used in this blog post sparked an interesting conversation with members of the TypeScript team when it was applied to ",(0,s.jsx)(t.a,{href:"https://github.com/testing-library/jest-dom",children:(0,s.jsx)(t.code,{children:"https://github.com/testing-library/jest-dom"})}),". ",(0,s.jsx)(t.a,{href:"https://github.com/testing-library/jest-dom/issues/123#issuecomment-523586977",children:"The conversation can be read here"}),"."]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},54770:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/RTL-9.1.1-c05d16d3b7193ffdf9e5bfc2debc980f.webp"}}]);