"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[80923],{24030:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=t(74848),s=t(28453);const a={slug:"using-webpacks-defineplugin-with-typescript",title:"Understanding webpack's DefinePlugin (and using with TypeScript)",description:"webpack's DefinePlugin allows you to create global constants which can be configured at compile time; here's how to use it with TypeScript",authors:"johnnyreilly",tags:["webpack","typescript"],hide_table_of_contents:!1},o=void 0,l={permalink:"/using-webpacks-defineplugin-with-typescript",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2016-07-23-using-webpacks-defineplugin-with-typescript/index.md",source:"@site/blog/2016-07-23-using-webpacks-defineplugin-with-typescript/index.md",title:"Understanding webpack's DefinePlugin (and using with TypeScript)",description:"webpack's DefinePlugin allows you to create global constants which can be configured at compile time; here's how to use it with TypeScript",date:"2016-07-23T00:00:00.000Z",tags:[{label:"webpack",permalink:"/tags/webpack"},{label:"typescript",permalink:"/tags/typescript"}],readingTime:2.47,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"using-webpacks-defineplugin-with-typescript",title:"Understanding webpack's DefinePlugin (and using with TypeScript)",description:"webpack's DefinePlugin allows you to create global constants which can be configured at compile time; here's how to use it with TypeScript",authors:"johnnyreilly",tags:["webpack","typescript"],hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"The Ternary Operator <3 Destructuring",permalink:"/the-ternary-operator-meets-destructuring"},nextItem:{title:"Creating an ES2015 Map from an Array in TypeScript",permalink:"/create-es2015-map-from-array-in-typescript"}},r={authorsImageUrls:[void 0]},c=[{value:"What Globals?",id:"what-globals",level:2},{value:"Configuring our Globals",id:"configuring-our-globals",level:2},{value:"TypeScript and Define",id:"typescript-and-define",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["I've been searching for a way to describe what the DefinePlugin actually does. The ",(0,i.jsx)(n.a,{href:"https://github.com/webpack/docs/wiki/list-of-plugins#defineplugin",children:"docs"})," say:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Define free variables. Useful for having development builds with debug logging or adding global constants."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["I think I would describe it like this: the DefinePlugin allows you to create global constants which can be ",(0,i.jsx)(n.em,{children:"configured at compile time"}),". I find this very useful for allowing different behaviour between development builds and release builds. This post will demonstrate usage of this approach, talk about what's actually happening and how to get this working nicely with TypeScript."]}),"\n",(0,i.jsx)(n.h2,{id:"what-globals",children:"What Globals?"}),"\n",(0,i.jsxs)(n.p,{children:["For our example we want to define 2 global constants; a string called ",(0,i.jsx)(n.code,{children:"__VERSION__"})," and a boolean called ",(0,i.jsx)(n.code,{children:"__IN_DEBUG__"}),'. The names are deliberately wacky to draw attention to the fact that these are not your everyday, common-or-garden variables. Them\'s "special". These constants will be initialised with different values depending on whether we are in a debug build or a production build. Usage of these constants in our code might look like this:']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"if (__IN_DEBUG__) {\n  console.log(`This app is version ${__VERSION__}`);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So, if ",(0,i.jsx)(n.code,{children:"__IN_DEBUG__"})," is set to ",(0,i.jsx)(n.code,{children:"true"})," this code would log out to the console the version of the app."]}),"\n",(0,i.jsx)(n.h2,{id:"configuring-our-globals",children:"Configuring our Globals"}),"\n",(0,i.jsx)(n.p,{children:"To introduce these constants to webpack we're going to add this to our webpack configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"var webpack = require('webpack');\n\n// ...\n\nplugins: [\n  new webpack.DefinePlugin({\n    __IN_DEBUG__: JSON.stringify(false),\n    __VERSION__: JSON.stringify('1.0.0.' + Date.now()),\n  }),\n  // ...\n];\n// ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["What's going on here? Well, each key of the object literal above represents one of our global constants. When you look at the value, just imagine each outer ",(0,i.jsx)(n.code,{children:"JSON.stringify( ... )"})," is not there. It's just noise. Imagine instead that you're seeing this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"__IN_DEBUG__: false,\n__VERSION__: '1.0.0.' + Date.now()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A little clearer, right? ",(0,i.jsx)(n.code,{children:"__IN_DEBUG__"})," is given the boolean value ",(0,i.jsx)(n.code,{children:"false"})," and ",(0,i.jsx)(n.code,{children:"__VERSION__"})," is given the string value of ",(0,i.jsx)(n.code,{children:"1.0.0."})," plus the ticks off of ",(0,i.jsx)(n.code,{children:"Date.now()"}),". What's happening here is well explained in Pete Hunt's excellent ",(0,i.jsx)(n.a,{href:"https://github.com/petehunt/webpack-howto#6-feature-flags",children:"webpack howto"}),': "definePlugin takes raw strings and inserts them". ',(0,i.jsx)(n.code,{children:"JSON.stringify"})," facilitates this; it produces a string representation of a value that can be inlined into code. When the inlining takes place the actual output would be something like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"if (false) {\n  // Because at compile time, __IN_DEBUG__ === false\n  console.log(`This app is version ${'1.0.0.1469268116580'}`); // And __VERSION__ === \"1.0.0.1469268116580\"\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And if you've got some ",(0,i.jsx)(n.a,{href:"https://github.com/mishoo/UglifyJS",children:"UglifyJS"})," or similar in the mix then, in the example above, this would actually strip out the statement above entirely since it's clearly a ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/NOP",children:"NOOP"}),". Yay the dead code removal! If ",(0,i.jsx)(n.code,{children:"__IN_DEBUG__"})," was ",(0,i.jsx)(n.code,{children:"false"})," then (perhaps obviously) this statement would be left in place as it wouldn't be dead code."]}),"\n",(0,i.jsx)(n.h2,{id:"typescript-and-define",children:"TypeScript and Define"}),"\n",(0,i.jsx)(n.p,{children:"The final piece of the puzzle is making TypeScript happy. It doesn't know anything about our global constants. So we need to tell it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"declare var __IN_DEBUG__: boolean;\ndeclare var __VERSION__: string;\n"})}),"\n",(0,i.jsx)(n.p,{children:"And that's it. Compile time constants are a go!"})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(96540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);