"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[14694],{8890:e=>{e.exports=JSON.parse('{"permalink":"/striving-for-javascript-convention","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2012-03-12-striving-for-javascript-convention/index.md","source":"@site/blog/2012-03-12-striving-for-javascript-convention/index.md","title":"Striving for (JavaScript) Convention","description":"Visual Studio 11 beta resolved issues. John has moved away from Hungarian Notation but retained using \\"$\\" as a prefix for jQuery objects.","date":"2012-03-12T00:00:00.000Z","tags":[{"inline":false,"label":"JavaScript","permalink":"/tags/javascript","description":"The JavaScript programming language."}],"readingTime":9.76,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"striving-for-javascript-convention","title":"Striving for (JavaScript) Convention","authors":"johnnyreilly","tags":["javascript"],"hide_table_of_contents":false,"description":"Visual Studio 11 beta resolved issues. John has moved away from Hungarian Notation but retained using \\"$\\" as a prefix for jQuery objects."},"unlisted":false,"prevItem":{"title":"Using the PubSub / Observer pattern to emulate constructor chaining without cluttering up global scope","permalink":"/using-pubsub-observer-pattern-to"},"nextItem":{"title":"jQuery Unobtrusive Remote Validation","permalink":"/jquery-unobtrusive-remote-validation"}}')},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(96540);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},68785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var a=n(8890),i=n(74848),o=n(28453);const s={slug:"striving-for-javascript-convention",title:"Striving for (JavaScript) Convention",authors:"johnnyreilly",tags:["javascript"],hide_table_of_contents:!1,description:'Visual Studio 11 beta resolved issues. John has moved away from Hungarian Notation but retained using "$" as a prefix for jQuery objects.'},r=void 0,l={authorsImageUrls:[void 0]},h=[{value:"Update",id:"update",level:2},{value:"1. Dynamic typing",id:"1-dynamic-typing",level:3}];function d(e){const t={a:"a",code:"code",del:"del",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"update",children:"Update"}),"\n",(0,i.jsxs)(t.p,{children:["The speed of change makes fools of us all. Since I originally wrote this post all of 3 weeks ago Visual Studio 11 beta has been released and the issues I was seeking to solve have pretty much been resolved by the new innovations found therein. It's nicely detailed in ",(0,i.jsx)(t.a,{href:"http://www.twitter.com/carlbergenhem",children:"@carlbergenhem"}),"'s blog post: ",(0,i.jsx)(t.a,{href:"https://blogs.telerik.com/blogs/posts/12-03-26/my-top-5-visual-studio-11-designer-improvements-for-asp-net-4-5-development.aspx",children:"My Top 5 Visual Studio 11 Designer Improvements for ASP.NET 4.5 Development"}),". I've left the post in place below but much of what I said (particularly with regard to Hungarian Notation) I've now moved away from. That was originally my intention anyway so that's no bad thing. The one HN artefact that I've held onto is using \"$\" as a prefix for jQuery objects. I think that still makes sense. I would have written my first line of JavaScript in probably 2000. It probably looked something like this: ",(0,i.jsx)(t.code,{children:"alert('hello world')"}),". I know. Classy. As I've mentioned before it was around 2010 before I took JavaScript in any way seriously. Certainly it was then when I started to actively learn the language. Because up until this point I'd been studiously avoiding writing any JavaScript at all I'd never really given thought to forms and conventions. When I wrote any JavaScript I just used the same style and approaches as I used in my main development language (of C#). By and large I have been following the .net naming conventions which are ably explained by Pete Brown ",(0,i.jsx)(t.a,{href:"http://10rem.net/articles/net-naming-conventions-and-programming-standards---best-practices",children:"here"}),". Over time I have started to move away from this approach. Without a deliberate intention to do so I have found myself adopting a different style for my JavaScript code as compared with anything else I write. I wouldn't go so far as to say I'm completely happy with the style I'm currently using. But I find it more helpful than not and thought it might be worth talking about. It was really 2 things that started me down the road of \"rolling my own\" convention: dynamic typing and the lack of safety nets. Let's take each in turn...."]}),"\n",(0,i.jsx)(t.h3,{id:"1-dynamic-typing",children:"1. Dynamic typing"}),"\n",(0,i.jsx)(t.p,{children:"Having grown up (in a development sense) using compiled and strongly-typed languages I was used to the IDE making it pretty clear what was what through friendly tooltips and the like:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(70040).A+"",width:"174",height:"58",loading:"lazy"})}),"\n",(0,i.jsxs)(t.p,{children:["JavaScript is loosely / dynamically typed (",(0,i.jsx)(t.a,{href:"http://stackoverflow.com/questions/9154388/does-untyped-also-mean-dynamically-typed-in-the-academic-cs-world",children:'occasionally called "untyped" but let\'s not go there'}),"). This means that the IDE can't easily determine what's what. So no tooltips for you sunshine. ### 2. The lack of safety nets / running with scissors"]}),"\n",(0,i.jsxs)(t.p,{children:["Now I've come to love it but what I realised pretty quickly when getting into JavaScript was this: you are running with scissors. If you're not careful and you don't take precautions it can bloody quickly. If I'm writing C# I have a lot of safety nets. Not the least of which is \"does it compile\"? If I declare an integer and then subsequently try to assign a string value to it ",(0,i.jsx)("u",{children:"it won't let me"})]}),"\n",(0,i.jsx)(t.p,{children:". But JavaScript is forgiving. Some would say too forgiving. Let's do something mad:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"var iAmANumber = 77;\n\nconsole.log(iAmANumber); //Logs a number\n\niAmANumber = \"It's a string\";\n\nconsole.log(iAmANumber); //Logs a string\n\niAmANumber = {\n  description: 'I am an object',\n};\n\nconsole.log(iAmANumber); //Logs an object\n\niAmANumber = function (myVariable) {\n  console.log(myVariable);\n};\n\nconsole.log(iAmANumber); //Logs a function\niAmANumber('I am not a number, I am a free man!'); //Calls a function which performs a log\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now if I were to attempt something similar in C# fuggedaboudit but JavaScript; no I'm romping home free:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(99216).A+"",width:"320",height:"251",loading:"lazy"})}),"\n",(0,i.jsxs)(t.p,{children:["Now I'm not saying that you should ever do the above, and thinking about it I can't think of a situation where you'd want to (suggestions on a postcard). But the point is it's possible. And because it's possible to do this deliberately, it's doubly possible to do this accidentally. My point is this: it's easy to make bugs in JavaScript. ## What ",(0,i.jsx)(t.del,{children:"Katy"})," Johnny Did Next"]}),"\n",(0,i.jsxs)(t.p,{children:["I'd started making more and more extensive use of JavaScript. I was beginning to move in the direction of using the ",(0,i.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Single-page_application",children:"single-page application"})," approach (",(0,i.jsx)(t.em,{children:"although more in the sense of giving application style complexity to individual pages rather than ensuring that entire applications ended up in a single page"}),"). This meant that whereas in the past I'd had the occasional 2 lines of JavaScript I now had a multitude of functions which were all interacting in response to user input. All these functions would contain a number of different variables. As well as this I was making use of jQuery for both Ajax purposes and to smooth out the DOM inconsistencies between various browsers. This only added to the mix as variables in one of my functions could be any one of the following: - a number"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"a string"}),"\n",(0,i.jsx)(t.li,{children:"a boolean"}),"\n",(0,i.jsx)(t.li,{children:"a date"}),"\n",(0,i.jsx)(t.li,{children:"an object"}),"\n",(0,i.jsx)(t.li,{children:"an array"}),"\n",(0,i.jsx)(t.li,{children:"a function"}),"\n",(0,i.jsx)(t.li,{children:"a jQuery object - not strictly a distinct JavaScript type obviously but treated pretty much as one in the sense that it has a particular functions / properties etc associated with it"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["As I started doing this sort of work I made no changes to my coding style. Wherever possible I did *",(0,i.jsx)(t.strong,{children:"exactly"}),"* what I would have been doing in C# in JavaScript. And it worked fine. Until.... Okay there is no \"until\" as such, it did work fine. But what I found was that I would do a piece of work, check it into source control, get users to test it, release the work into Production and promptly move onto the next thing. However, a little way down the line there would be a request to add a new feature or perhaps a bug was reported and I'd find myself back looking at the code. And, as is often the case, despite the comments I would realise that it wasn't particularly clear why something worked in the way it did. (Happily it's not just me that has this experience, paranoia has lead me to ask many a fellow developer and they have confessed to similar) When it came to bug hunting in particular I found myself cursing the lack of friendly tooltips and the like. Each time I wanted to look at a variable I'd find myself tracking back through the function, looking for the initial use of the variable to determine the type. Then I'd be tracking forward through the function for each subsequent use to ensure that it conformed. Distressingly, I would find examples of where it looked like I'd forgotten the type of the variable towards the end of a function (for which I can only, regrettably, blame myself). Most commonly I would have a situation like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"var tableCell = $('#ItIsMostDefinitelyATableCell'); //I jest ;-)\n\n/* ...THERE WOULD BE SOME CODE DOING SOMETHING HERE... */\n\ntableCell.className = 'makeMeProminent'; //Oh dear - not good.\n"})}),"\n",(0,i.jsx)(t.p,{children:"You see what happened above? I forgot I had a jQuery object and instead treated it like it was a standard DOM element. Oh dear. ## Spinning my own safety net; Hungarian style"}),"\n",(0,i.jsxs)(t.p,{children:['After I\'d experienced a few of the situations described above I decided that steps needed to be taken to minimise the risk of this. In this case, I decided that "steps" meant ',(0,i.jsx)(t.a,{href:"http://en.wikipedia.org/wiki/Hungarian_notation",children:"Hungarian notation"}),". I know. I bet you're wincing right now. For those of you that don't remember HN was pretty much the standard way of coding at one point (although at the point that I started coding professionally it had already started to decline). It was adopted in simpler times long before the modern IDE's that tell you what each variable is became the norm. Back when you couldn't be sure of the types you were dealing with. In short, kind of like my situation with JavaScript right now. There's not much to it. By and large HN simply means having a lowercase prefix of 1-3 characters on all your variables indicating type. It doesn't solve all your problems. It doesn't guarantee to stop bugs. But because each instance of the variables use implicitly indicates it's type it makes bugs more glaringly obvious. This means when writing code I'm less likely to misuse a variable (eg ",(0,i.jsx)(t.code,{children:'iNum = "JIKJ"'}),") because part of my brain would be bellowing: \"that just looks wrong... pay better attention lad!\". Likewise, if I'm scanning through some JavaScript and searching for a bug then this can make it more obvious. Here's some examples of different types of variables declared using the style I have adopted:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"var iInteger = 4;\nvar dDecimal = 10.5;\nvar sString = 'I am a string';\nvar bBoolean = true;\nvar dteDate = new Date();\nvar oObject = {\n  description: 'I am an object',\n};\nvar aArray = [34, 77];\nvar fnFunction = function () {\n  //Do something\n};\nvar $jQueryObject = $('#ItIsMostDefinitelyATableCell');\n"})}),"\n",(0,i.jsx)(t.p,{children:"Some of you have read this and thought \"hold on a minute... JavaScript doesn't have integers / decimals etc\". You're quite right. My style is not specifically stating the type of a variable. More it is seeking to provide a guide on how a variable should be used. JavaScript does not have integers. But oftentimes I'll be using a number variable which i will only ever want to treat as an integer. And so I'll name it accordingly. ## Spinning a better safety net; DOJO style"}),"\n",(0,i.jsxs)(t.p,{children:["I would be the first to say that alternative approaches are available. And here's one I recently happened upon that I rather like the look of: look 2/3rds down at the parameters section of ",(0,i.jsx)(t.a,{href:"http://dojotoolkit.org/community/styleGuide",children:"the DOJO styleguide"})," Essentially they advise specifying parameter types through the use of prefixed comments. See the examples below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"function(/*String*/ foo, /*int*/ bar)...\n"})}),"\n",(0,i.jsx)(t.p,{children:"or"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"function(/_String?_/ foo, /_int_/ bar, /_String[]?_/ baz)...\n"})}),"\n",(0,i.jsx)(t.p,{children:"I really rather like this approach and I'm thinking about starting to adopt it. It's not possible in Hungarian Notation to be so clear about the purpose of a variable. At least not without starting to adopt all kinds of kooky conventions that take in all the possible permutations of variable types. And if you did that you'd really be defeating yourself anyway as it would simply reduce the clarity of your code and make bugs more likely. ## Spinning a better safety net; unit tests"}),"\n",(0,i.jsx)(t.p,{children:"Despite being quite used to writing unit tests for all my server-side code I have not yet fully embraced unit testing on the client. Partly I've been holding back because of the variety of JavaScript testing frameworks available. I wasn't sure which to start with. But given that it is so easy to introduce bugs into JavaScript I have come to the conclusion that it's better to have some tests in place rather than none. Time to embrace the new. ## Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"I've found using Hungarian Notation useful whilst working in JavaScript. Not everyone will feel the same and I think that's fair enough; within reason I think it's generally a good idea to go with what you find useful. However, I am giving genuine consideration to moving to the DOJO style and moving back to my more standard camel-cased variable names instead of Hungarian Notation. Particularly since I strive to keep my functions short with the view that ideally each should 1 thing well. Keep it simple etc... And so in a perfect world the situation of forgetting a variables purpose shouldn't really arise... I think once I've got up and running with JavaScript unit tests I may make that move. Hungarian Notation may have proved to be just a stop-gap measure until better techniques were employed..."})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},70040:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/IDE-70c79404a67eeb869491ec15aea7474f.png"},99216:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/Mad-Stuff-5dc864cbbda35460fb52a9b9c085c8a0.webp"}}]);