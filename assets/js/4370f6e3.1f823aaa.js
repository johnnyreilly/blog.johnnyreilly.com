"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[35948],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>y});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,y=u["".concat(s,".").concat(m)]||u[m]||h[m]||a;return n?r.createElement(y,o(o({ref:t},c),{},{components:n})):r.createElement(y,o({ref:t},c))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},26777:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>u});n(67294);var r=n(3905);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const l={slug:"typescript-5-1-declaring-jsx-element-types",title:"TypeScript 5.1: Declaring JSX element types",authors:"johnnyreilly",tags:["typescript","JSX","React"],description:"With TypeScript 5.1, it becomes possible for libraries to control what types are used for JSX elements. This post looks at why this matters.",hide_table_of_contents:!1},s=void 0,p={permalink:"/typescript-5-1-declaring-jsx-element-types",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-06-09-typescript-5-1-declaring-jsx-element-types/index.md",source:"@site/blog/2023-06-09-typescript-5-1-declaring-jsx-element-types/index.md",title:"TypeScript 5.1: Declaring JSX element types",description:"With TypeScript 5.1, it becomes possible for libraries to control what types are used for JSX elements. This post looks at why this matters.",date:"2023-06-09T00:00:00.000Z",formattedDate:"June 9, 2023",tags:[{label:"typescript",permalink:"/tags/typescript"},{label:"JSX",permalink:"/tags/jsx"},{label:"React",permalink:"/tags/react"}],readingTime:4.405,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"typescript-5-1-declaring-jsx-element-types",title:"TypeScript 5.1: Declaring JSX element types",authors:"johnnyreilly",tags:["typescript","JSX","React"],description:"With TypeScript 5.1, it becomes possible for libraries to control what types are used for JSX elements. This post looks at why this matters.",hide_table_of_contents:!1},nextItem:{title:"TypeScript 5: importsNotUsedAsValues replaced by ESLint consistent-type-imports",permalink:"/typescript-5-importsnotusedasvalues-error-eslint-consistent-type-imports"}},c={authorsImageUrls:[void 0]},u=[{value:"What&#39;s the problem?",id:"whats-the-problem",level:2},{value:"The arrival of <code>JSX.ElementType</code>",id:"the-arrival-of-jsxelementtype",level:2},{value:"Summary",id:"summary",level:2}],h={toc:u};function m(e){var{components:t}=e,n=o(e,["components"]);return(0,r.kt)("wrapper",a(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),r.forEach((function(t){i(e,t,n[t])}))}return e}({},h,n),{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A new feature arrives with TypeScript 5.1, ",(0,r.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-beta/#decoupled-type-checking-between-jsx-elements-and-jsx-tag-types"},'it is described as "Decoupled Type-Checking Between JSX Elements and JSX Tag Types"'),"."),(0,r.kt)("p",null,"It's all about handing control of JSX type definitions to libraries. With this feature, libraries can control what types are used for JSX elements. Why does this matter? Great question! right now, TypeScript does an imperfect job of representing what is possible with JSX. This feature allows libraries to do a better job of representing what is possible with JSX."),(0,r.kt)("p",null,"This feature fixes a problem that's been around a while, and in this post will talk around it a little."),(0,r.kt)("p",null,"It's probably worth saying, that this is a complicated feature. If you don't understand it (and as the author of this post I'll confess that I had to work quite hard to understand it), ",(0,r.kt)("strong",{parentName:"p"},"that is okay"),". This is a low level feature that is only likely to be used by library / type definition authors. It's a primitive that will unlock possibilites for people writing JSX - but it's something that people will mainly feel the benefit of, without directly doing anything themselves."),(0,r.kt)("h2",{id:"whats-the-problem"},"What's the problem?"),(0,r.kt)("p",null,"In general, TypeScript creates a type system which sits on top of JavaScript, and provides static typing capabilities. As the language has grown more sophisticated, it has been able to get closer and closer to representing the full range of possibilities that JavaScript offers. If you remember the early days of TypeScript, you'll remember a time before union types, where you had to use ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," to represent a value that could be one of a number of types. That was solved with union types."),(0,r.kt)("p",null,"This problem is in the same vein, but specifically applies to JSX; which is widely used in libraries like React. With JSX support in TypeScript (up to and including 5.0), it was not possible to accurately represent all JSX possibilities. This is because the type of a JSX element is always ",(0,r.kt)("inlineCode",{parentName:"p"},"JSX.Element"),". This is a type that is defined in the TypeScript compiler, and is not something that can be changed by a library author."),(0,r.kt)("p",null,"How does this play out? Well, let's take a look at a simple example. Let's say we have a function component that returns a number. We might write something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function ComponentThatReturnsANumber() {\n  return 42;\n}\n\n<ComponentThatReturnsANumber />;\n")),(0,r.kt)("p",null,"The above is legitimate JSX, but it is not legitimate TypeScript. The TypeScript compiler will complain:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"'ComponentThatReturnsANumber' cannot be used as a JSX component.\nIts return type 'number' is not a valid JSX element.(2786)"),(0,r.kt)("p",{parentName:"blockquote"},"function ComponentThatReturnsANumber(): number")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgIilQ3wG4AoczAVwDsNgJa4BhXSWpWmAFQAsUMZDGpRaAZwCCAOWogARkigAKAJRwA3uThwiIsXAAsAJgoBfSgB424Jl14ChSfRJlzFUOAHoAfOSA"},"You can see this in the TypeScript Playground")),(0,r.kt)("p",null,"This errors because function components that return anything but ",(0,r.kt)("inlineCode",{parentName:"p"},"null | JSX.Element")," are not allowed as element types in React according to TypeScript. (Incidentally, this return value would be perfectly fine in class components - the restrictions are different there.) To quote Sebastian:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"However, in React, components can return a ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactNode"),". That type includes ",(0,r.kt)("inlineCode",{parentName:"p"},"number | string | Iterable<ReactNode> | undefined")," (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/reactjs/rfcs/pull/229"},"and will likely include ",(0,r.kt)("inlineCode",{parentName:"a"},"Promise<ReactNode>")," in the future"),").")),(0,r.kt)("p",null,"So this is the problem: what it actually possible in React (or other JSX libraries) is not possible to represent in TypeScript today. Furthermore, what's returned from JSX may change over time, and TypeScript needs to be able to represent that."),(0,r.kt)("h2",{id:"the-arrival-of-jsxelementtype"},"The arrival of ",(0,r.kt)("inlineCode",{parentName:"h2"},"JSX.ElementType")),(0,r.kt)("p",null,"Sebastian Silbermann ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/pull/51328"},"opened a pull request to TypeScript"),'. It had the title "RFC: Consult new JSX.ElementType for valid JSX element types". In that PR Sebastian explained the issue we\'ve just looked at above, and proposed a solution. The solution was to introduce a new type, ',(0,r.kt)("inlineCode",{parentName:"p"},"JSX.ElementType"),". This type would be used to represent the type of a JSX element. This would allow library authors to control what types are used for JSX elements."),(0,r.kt)("p",null,"To illustrate the what ",(0,r.kt)("inlineCode",{parentName:"p"},"JSX.ElementType")," actually is, consider Sebastian's illustration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<Component />\n// ^^^^^^^^^ JSX element type\n//^^^^^^^^^^^^^ JSX element\n")),(0,r.kt)("p",null,"The significance of ",(0,r.kt)("inlineCode",{parentName:"p"},"JSX.ElementType")," is that it hands control to type definition and library authors to implement."),(0,r.kt)("p",null,"The PR was merged, and so Sebastian (who helps maintain the React type definitions) did exactly this in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/DefinitelyTyped/DefinitelyTyped/pull/65135"},"this pull request to the DefinitelyTyped repository for the React type definitions"),". At the time of writing, this pull request is still open, but once merged and shipped the React community will feel the benefits."),(0,r.kt)("p",null,"The changes are subtle; You can see in this pull request that ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactElement | null")," is generally replaced with ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactNode"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"    type JSXElementConstructor<P> =\n-        | ((props: P) => ReactElement<any, any> | null)\n+        | ((props: P) => ReactNode)\n        | (new (props: P) => Component<any, any>);\n")),(0,r.kt)("p",null,"Remember how we mentioned earlier on that function components couldn't return numbers? Let's look at the updated tests in the PR:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"    const ReturnNumber = () => 0xeac1;\n+    const FCNumber: React.FC = ReturnNumber;\n    class RenderNumber extends React.Component {\n        render() {\n          return 0xeac1;\n        }\n    }\n")),(0,r.kt)("p",null,"With this change, React components that return numbers are now valid JSX elements. This is because ",(0,r.kt)("inlineCode",{parentName:"p"},"JSX.ElementType")," is now ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactNode"),", which includes numbers."),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,'The TL;DR of this post is "TypeScript will better allow for the modelling of JSX in TypeScript 5.1". I\'m indebted to ',(0,r.kt)("a",{parentName:"p",href:"https://github.com/eps1lon"},"Sebastian Silbermann")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/DanielRosenwasser"},"Daniel Rosenwasser")," for their explanations of this feature. I hope this post helps you understand the feature a little better."))}m.isMDXComponent=!0}}]);