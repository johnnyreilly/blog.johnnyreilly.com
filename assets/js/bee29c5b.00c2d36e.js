"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[8224],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(a),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return a?n.createElement(h,l(l({ref:t},p),{},{components:a})):n.createElement(h,l({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[m]="string"==typeof e?e:r,l[1]=i;for(var u=2;u<o;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},19551:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>u,toc:()=>m});a(67294);var n=a(3905);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})),e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const i={slug:"jquery-validation-globalize-hits-10",title:"jQuery Validation Globalize hits 1.0",authors:"johnnyreilly",tags:["globalize","jquery"],hide_table_of_contents:!1,description:"jQuery Validation Globalize plugin now supports Globalize 1.x, with minor code changes. Users can customize date parsing format."},s=void 0,u={permalink:"/jquery-validation-globalize-hits-10",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2015-10-05-jquery-validation-globalize-hits-10/index.md",source:"@site/blog/2015-10-05-jquery-validation-globalize-hits-10/index.md",title:"jQuery Validation Globalize hits 1.0",description:"jQuery Validation Globalize plugin now supports Globalize 1.x, with minor code changes. Users can customize date parsing format.",date:"2015-10-05T00:00:00.000Z",formattedDate:"October 5, 2015",tags:[{label:"globalize",permalink:"/tags/globalize"},{label:"jquery",permalink:"/tags/jquery"}],readingTime:2.87,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"jquery-validation-globalize-hits-10",title:"jQuery Validation Globalize hits 1.0",authors:"johnnyreilly",tags:["globalize","jquery"],hide_table_of_contents:!1,description:"jQuery Validation Globalize plugin now supports Globalize 1.x, with minor code changes. Users can customize date parsing format."},prevItem:{title:"The Names Have Been Changed...",permalink:"/the-names-have-been-changed"},nextItem:{title:"Definitely Typed Shouldn't Exist",permalink:"/authoring-npm-modules-with-typescript"}},p={authorsImageUrls:[void 0]},m=[],c={toc:m},d="wrapper";function h(e){var{components:t}=e,a=l(e,["components"]);return(0,n.kt)(d,o(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),n.forEach((function(t){r(e,t,a[t])}))}return e}({},c,a),{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This is just a quick post - the tl;dr is this: jQuery Validation Globalize has been ported to Globalize 1.x. Yay! In one of those twists of fate I'm not actually using this plugin in my day job anymore but I thought it might be useful to other people. So here you go. You can read more about this plugin in an ",(0,n.kt)("a",{parentName:"p",href:"/globalize-and-jquery-validate"},"older post")," and you can see a demo of it in action ",(0,n.kt)("a",{parentName:"p",href:"http://johnnyreilly.github.io/jQuery.Validation.Unobtrusive.Native/AdvancedDemo/Globalize.html"},"here"),"."),(0,n.kt)("p",null,"The code did not change drastically - essentially it was just a question of swapping ",(0,n.kt)("inlineCode",{parentName:"p"},"parseFloat")," for ",(0,n.kt)("inlineCode",{parentName:"p"},"parseNumber")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"parseDate")," for a slightly different ",(0,n.kt)("inlineCode",{parentName:"p"},"parseDate"),". So, we went from this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"},"(function ($, Globalize) {\n  // Clone original methods we want to call into\n  var originalMethods = {\n    min: $.validator.methods.min,\n    max: $.validator.methods.max,\n    range: $.validator.methods.range,\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize\n\n  $.validator.methods.number = function (value, element) {\n    var val = Globalize.parseFloat(value);\n    return this.optional(element) || $.isNumeric(val);\n  };\n\n  // Tell the validator that we want dates parsed using Globalize\n\n  $.validator.methods.date = function (value, element) {\n    var val = Globalize.parseDate(value);\n    return this.optional(element) || val instanceof Date;\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize,\n  // then call into original implementation with parsed value\n\n  $.validator.methods.min = function (value, element, param) {\n    var val = Globalize.parseFloat(value);\n    return originalMethods.min.call(this, val, element, param);\n  };\n\n  $.validator.methods.max = function (value, element, param) {\n    var val = Globalize.parseFloat(value);\n    return originalMethods.max.call(this, val, element, param);\n  };\n\n  $.validator.methods.range = function (value, element, param) {\n    var val = Globalize.parseFloat(value);\n    return originalMethods.range.call(this, val, element, param);\n  };\n})(jQuery, Globalize);\n")),(0,n.kt)("p",null,"To this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"},"(function ($, Globalize) {\n  // Clone original methods we want to call into\n  var originalMethods = {\n    min: $.validator.methods.min,\n    max: $.validator.methods.max,\n    range: $.validator.methods.range,\n  };\n\n  // Globalize options - initially just the date format used for parsing\n  // Users can customise this to suit them\n  $.validator.methods.dateGlobalizeOptions = {\n    dateParseFormat: { skeleton: 'yMd' },\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize\n  $.validator.methods.number = function (value, element) {\n    var val = Globalize.parseNumber(value);\n    return this.optional(element) || $.isNumeric(val);\n  };\n\n  // Tell the validator that we want dates parsed using Globalize\n  $.validator.methods.date = function (value, element) {\n    var val = Globalize.parseDate(\n      value,\n      $.validator.methods.dateGlobalizeOptions.dateParseFormat,\n    );\n    return this.optional(element) || val instanceof Date;\n  };\n\n  // Tell the validator that we want numbers parsed using Globalize,\n  // then call into original implementation with parsed value\n\n  $.validator.methods.min = function (value, element, param) {\n    var val = Globalize.parseNumber(value);\n    return originalMethods.min.call(this, val, element, param);\n  };\n\n  $.validator.methods.max = function (value, element, param) {\n    var val = Globalize.parseNumber(value);\n    return originalMethods.max.call(this, val, element, param);\n  };\n\n  $.validator.methods.range = function (value, element, param) {\n    var val = Globalize.parseNumber(value);\n    return originalMethods.range.call(this, val, element, param);\n  };\n})(jQuery, Globalize);\n")),(0,n.kt)("p",null,"All of which is pretty self-explanatory. The only thing I'd like to draw out is that Globalize 0.1.x didn't force you to specify a date parsing format and, as I recall, would attempt various methods of parsing. For that reason jQuery Validation Globalize 1.0 exposes a ",(0,n.kt)("inlineCode",{parentName:"p"},"$.validator.methods.dateGlobalizeOptions")," which allows you to specify the data parsing format you want to use. This means, should you be using a different format than the out of the box one then you can tweak it like so:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"},"$.validator.methods.dateGlobalizeOptions.dateParseFormat = // your data parsing format goes here...\n")),(0,n.kt)("p",null,"Theoretically, this functionality could be tweaked to allow the user to specify multiple possible date parsing formats to attempt. I'm not certain if that's a good idea though, so it remains unimplemented for now."))}h.isMDXComponent=!0}}]);