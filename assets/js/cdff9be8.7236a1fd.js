"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[72687],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>y});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(r),h=o,y=c["".concat(s,".").concat(h)]||c[h]||d[h]||a;return r?n.createElement(y,i(i({ref:t},u),{},{components:r})):n.createElement(y,i({ref:t},u))}));function y(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},40722:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>y,frontMatter:()=>l,metadata:()=>p,toc:()=>c});r(67294);var n=r(3905);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})),e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}const l={slug:"webpack-resolveloader-alias-with-query",title:"webpack: resolveLoader / alias with query / options",authors:"johnnyreilly",tags:["webpack"],hide_table_of_contents:!1,description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options."},s=void 0,p={permalink:"/webpack-resolveloader-alias-with-query",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2017-01-06-webpack-resolveloader-alias-with-query/index.md",source:"@site/blog/2017-01-06-webpack-resolveloader-alias-with-query/index.md",title:"webpack: resolveLoader / alias with query / options",description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options.",date:"2017-01-06T00:00:00.000Z",formattedDate:"January 6, 2017",tags:[{label:"webpack",permalink:"/tags/webpack"}],readingTime:1.38,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"webpack-resolveloader-alias-with-query",title:"webpack: resolveLoader / alias with query / options",authors:"johnnyreilly",tags:["webpack"],hide_table_of_contents:!1,description:"Webpacks enhanced-resolve has a bug with aliased loaders. A workaround involves suffixing the aliased path with query options."},prevItem:{title:"Hands-free HTTPS",permalink:"/hands-free-https"},nextItem:{title:"webpack: configuring a loader with query / options",permalink:"/webpack-configuring-loader-with-query"}},u={authorsImageUrls:[void 0]},c=[],d={toc:c},h="wrapper";function y(e){var{components:t}=e,r=i(e,["components"]);return(0,n.kt)(h,a(function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){o(e,t,r[t])}))}return e}({},d,r),{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,'Sometimes you write a post for the ages. Sometimes you write one you hope is out of date before you hit "publish". This is one of those.'),(0,n.kt)("p",null,"There's a ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/webpack/enhanced-resolve/issues/41"},"bug")," in webpack's enhanced-resolve. It means that you cannot configure an aliased loader using the ",(0,n.kt)("inlineCode",{parentName:"p"},"query")," (or ",(0,n.kt)("inlineCode",{parentName:"p"},"options")," in the webpack 2 nomenclature). Let me illustrate; consider the following code:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = {\n  // ...\n  module: {\n    loaders: [\n      {\n        test: /\\.ts$/,\n        loader: 'ts-loader',\n        query: {\n            entryFileIsJs: true\n        }\n      }\n    ]\n  }\n}\n\nmodule.exports.resolveLoader = { alias: { 'ts-loader': require('path').join(__dirname, \"../../index.js\")\n")),(0,n.kt)("p",null,"At the time of writing, if you alias a loader as above, then the ",(0,n.kt)("inlineCode",{parentName:"p"},"query")," / ",(0,n.kt)("inlineCode",{parentName:"p"},"options")," will ","*",(0,n.kt)("em",{parentName:"p"},"not"),"*"," be passed along. This is bad, particularly given the requirement in webpack 2 that configuration is no longer possible through extending the ",(0,n.kt)("a",{parentName:"p",href:"https://webpack.js.org/guides/migrating/#loader-configuration-is-through-options"},(0,n.kt)("inlineCode",{parentName:"a"},"webpack.config.js")),". So what to do? Well, when this was a problem previously the marvellous ",(0,n.kt)("a",{parentName:"p",href:"https://www.twitter.com/jbrantly"},"James Brantly")," had a ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/webpack/webpack/issues/1289#issuecomment-125767499"},"workaround"),". I've taken that and run with it:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"},"var config = {\n  // ...\n  module: {\n    loaders: [\n      {\n        test: /\\.ts$/,\n        loader: 'ts-loader',\n        query: {\n          entryFileIsJs: true,\n        },\n      },\n    ],\n  },\n};\n\nmodule.exports = config;\n\nvar loaderAliasPath = require('path').join(__dirname, '../../../index.js');\nvar rules = config.module.loaders || config.module.rules;\nrules.forEach(function (rule) {\n  var options = rule.query || rule.options;\n  rule.loader = rule.loader.replace(\n    'ts-loader',\n    loaderAliasPath + (options ? '?' + JSON.stringify(options) : ''),\n  );\n});\n")),(0,n.kt)("p",null,"This approach stringifies the ",(0,n.kt)("inlineCode",{parentName:"p"},"query")," / ",(0,n.kt)("inlineCode",{parentName:"p"},"options")," and suffixes it to the aliased path. This works as long as the options you're passing are JSON-able (yes it's a word)."),(0,n.kt)("p",null,"As I said earlier; hopefully by the time you read this the workaround will no longer be necessary again. But just in case...."))}y.isMDXComponent=!0}}]);