"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["33550"],{66033:function(e,n,i){i.r(n),i.d(n,{assets:function(){return l},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return a},metadata:function(){return r},toc:function(){return d}});var r=i(99591),t=i(85893),s=i(50065);let a={slug:"azure-devops-pull-requests-dynamic-required-reviewers",title:"Azure DevOps: pull requests and dynamic required reviewers",authors:"johnnyreilly",tags:["typescript","azure devops","node.js"],image:"./title-image.png",hide_table_of_contents:!1,description:"How to have dynamically assigned required reviewers for a pull request in Azure DevOps using build validations and the Azure DevOps Client for Node.js."},o=void 0,l={image:i(60560).Z,authorsImageUrls:[void 0]},d=[{value:"Build validations and required reviewers",id:"build-validations-and-required-reviewers",level:2},{value:"Co-opting your existing build validation pipeline",id:"co-opting-your-existing-build-validation-pipeline",level:2},{value:"Setting up the code to dynamically assign required reviewers",id:"setting-up-the-code-to-dynamically-assign-required-reviewers",level:2},{value:"Running the code",id:"running-the-code",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){let n={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Have you ever wanted to have required reviewers for a pull request in Azure DevOps? Probably. And that's an inbuilt feature of Azure DevOps. By using ",(0,t.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#automatically-include-code-reviewers",children:"branch policies, you can set required reviewers for a pull request"}),". If you want to ensure the code is reviewed by the appropriate people before it is merged into the main branch, this can prove very useful."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"title image reading &quot;Azure DevOps: pull requests and dynamic required reviewers&quot; with an Azure DevOps logo",src:i(35649).Z+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,t.jsxs)(n.p,{children:["However, the required reviewers are static. You can set them up in the branch policies, but they don't change dynamically based on the code being altered or the people involved in the pull request. I spent many moons trawling the internet for an answer to this question, ",(0,t.jsx)(n.a,{href:"https://stackoverflow.com/questions/64754998/how-do-i-add-a-required-reviewer-when-people-of-a-given-team-create-a-pull-reque",children:"and I found that many people were asking the same question"}),'. The answer was always the same: "You can\'t do that."']}),"\n",(0,t.jsx)(n.p,{children:"However, there is a way. It is, hand on heart, marginally clunky. But the clunk is marginal, and more than acceptable. It involves co-opting build validations to achieve the desired effect. In this post, I'll show you how to do that."}),"\n",(0,t.jsx)(n.h2,{id:"build-validations-and-required-reviewers",children:"Build validations and required reviewers"}),"\n",(0,t.jsx)(n.p,{children:"Build validations in Azure DevOps are a way to ensure that code meets certain criteria before it is merged into the main branch. They are, crucially, Azure DevOps pipelines that run when a pull request is created or updated. They are typically used to ensure that the code builds successfully, tests pass, linting succeeds etc. Build validations are set up in the branch policies for a repository. It's pretty typical for a repository to have a build validations."}),"\n",(0,t.jsxs)(n.p,{children:["The crucial thing to note is that, typically, ",(0,t.jsx)(n.strong,{children:"build validations must pass before a pull request can be completed"}),". That's how they provide their value; as a control to prevent changes breaking the codebase. What we're going to do, is use this blocking aspect to our advantage. We'll include a new stage in our build validation pipeline that, each time it runs, does one of the following:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Dynamically adds a required reviewer to the pull request, if appropriate. The way we decide which reviewers are dynamically added, if any, is down to us to determine. It's entirely flexible. It could be based on the code being changed or the people involved in the pull request, or indeed something else. If no reviewer is added, the pipeline will pass. But if a reviewer is added to the pull request, the pipeline will be made to fail."}),"\n",(0,t.jsx)(n.li,{children:"If a reviewer is determined as required, and has already been assigned, check if the reviewer has approved the pull request. If they have approved, the pipeline will pass. If they haven't approved the pull request, the pipeline will fail."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The thing to pay attention to is that the pipeline will fail if dynamically assigned required reviewers have not given their approval by the end of the pipeline run. This applies equally if the pipeline is running for the first time against a pull request and assigning the reviewers. ",(0,t.jsx)(n.strong,{children:"This means that the pull request cannot be completed until any dynamically assigned required reviewers have approved it."})]}),"\n",(0,t.jsx)(n.p,{children:"This is the part that makes your risk and audit teams happy. You cannot circumvent the required reviewers; the pipeline failing will prevent the pull request from being merged / completed until the required reviewers have approved it. This is a way to ensure that the code is reviewed by the appropriate people before it is merged into the main branch."}),"\n",(0,t.jsx)(n.p,{children:'I mentioned "clunky" earlier. The clunkiness comes from the need to rerun the build validation pipeline in the Azure DevOps UI when the approval has been given. This is because there is no way (that I\'m aware of) to trigger the build validation pipeline when a reviewer approval has been provided. So, if the required reviewers approve the pull request, you will need to rerun the build validation pipeline to ensure that it passes and the pull request can be completed.'}),"\n",(0,t.jsx)(n.p,{children:"As long as the failing pipeline provides a clear message about what is required, this is a small price to pay for the ability to have dynamic required reviewers."}),"\n",(0,t.jsx)(n.p,{children:"Now I've convinced you that this is a good idea, let's look at how to implement it."}),"\n",(0,t.jsx)(n.h2,{id:"co-opting-your-existing-build-validation-pipeline",children:"Co-opting your existing build validation pipeline"}),"\n",(0,t.jsx)(n.p,{children:"I'm making an assumption that you already have a build validation pipeline set up for your repository. If you don't, you'll need to set one up first."}),"\n",(0,t.jsx)(n.p,{children:"To your existing build validation pipeline, you'll need to add a new stage that will run the code to dynamically assign required reviewers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- stage: DynamicRequiredReviewers\n  displayName: Dynamic required reviewers\n  dependsOn: [] # This stage does not depend on any other stages and so will run in parallel with the others\n  jobs:\n    - job:\n      steps:\n        - task: NodeTool@0\n          inputs:\n            versionSpec: 22\n          displayName: Install Node.js\n\n        - bash: npm ci\n          displayName: 'Install dependencies'\n          workingDirectory: 'scripts/dynamic-required-reviewers'\n\n        - bash: npm test\n          displayName: 'Run tests'\n          workingDirectory: 'scripts/dynamic-required-reviewers'\n\n        - bash: npm start -- --sat $(System.AccessToken) --pullRequestId $(System.PullRequest.PullRequestId) --organization $(System.CollectionUri) --repositoryName $(Build.Repository.Name) --projectName $(System.TeamProject)'\n          displayName: 'Validate claims'\n          workingDirectory: 'scripts/dynamic-required-reviewers'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can see reference to the ",(0,t.jsx)(n.code,{children:"scripts/dynamic-required-reviewers"})," directory. This is where we'll put the code that will dynamically assign required reviewers. The code will run in a Node.js environment, so we'll need to install Node.js and the dependencies for the code to run."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also see that we're using the ",(0,t.jsx)(n.code,{children:"System.AccessToken"})," and ",(0,t.jsx)(n.code,{children:"System.PullRequest.PullRequestId"})," variables. The ",(0,t.jsx)(n.code,{children:"System.AccessToken"})," is a token that allows the code to interact with the Azure DevOps API, and the ",(0,t.jsx)(n.code,{children:"System.PullRequest.PullRequestId"})," is the ID of the pull request that the build validation pipeline is running against. We'll use these in our code to dynamically assign required reviewers to the pull request."]}),"\n",(0,t.jsxs)(n.p,{children:["We also use the ",(0,t.jsx)(n.code,{children:"System.CollectionUri"}),", ",(0,t.jsx)(n.code,{children:"Build.Repository.Name"}),", and ",(0,t.jsx)(n.code,{children:"System.TeamProject"})," variables to get the organization, repository name, and project name respectively. These will be used to make API calls to Azure DevOps with our token."]}),"\n",(0,t.jsx)(n.h2,{id:"setting-up-the-code-to-dynamically-assign-required-reviewers",children:"Setting up the code to dynamically assign required reviewers"}),"\n",(0,t.jsxs)(n.p,{children:["You'll need to create the ",(0,t.jsx)(n.code,{children:"scripts/dynamic-required-reviewers"})," directory. In there we're going to add a ",(0,t.jsx)(n.code,{children:"package.json"})," file to manage our dependencies:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "name": "dynamic-required-reviewers",\n  "version": "1.0.0",\n  "scripts": {\n    "build": "tsc",\n    "start": "npm run build && node dist/index.js"\n  },\n  "license": "ISC",\n  "type": "module",\n  "dependencies": {\n    "azure-devops-node-api": "^15.1.0"\n  },\n  "devDependencies": {\n    "@types/node": "^22.0.0",\n    "typescript": "^5.8.3"\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We also need a ",(0,t.jsx)(n.code,{children:"tsconfig.json"})," file to configure TypeScript:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "allowJs": true,\n    "declaration": true,\n    "declarationMap": true,\n    "esModuleInterop": true,\n    "module": "NodeNext",\n    "moduleResolution": "NodeNext",\n    "noEmit": false,\n    "resolveJsonModule": true,\n    "skipLibCheck": true,\n    "sourceMap": true,\n    "strict": true,\n    "target": "ES2022",\n    "outDir": "dist"\n  },\n  "include": ["src"]\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now we'll add our ",(0,t.jsx)(n.code,{children:"src/index.ts"})," file where we'll put our code to dynamically assign required reviewers."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { parseArgs } from 'node:util';\n\nimport * as nodeApi from 'azure-devops-node-api';\nimport type { GitPullRequest } from 'azure-devops-node-api/interfaces/GitInterfaces.js';\nimport type { IGitApi } from 'azure-devops-node-api/GitApi.js';\n\nasync function main() {\n  const args = parseArgs({\n    options: {\n      pat: { type: 'string', short: 'p', default: process.env.ADO_PAT },\n      sat: { type: 'string', short: 's', default: process.env.ADO_SAT },\n      pullRequestId: {\n        type: 'string',\n        short: 'i',\n        default: process.env.ADO_PULL_REQUEST_ID,\n      },\n      organization: {\n        type: 'string',\n        short: 'o',\n        default: '',\n      },\n      repositoryName: { type: 'string', short: 'r', default: '' },\n      projectName: { type: 'string', short: 'j', default: '' },\n    },\n  });\n\n  const pullRequestId = parseInt(args.values.pullRequestId ?? '0', 10);\n  const pat = args.values.pat ?? '';\n  const sat = args.values.sat ?? '';\n  const organization = args.values.organization ?? '';\n  const repositoryName = args.values.repositoryName ?? '';\n  const projectName = args.values.projectName ?? '';\n\n  const webApi = await makeWebApi({\n    pat,\n    sat,\n    organization,\n  });\n\n  const gitApi = await webApi.getGitApi();\n  const pullRequest = await gitApi.getPullRequest(\n    /* repositoryId */ repositoryName,\n    /* pullRequestId */ pullRequestId,\n    /* project */ projectName,\n    /* maxCommentLength */ undefined,\n    /* skip */ undefined,\n    /* top */ undefined,\n    /* includeCommits */ true,\n    /* includeWorkItemRefs */ false,\n  );\n\n  const requiredReviewerName = await determineRequiredReviewerName(pullRequest);\n\n  if (!requiredReviewerName) {\n    console.log(\n      '\u2705 No required reviewer was deemed necessary. No action needed.',\n    );\n    return;\n  }\n\n  const requiredReviewer = await searchIdentityForReviewer({\n    pat,\n    sat,\n    organization,\n    searchTerm: requiredReviewerName,\n  });\n\n  if (!requiredReviewer) {\n    const errorMessage = `\u274C Failed to look up reviewer: ${requiredReviewerName}`;\n    throw new Error(errorMessage);\n  }\n\n  await determineAction({\n    requiredReviewer,\n    pullRequest,\n    gitApi,\n    projectName,\n    repositoryName,\n  });\n}\n\nasync function determineRequiredReviewerName(\n  pullRequest: GitPullRequest,\n): Promise<string | undefined> {\n  // This is a placeholder function. You should implement your logic to determine the required reviewer name.\n  return 'Required Reviewer Name'; // Replace with actual logic\n}\n\nasync function makeWebApi({\n  organization,\n  pat,\n  sat,\n}: {\n  organization: string;\n  pat?: string;\n  sat?: string;\n}) {\n  if (!pat && !sat) {\n    throw new Error(\n      'Either a Personal Access Token (PAT) or a Service Account Token (SAT) must be provided.',\n    );\n  }\n  const webApi = new nodeApi.WebApi(\n    `https://dev.azure.com/${organization}`,\n    pat\n      ? nodeApi.getPersonalAccessTokenHandler(\n          pat,\n          /** allowCrossOriginAuthentication */ true,\n        )\n      : nodeApi.getHandlerFromToken(\n          sat ?? '',\n          /** allowCrossOriginAuthentication */ true,\n        ),\n  );\n\n  return webApi;\n}\n\ninterface Identity {\n  id: string;\n  providerDisplayName: string;\n}\n\n/**\n * This searches the organization's identity system directly\n * based on https://learn.microsoft.com/en-us/rest/api/azure/devops/ims/identities/read-identities?view=azure-devops-rest-7.1&tabs=HTTP\n */\nasync function searchIdentityForReviewer({\n  pat,\n  sat,\n  searchTerm,\n  organization,\n}: {\n  pat: string;\n  sat: string;\n  searchTerm: string;\n  organization: string;\n}): Promise<Identity | undefined> {\n  try {\n    // Use the identities API endpoint for broader search\n    const searchUrl = `https://vssps.dev.azure.com/${organization}/_apis/identities?searchFilter=General&filterValue=${encodeURIComponent(\n      searchTerm,\n    )}&api-version=7.1-preview.1`;\n\n    const response = await fetch(searchUrl, {\n      method: 'GET',\n      headers: {\n        Authorization: `Basic ${Buffer.from(`PAT:${pat || sat}`).toString(\n          'base64',\n        )}`,\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      console.warn(\n        `Identity search failed: ${response.status} ${response.statusText}`,\n      );\n      return undefined;\n    }\n\n    const data = await response.json();\n\n    if (data.value && data.value.length > 0) {\n      const identity: Identity = data.value[0]; // Take the first match\n\n      console.log(`\u2705 Found identity via search:`);\n      console.log(`   ID: ${identity.id}`);\n      console.log(`   Display Name: ${identity.providerDisplayName}`);\n\n      return identity;\n    }\n\n    console.warn(`\u26A0\uFE0F  No identities found for: ${searchTerm}`);\n    return undefined;\n  } catch (error) {\n    console.error(`\u274C Error searching identities for ${searchTerm}:`, error);\n    return undefined;\n  }\n}\n\nconst voteValues = {\n  approved: 10,\n  approvedWithSuggestions: 5,\n  noVote: 0,\n  waitingForAuthor: -5,\n  rejected: -10,\n} as const;\n\nasync function determineAction({\n  requiredReviewer,\n  pullRequest,\n  gitApi,\n  projectName,\n  repositoryName,\n}: {\n  requiredReviewer: Identity;\n  pullRequest: GitPullRequest;\n  gitApi: IGitApi;\n  projectName: string;\n  repositoryName: string;\n}): Promise<void> {\n  const assignedReviewer = pullRequest.reviewers?.find(\n    (reviewer) => reviewer.id === requiredReviewer.id,\n  );\n  const requiredReviewIsAssigned =\n    assignedReviewer && assignedReviewer.isRequired;\n  const hasBeenApprovedByRequiredReviewer =\n    assignedReviewer && assignedReviewer.vote === voteValues.approved;\n\n  if (requiredReviewIsAssigned && hasBeenApprovedByRequiredReviewer) {\n    console.log(\n      `\u2705 Reviewer with ID ${\n        assignedReviewer.displayName ?? assignedReviewer.id\n      } is already assigned and has approved the pull request. No action needed.`,\n    );\n  } else if (requiredReviewIsAssigned) {\n    const errorMessage = `\u26A0\uFE0F Reviewer with ID ${\n      assignedReviewer.displayName ?? assignedReviewer.id\n    } is already assigned but has not approved the pull request.`;\n    throw new Error(errorMessage);\n  } else {\n    console.log(\n      `\u26A0\uFE0F Reviewer with ID ${requiredReviewer.providerDisplayName} is not yet assigned. Will assign them.`,\n    );\n\n    const reviewerToBeAssigned = {\n      id: requiredReviewer.id,\n      vote: voteValues.noVote,\n      isRequired: true,\n    };\n\n    try {\n      await gitApi.createPullRequestReviewer(\n        reviewerToBeAssigned,\n        /** repositoryId */ repositoryName,\n        pullRequest.pullRequestId!,\n        /** reviewerId */ reviewerToBeAssigned.id,\n        /** project */ projectName,\n      );\n      console.log('\u2705 Successfully added reviewer to pull request');\n    } catch (error) {\n      const errorMessage = `\u274C Failed to add reviewer to pull request`;\n      throw new Error(errorMessage, { cause: error });\n    }\n\n    const errorMessage = `The pull request requires review and approval by ${requiredReviewer.providerDisplayName}. Once approved, please re-run this build validation and it should pass.`;\n    throw new Error(errorMessage);\n  }\n}\n\nmain();\n"})}),"\n",(0,t.jsx)(n.p,{children:"There's a good bit of code here, so let's break it down:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"main"})," function is the entry point of the script. It parses the command line arguments and sets up the Azure DevOps API client."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"makeWebApi"})," function creates an instance of the Azure DevOps Web API client using either a Personal Access Token (PAT) or a Service Account Token (SAT). You'll use a PAT for local development and a SAT in the build validation pipeline. If using a PAT it requires the scopes: ",(0,t.jsx)(n.code,{children:"vso.code"})," and ",(0,t.jsx)(n.code,{children:"vso.identity"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"getRequiredReviewerName"})," function is a placeholder for your logic to determine the name of your required reviewer, if any. You should implement your logic here to determine when dynamically assigned reviewers are appropriate."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"searchIdentityForReviewer"})," function searches for the required reviewer in the Azure DevOps identity system. It uses the Azure DevOps REST API to search for identities based on a search term. Rather frustratingly, you can't directly use the Azure AD / Entra ID Graph API to search for users in Azure DevOps."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"determineAction"})," function checks if the required reviewer is already assigned to the pull request and whether they have approved it.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If they have, it logs a success message."}),"\n",(0,t.jsx)(n.li,{children:"If they haven't, it throws an error with a message indicating that the required reviewer needs to approve the pull request."}),"\n",(0,t.jsx)(n.li,{children:"If the required reviewer is not assigned, it assigns them to the pull request and throws an error with a message indicating that the pull request requires their approval."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"running-the-code",children:"Running the code"}),"\n",(0,t.jsx)(n.p,{children:"You can run the code locally to test it. You'll need to set up a Personal Access Token (PAT) with the required scopes and set the environment variables accordingly. You can then run the code using:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm start -- --pat [YOUR_PAT] --pullRequestId [PULL_REQUEST_ID] --organization [ORGANISATION_NAME] --repositoryName [ADO_REPOSITORY_NAME] --projectName [ADO_PROJECT_NAME]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"In this post, we've seen how to dynamically assign required reviewers for a pull request in Azure DevOps using build validations and the Azure DevOps API brought together with a little TypeScript. By co-opting your existing build validation pipeline, you can ensure that the code is reviewed by the appropriate people before it is merged into the main branch."}),"\n",(0,t.jsx)(n.p,{children:"Use this. Make your risk and audit teams happy!"})]})}function p(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},60560:function(e,n,i){i.d(n,{Z:function(){return r}});let r=i.p+"assets/images/title-image-d9d792feb68580211ffd5ef79efee6b6.png"},35649:function(e,n,i){i.d(n,{Z:function(){return r}});let r=i.p+"assets/images/title-image-d9d792feb68580211ffd5ef79efee6b6.png"},50065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return a}});var r=i(67294);let t={},s=r.createContext(t);function a(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},99591:function(e){e.exports=JSON.parse('{"permalink":"/azure-devops-pull-requests-dynamic-required-reviewers","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2025-06-25-azure-devops-pull-requests-dynamic-required-reviewers/index.md","source":"@site/blog/2025-06-25-azure-devops-pull-requests-dynamic-required-reviewers/index.md","title":"Azure DevOps: pull requests and dynamic required reviewers","description":"How to have dynamically assigned required reviewers for a pull request in Azure DevOps using build validations and the Azure DevOps Client for Node.js.","date":"2025-06-25T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."},{"inline":false,"label":"Azure DevOps","permalink":"/tags/azure-devops","description":"The Azure DevOps suite of tools."},{"inline":false,"label":"Node.js","permalink":"/tags/node-js","description":"The Node.js runtime."}],"readingTime":11.17,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"azure-devops-pull-requests-dynamic-required-reviewers","title":"Azure DevOps: pull requests and dynamic required reviewers","authors":"johnnyreilly","tags":["typescript","azure devops","node.js"],"image":"./title-image.png","hide_table_of_contents":false,"description":"How to have dynamically assigned required reviewers for a pull request in Azure DevOps using build validations and the Azure DevOps Client for Node.js."},"unlisted":false,"nextItem":{"title":"TypeScript is going Go: Why it\u2019s the pragmatic choice","permalink":"/typescript-go-pragmatic-choice"}}')}}]);