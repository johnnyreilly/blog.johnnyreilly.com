"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[73738],{78349:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=n(74848),s=n(28453);const r={slug:"typescript-5-1-declaring-jsx-element-types",title:"TypeScript 5.1: declaring JSX element types",authors:"johnnyreilly",tags:["react","typescript"],image:"./title-image.png",description:"With TypeScript 5.1, it becomes possible for libraries to control what types are used for JSX elements. This post looks at why this matters.",hide_table_of_contents:!1},o=void 0,a={permalink:"/typescript-5-1-declaring-jsx-element-types",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-07-09-typescript-5-1-declaring-jsx-element-types/index.md",source:"@site/blog/2023-07-09-typescript-5-1-declaring-jsx-element-types/index.md",title:"TypeScript 5.1: declaring JSX element types",description:"With TypeScript 5.1, it becomes possible for libraries to control what types are used for JSX elements. This post looks at why this matters.",date:"2023-07-09T00:00:00.000Z",tags:[{label:"react",permalink:"/tags/react"},{label:"typescript",permalink:"/tags/typescript"}],readingTime:5.45,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"typescript-5-1-declaring-jsx-element-types",title:"TypeScript 5.1: declaring JSX element types",authors:"johnnyreilly",tags:["react","typescript"],image:"./title-image.png",description:"With TypeScript 5.1, it becomes possible for libraries to control what types are used for JSX elements. This post looks at why this matters.",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Azure Container Apps, Bicep, bring your own certificates and custom domains",permalink:"/azure-container-apps-bicep-bring-your-own-certificates-custom-domains"},nextItem:{title:"Azure Container Apps, Bicep, managed certificates and custom domains",permalink:"/azure-container-apps-bicep-managed-certificates-custom-domains"}},l={image:n(14129).A,authorsImageUrls:[void 0]},c=[{value:"What&#39;s the problem?",id:"whats-the-problem",level:2},{value:"The arrival of <code>JSX.ElementType</code>",id:"the-arrival-of-jsxelementtype",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components},{Head:r}=t;return r||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["A new feature arrives with TypeScript 5.1, ",(0,i.jsx)(t.a,{href:"https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-beta/#decoupled-type-checking-between-jsx-elements-and-jsx-tag-types",children:'it is described as "Decoupled Type-Checking Between JSX Elements and JSX Tag Types"'}),"."]}),"\n",(0,i.jsx)(t.p,{children:"It's all about handing control of JSX type definitions to libraries. With this feature, libraries can control what types are used for JSX elements. Why does this matter? Great question! Until version 5.1, TypeScript did an imperfect job of representing what is possible with JSX. This feature allows libraries to do a better job of that, and we'll look into it in this post."}),"\n",(0,i.jsxs)(t.p,{children:["It's probably worth saying, that this is a complicated feature. If you don't understand it (and as the author of this post I'll confess that I had to work quite hard to understand it), ",(0,i.jsx)(t.strong,{children:"that is okay"}),". This is a low level feature that is only likely to be used by library / type definition authors. It's a primitive that will unlock possibilites for people writing JSX - but it's something that people will mainly feel the benefit of, without directly doing anything themselves, or necessarily noticing that things have changed for the better."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"title image reading &quot;TypeScript 5.1: declaring JSX element types&quot; with the TypeScript logo",src:n(66050).A+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,i.jsx)(t.h2,{id:"whats-the-problem",children:"What's the problem?"}),"\n",(0,i.jsxs)(t.p,{children:["TypeScript creates a type system which sits on top of JavaScript, and provides static typing capabilities. As the language has grown more sophisticated, it has been able to get closer and closer to representing the full range of possibilities that JavaScript offers. As an example of this evolution, if you remember the early days of TypeScript, you'll remember a time before union types. Back then, you had to use ",(0,i.jsx)(t.code,{children:"any"})," to represent a value that could be one of a number of types. That imperfect representation of JavaScript was solved with union types:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:"-function printStringOrNumber(stringOrNumber: any) {\n+function printStringOrNumber(stringOrNumber: string | number) {\n    console.log(stringOrNumber);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The problem we're looking at here is in the same vein. But it specifically applies to JSX; which is widely used in libraries like React. With JSX support in TypeScript (up to and including 5.0), it was not possible to accurately represent all JSX possibilities. This is because the type of a JSX element returned from a function component was always ",(0,i.jsx)(t.code,{children:"JSX.Element | null"}),". This is a type that is defined in the TypeScript compiler, and is not something that can be changed by a library author."]}),"\n",(0,i.jsx)(t.p,{children:"How does this play out? Well, let's take a look at a simple example. Let's say we have a function component that returns a number. We might write something like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"function ComponentThatReturnsANumber() {\n  return 42;\n}\n\n<ComponentThatReturnsANumber />;\n"})}),"\n",(0,i.jsx)(t.p,{children:"The above is legitimate JSX, but it is not legitimate TypeScript. The TypeScript compiler will complain:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"screenshot of typescript playground saying &#39;ComponentThatReturnsANumber&#39; cannot be used as a JSX component. Its return type &#39;number&#39; is not a valid JSX element.(2786)",src:n(51056).A+"",width:"690",height:"298",loading:"lazy"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgIilQ3wG4AoczAVwDsNgJa4BhXSWpWmAFQAsUMZDGpRaAZwCCAOWogARkigAKAJRwA3uThwiIsXAAsAJgoBfSgB424Jl14ChSfRJlzFUOAHoAfOSA",children:"You can see this in the TypeScript Playground"})}),"\n",(0,i.jsxs)(t.p,{children:["This errors because function components that return anything but ",(0,i.jsx)(t.code,{children:"JSX.Element | null"})," are not allowed as element types in React according to TypeScript. However, in React, function components ",(0,i.jsx)(t.strong,{children:"can"})," return a ",(0,i.jsx)(t.code,{children:"ReactNode"}),". That type includes ",(0,i.jsx)(t.code,{children:"number | string | Iterable<ReactNode> | undefined"})," (",(0,i.jsxs)(t.a,{href:"https://github.com/reactjs/rfcs/pull/229",children:["and will likely include ",(0,i.jsx)(t.code,{children:"Promise<ReactNode>"})," in the future"]}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["As an aside, a return value of ",(0,i.jsx)(t.code,{children:"number"})," would be perfectly fine in class components - the restrictions are different there. I spoke to Sebastian about this and he said:"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["An interesting note is that before function components we did have full control. Due to ",(0,i.jsx)(t.code,{children:"ElementClass"}),", class components already could return ",(0,i.jsx)(t.code,{children:"ReactNode"})," at the type level. It was just function components that were missing full control (or any other component types Suspense or Profiler)."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"So this is the problem: is not possible to represent in TypeScript today what is actually possible in React (or other JSX libraries). Furthermore, what's returned from JSX may change over time, and TypeScript needs to be able to represent that."}),"\n",(0,i.jsxs)(t.h2,{id:"the-arrival-of-jsxelementtype",children:["The arrival of ",(0,i.jsx)(t.code,{children:"JSX.ElementType"})]}),"\n",(0,i.jsxs)(t.p,{children:["Sebastian Silbermann ",(0,i.jsx)(t.a,{href:"https://github.com/microsoft/TypeScript/pull/51328",children:"opened a pull request to TypeScript"}),'. It had the title "RFC: Consult new JSX.ElementType for valid JSX element types". In that PR Sebastian explained the issue we\'ve just looked at above, and proposed a solution. The solution was to introduce a new type, ',(0,i.jsx)(t.code,{children:"JSX.ElementType"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["To illustrate the what ",(0,i.jsx)(t.code,{children:"JSX.ElementType"})," actually is as compared to a JSX element, consider this illustration:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"// <Component />\n//  ^^^^^^^^^    JSX element type\n// ^^^^^^^^^^^^^ JSX element\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The significance of ",(0,i.jsx)(t.code,{children:"JSX.ElementType"})," is that it is used to represent the type of a JSX element and ",(0,i.jsx)(t.strong,{children:"allow library authors to control what types are used for JSX elements"}),". This control was not available before."]}),"\n",(0,i.jsxs)(t.p,{children:["The TypeScript pull request was merged, and so Sebastian (who helps maintain the React type definitions) exercised the new powers in ",(0,i.jsx)(t.a,{href:"https://github.com/DefinitelyTyped/DefinitelyTyped/pull/65135",children:"this pull request to the DefinitelyTyped repository for the React type definitions"}),". At the time of writing, this pull request is still open, but once merged and shipped the React community will feel the benefits."]}),"\n",(0,i.jsxs)(t.p,{children:["The changes are subtle; You can see in this pull request that ",(0,i.jsx)(t.code,{children:"ReactElement | null"})," is generally replaced with ",(0,i.jsx)(t.code,{children:"ReactNode"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:"     type JSXElementConstructor<P> =\n-        | ((props: P) => ReactElement<any, any> | null)\n+        | ((props: P) => ReactNode)\n         | (new (props: P) => Component<any, any>);\n"})}),"\n",(0,i.jsx)(t.p,{children:"Remember how we mentioned earlier on that function components couldn't return numbers? Let's look at the updated tests in the PR:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:"    const ReturnNumber = () => 0xeac1;\n+   const FCNumber: React.FC = ReturnNumber;\n    class RenderNumber extends React.Component {\n        render() {\n          return 0xeac1;\n        }\n    }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["With this change, React components that return numbers are now valid JSX elements. This is because ",(0,i.jsx)(t.code,{children:"JSX.ElementType"})," is now ",(0,i.jsx)(t.code,{children:"ReactNode"}),", which includes numbers. Essentially this represents that new things are possible as a consequence of this change. The library and type definition author now has more control over what is possible in JSX."]}),"\n",(0,i.jsx)(t.p,{children:"To quote Sebastian again:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Now we have control over any potential component type."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Let's look again at our component that produces a number again:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"function ComponentThatReturnsANumber() {\n  return 42;\n}\n\n<ComponentThatReturnsANumber />;\n"})}),"\n",(0,i.jsx)(t.p,{children:"With Sebastian's changes, this becomes valid TypeScript. And as React, and other JSX libraries evolve, TypeScript compatibility can also."}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(t.p,{children:['The TL;DR of this post is "TypeScript will better allow for the modelling of JSX in TypeScript 5.1". I\'m indebted to ',(0,i.jsx)(t.a,{href:"https://github.com/eps1lon",children:"Sebastian Silbermann"})," and ",(0,i.jsx)(t.a,{href:"https://github.com/DanielRosenwasser",children:"Daniel Rosenwasser"})," for their explanations of this feature. Thanks in particular to Sebastian for implementing this feature and for reviewing this post."]}),"\n",(0,i.jsx)(t.p,{children:"I hope this post helps you understand the feature a little better."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://blog.logrocket.com/declaring-jsx-types-typescript-5-1/",children:"This post was originally published on LogRocket."})}),"\n",(0,i.jsx)(r,{children:(0,i.jsx)("link",{rel:"canonical",href:"https://blog.logrocket.com/declaring-jsx-types-typescript-5-1/"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},14129:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-c27519b13ccfb42822abd1b70624ae01.png"},51056:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/screenshot-typescript-playground-8ad019b0cc457082ad80d30c000bc42c.png"},66050:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-c27519b13ccfb42822abd1b70624ae01.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(96540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);