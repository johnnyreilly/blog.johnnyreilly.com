"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[98088],{52585:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var i=n(74848),s=n(28453);const o={slug:"playwright-github-actions-and-azure-static-web-apps-staging-environments",title:"Playwright, GitHub Actions and Azure Static Web Apps staging environments",authors:"johnnyreilly",tags:["azure static web apps","github actions"],image:"./title-image.png",description:"Azure Static Web Apps staging environments allow you to test changes before they go live. This shows how to use Playwright against staging environments.",hide_table_of_contents:!1},a=void 0,r={permalink:"/playwright-github-actions-and-azure-static-web-apps-staging-environments",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-03-20-playwright-github-actions-and-azure-static-web-apps-staging-environments/index.md",source:"@site/blog/2023-03-20-playwright-github-actions-and-azure-static-web-apps-staging-environments/index.md",title:"Playwright, GitHub Actions and Azure Static Web Apps staging environments",description:"Azure Static Web Apps staging environments allow you to test changes before they go live. This shows how to use Playwright against staging environments.",date:"2023-03-20T00:00:00.000Z",tags:[{inline:!1,label:"Azure Static Web Apps",permalink:"/tags/azure-static-web-apps",description:"The Azure Static Web Apps service."},{inline:!1,label:"GitHub Actions",permalink:"/tags/github-actions",description:"The GitHub Actions CI / CD service."}],readingTime:9.005,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"playwright-github-actions-and-azure-static-web-apps-staging-environments",title:"Playwright, GitHub Actions and Azure Static Web Apps staging environments",authors:"johnnyreilly",tags:["azure static web apps","github actions"],image:"./title-image.png",description:"Azure Static Web Apps staging environments allow you to test changes before they go live. This shows how to use Playwright against staging environments.",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Bicep user defined types and Bash single item arrays",permalink:"/bicep-user-defined-types-and-bash-single-item-arrays"},nextItem:{title:"Migrating from ts-node to Bun",permalink:"/migrating-from-ts-node-to-bun"}},l={image:n(29333).A,authorsImageUrls:[void 0]},h=[{value:"Playwright, GitHub Actions and Azure Static Web Apps",id:"playwright-github-actions-and-azure-static-web-apps",level:2},{value:"Adding Playwright to the project",id:"adding-playwright-to-the-project",level:2},{value:"A test using <code>baseURL</code>",id:"a-test-using-baseurl",level:2},{value:"Creating a GitHub Actions workflow",id:"creating-a-github-actions-workflow",level:2},{value:"Site build and deploy \ud83c\udfd7\ufe0f",id:"site-build-and-deploy-\ufe0f",level:3},{value:"Integration tests \ud83d\udca1\ud83c\udfe0",id:"integration-tests-",level:3},{value:"How does it look?",id:"how-does-it-look",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Azure Static Web Apps staging environments allow you to test changes before they go live. This post shows how to use Playwright against staging environments with GitHub Actions. It's a follow up to my previous post on ",(0,i.jsx)(t.a,{href:"/lighthouse-meet-github-actions",children:"using Lighthouse with Azure Static Web Apps staging environments"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"title image reading &quot;Playwright, GitHub Actions and Azure Static Web Apps staging environments&quot; with product logos",src:n(12962).A+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,i.jsx)(t.h2,{id:"playwright-github-actions-and-azure-static-web-apps",children:"Playwright, GitHub Actions and Azure Static Web Apps"}),"\n",(0,i.jsx)(t.p,{children:"What's the problem we're trying to solve? Let's do our best Simon Sinek impression and start with \"Why?\". The \"Why?\" is that we want only to ship changes that haven't broken our application."}),"\n",(0,i.jsx)(t.p,{children:'Now let\'s move onto "How?" The way we guard against breaking production is by running automated tests on all changes. Playwright is a tool that allows us to do that. We get a fully fledged staging environment available to us on all pull requests. We want to run Playwright integration tests against our staging environment. We want to do this as part of our CI/CD pipeline; in our GitHub Actions workflow.'}),"\n",(0,i.jsxs)(t.p,{children:["I'm going to write about this in the context of my blog. My blog is open source and ",(0,i.jsx)(t.a,{href:"https://github.com/johnnyreilly/blog.johnnyreilly.com",children:"you can find the code here"}),". I'm going to present a simplified solution in this post, but you can find the full solution on GitHub."]}),"\n",(0,i.jsx)(t.h2,{id:"adding-playwright-to-the-project",children:"Adding Playwright to the project"}),"\n",(0,i.jsxs)(t.p,{children:["To add Playwright to my blog I followed the ",(0,i.jsx)(t.a,{href:"https://playwright.dev/docs/intro",children:"instructions on the Playwright website"}),". Essentially I ran the following command:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"npm init playwright@latest\n"})}),"\n",(0,i.jsxs)(t.p,{children:["By and large I accepted the defaults. However, I deleted the GitHub Actions workflow that was created, in favour of my own which we'll get to soon. I'd created my tests in a ",(0,i.jsx)(t.code,{children:"blog-website-tests"})," directory. This sits alongside the ",(0,i.jsx)(t.code,{children:"blog-website"})," directory which contains the code for my blog."]}),"\n",(0,i.jsxs)(t.p,{children:["I made one tweak to the ",(0,i.jsx)(t.code,{children:"playwright.config.ts"})," file that was created. I added the following line:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"//...\n\n/**\n * See https://playwright.dev/docs/test-configuration.\n */\nexport default defineConfig({\n  //...\n\n  use: {\n    //...\n\n    // WE WILL SET THIS IN THE GITHUB ACTIONS WORKFLOW\n    baseURL: process.env.PLAYWRIGHT_TEST_BASE_URL || 'http://localhost:3000',\n  },\n\n  //...\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["What's going on here? I'm setting the ",(0,i.jsx)(t.code,{children:"baseURL"})," to be the value of the ",(0,i.jsx)(t.code,{children:"PLAYWRIGHT_TEST_BASE_URL"})," environment variable. If that's not set then I'm defaulting to ",(0,i.jsx)(t.code,{children:"http://localhost:3000"}),", which is where my blog is served when running locally. I'll explain why I'm doing this in a moment."]}),"\n",(0,i.jsxs)(t.h2,{id:"a-test-using-baseurl",children:["A test using ",(0,i.jsx)(t.code,{children:"baseURL"})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://playwright.dev/docs/api/class-testoptions#test-options-base-url",children:(0,i.jsx)(t.code,{children:"baseURL"})})," can be used in a Playwright test to determine where to run the tests. That's exactly what I'm doing in the following test file named ",(0,i.jsx)(t.code,{children:"the.spec.ts"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { test, expect } from '@playwright/test';\n\ntest('page should have title and a root navigation link', async ({\n  page,\n  baseURL,\n}) => {\n  await page.goto(baseURL!);\n  const title = await page.title();\n  expect(title).toBe('johnnyreilly');\n\n  const navTitle = page.getByRole('link', {\n    name: 'Profile picture of John Reilly John Reilly \u2764\ufe0f\ud83c\udf3b',\n  });\n  await expect(navTitle).toBeVisible();\n});\n\ntest('can navigate to about page', async ({ page, baseURL }) => {\n  await page.goto(baseURL!);\n  await page.getByRole('link', { name: 'About', exact: true }).click();\n\n  const navTitle = page.getByRole('heading', {\n    name: \"Hi! I'm John Reilly - welcome! \u2764\ufe0f\ud83c\udf3b\",\n  });\n  await expect(navTitle).toBeVisible();\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"baseURL"})," is used in the ",(0,i.jsx)(t.code,{children:"page.goto"})," call. This means that the tests will run against the URL that I specify. In the case of the GitHub Actions workflow, I'll specify the URL of the staging environment. These are simple tests that check that the title of the page is correct and that I can navigate to the about page. Consider them smoke tests."]}),"\n",(0,i.jsx)(t.h2,{id:"creating-a-github-actions-workflow",children:"Creating a GitHub Actions workflow"}),"\n",(0,i.jsxs)(t.p,{children:["We now have a test that we can run against a URL. We need to create a GitHub Actions workflow that will run the test against the staging environment. I've created a workflow file named ",(0,i.jsx)(t.code,{children:"build-and-deploy-static-web-app.yml"})," in the ",(0,i.jsx)(t.code,{children:".github/workflows"})," directory. It looks like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yml",children:"name: Static Web App - Build and Deploy \ud83c\udfd7\ufe0f\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, synchronize, reopened, closed]\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  id-token: write # Require write permission to Fetch an OIDC token.\n  contents: write\n  pull-requests: write\n\nenv:\n  LOCATION: westeurope\n  STATICWEBAPPNAME: blog.johnnyreilly.com\n\njobs:\n  build_and_deploy_swa_job:\n    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')\n    runs-on: ubuntu-latest\n    name: Site build and deploy \ud83c\udfd7\ufe0f\n    steps:\n      - name: Checkout \ud83d\udce5\n        uses: actions/checkout@v3\n\n      # Auth between GitHub and Azure is handled by https://github.com/jongio/github-azure-oidc\n      # https://github.com/Azure/login#sample-workflow-that-uses-azure-login-action-using-oidc-to-run-az-cli-linux\n      # other login options are possible too\n      - name: AZ CLI login \ud83d\udd11\n        uses: azure/login@v2\n        with:\n          client-id: ${{ secrets.AZURE_CLIENT_ID }}\n          tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n\n      - name: Get preview URL \ud83d\udcdd\n        id: static_web_app_preview_url\n        uses: azure/CLI@v2\n        with:\n          inlineScript: |\n            DEFAULTHOSTNAME=$(az staticwebapp show -n '${{ env.STATICWEBAPPNAME }}' | jq -r '.defaultHostname')\n\n            PREVIEW_URL=\"https://${DEFAULTHOSTNAME/.[1-9]./-${{github.event.pull_request.number }}.${{ env.LOCATION }}.1.}\"\n\n            echo \"PREVIEW_URL=$PREVIEW_URL\" >> $GITHUB_OUTPUT\n\n      - name: Setup Node.js \ud83d\udd27\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'yarn'\n\n      - name: Install and build site \ud83d\udd27\n        run: |\n          cd blog-website\n          yarn install --frozen-lockfile\n          yarn run build\n          cp staticwebapp.config.json build/staticwebapp.config.json\n\n      - name: Get API key \ud83d\udd11\n        id: static_web_app_apikey\n        uses: azure/CLI@v2\n        with:\n          inlineScript: |\n            APIKEY=$(az staticwebapp secrets list --name '${{ env.STATICWEBAPPNAME }}' | jq -r '.properties.apiKey')\n            echo \"APIKEY=$APIKEY\" >> $GITHUB_OUTPUT\n\n      - name: Deploy site \ud83d\ude80\n        id: static_web_app_build_and_deploy\n        uses: Azure/static-web-apps-deploy@v1\n        with:\n          azure_static_web_apps_api_token: ${{ steps.static_web_app_apikey.outputs.APIKEY }}\n          repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments)\n          action: 'upload'\n          skip_app_build: true\n          app_location: '/blog-website/build' # App source code path\n          api_location: '/blog-website/api' # Api source code path - optional\n\n    outputs:\n      preview-url: ${{steps.static_web_app_preview_url.outputs.PREVIEW_URL}}\n\n  integration_tests_job:\n    name: Integration tests \ud83d\udca1\ud83c\udfe0\n    needs: build_and_deploy_swa_job\n    if: github.event_name == 'pull_request' && github.event.action != 'closed'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Wait for preview ${{ needs.build_and_deploy_swa_job.outputs.preview-url }} \u231a\n        id: static_web_app_wait_for_preview\n        uses: nev7n/wait_for_response@v1\n        with:\n          url: '${{ needs.build_and_deploy_swa_job.outputs.preview-url }}'\n          responseCode: 200\n          timeout: 600000\n          interval: 1000\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18\n\n      - name: Install dependencies\n        run: npm ci\n        working-directory: ./blog-website-tests\n\n      - name: Install Playwright Browsers\n        run: npx playwright install --with-deps\n        working-directory: ./blog-website-tests\n\n      - name: Run Playwright tests\n        env:\n          PLAYWRIGHT_TEST_BASE_URL: '${{ needs.build_and_deploy_swa_job.outputs.preview-url }}'\n        run: npx playwright test\n        working-directory: ./blog-website-tests\n\n      - uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: playwright-report\n          path: blog-website-tests/playwright-report/\n          retention-days: 30\n\n  close_pull_request_job:\n    if: github.event_name == 'pull_request' && github.event.action == 'closed'\n    runs-on: ubuntu-latest\n    name: Cleanup staging \ud83d\udca5\n    steps:\n      - name: AZ CLI login \ud83d\udd11\n        uses: azure/login@v2\n        with:\n          client-id: ${{ secrets.AZURE_CLIENT_ID }}\n          tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n\n      - name: Get API key \ud83d\udd11\n        id: apikey\n        uses: azure/CLI@v2\n        with:\n          inlineScript: |\n            APIKEY=$(az staticwebapp secrets list --name '${{ env.STATICWEBAPPNAME }}' | jq -r '.properties.apiKey')\n            echo \"APIKEY=$APIKEY\" >> $GITHUB_OUTPUT\n\n      - name: Destroy staging environment \ud83d\udca5\n        id: closepullrequest\n        uses: Azure/static-web-apps-deploy@v1\n        with:\n          azure_static_web_apps_api_token: ${{ steps.apikey.outputs.APIKEY }}\n          action: 'close'\n"})}),"\n",(0,i.jsx)(t.p,{children:"As I said earlier, this has been chopped down from the full version in my repo. It contains specific variables from my own project, but you can see the general structure of the workflow."}),"\n",(0,i.jsx)(t.p,{children:"Let's look at what happens above; there are 3 jobs:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Site build and deploy \ud83c\udfd7\ufe0f - This is the main job that builds the site and deploys it to the Static Web App."}),"\n",(0,i.jsx)(t.li,{children:"Integration tests \ud83d\udca1\ud83c\udfe0 - This job runs the Playwright tests against the preview URL of our Static Web App."}),"\n",(0,i.jsx)(t.li,{children:"Cleanup staging \ud83d\udca5 - This job runs when a pull request is closed, and destroys the staging environment."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Let's dig into 1 and 2 a bit more. We'll ignore 3 as it's pretty self explanatory."}),"\n",(0,i.jsx)(t.h3,{id:"site-build-and-deploy-\ufe0f",children:"Site build and deploy \ud83c\udfd7\ufe0f"}),"\n",(0,i.jsx)(t.p,{children:"This job is the main job that builds the site and deploys it to the Static Web App. It's a bit long, but it's not too complicated. Let's break it down:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Checkout \ud83d\udce5 - This is the first step, and it checks out the code from GitHub."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["AZ CLI login \ud83d\udd11 - This step logs into Azure using the ",(0,i.jsx)(t.code,{children:"azure/login"})," action. This is required to run the ",(0,i.jsx)(t.code,{children:"az"})," CLI commands."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Get preview URL \ud83d\udcdd - This step constructs the preview URL of the Static Web App using the ",(0,i.jsx)(t.code,{children:"defaultHostname"}),", the location of deployment, the pull request number and the partition id."]}),"\n",(0,i.jsxs)(t.p,{children:["The partition id is the ",(0,i.jsx)(t.code,{children:"1"})," in the URL. It matches whichever partition id that exists for the domain. Right now, if you create a new SWA, you will not get a ",(0,i.jsx)(t.code,{children:"1"})," since SWA is now on partition ",(0,i.jsx)(t.code,{children:"2"}),". When that partition gets filled, it will move on to partition ",(0,i.jsx)(t.code,{children:"3"}),". Ultimately, you just need to find out what the partition id for your SWA is, then you can hardcode it into your workflow."]}),"\n",(0,i.jsx)(t.p,{children:"The complete preview URL is required to run the Playwright tests against the preview URL."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Setup Node.js \ud83d\udd27 - This step sets up Node.js, which is required to build the site."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Install and build site \ud83d\udd27 - This step installs the dependencies and builds the site - we build our SWA ourselves; you can generally just leave this to the ",(0,i.jsx)(t.code,{children:"Azure/static-web-apps-deploy@v1"})," task. We don't because ",(0,i.jsx)(t.a,{href:"/migrating-from-ts-node-to-bun",children:"we have some post processing to do that requires Bun"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Get API key \ud83d\udd11 - This step gets the API key for the Static Web App. This is required to deploy the site."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Deploy site \ud83d\ude80 - This step deploys the site to the Static Web App."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"integration-tests-",children:"Integration tests \ud83d\udca1\ud83c\udfe0"}),"\n",(0,i.jsx)(t.p,{children:"Our tests job depends upon the previous job; specifically the preview URL of our Static Web App. You can't run Playwright tests if you've nothing to run them against! Again, let's dig into it:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Checkout \ud83d\udce5 - This is the first step, and it checks out the code from GitHub."}),"\n",(0,i.jsx)(t.li,{children:"Wait for preview ... \u231a - This step waits for the preview URL to be available. This is required because the Static Web App takes a few minutes to deploy, and we don't want to run the tests until it's deployed."}),"\n",(0,i.jsx)(t.li,{children:"Setup Node.js \ud83d\udd27 - This step sets up Node.js, which is required to run the tests."}),"\n",(0,i.jsx)(t.li,{children:"Install dependencies - This step installs the dependencies for the tests."}),"\n",(0,i.jsx)(t.li,{children:"Install Playwright Browsers - This step installs the browsers that Playwright will use to run the tests."}),"\n",(0,i.jsx)(t.li,{children:"Run Playwright tests - This step runs the Playwright tests."}),"\n",(0,i.jsx)(t.li,{children:"Upload test report - This step uploads the test report as an artifact. This is useful if you want to see the test report after the tests have run."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"how-does-it-look",children:"How does it look?"}),"\n",(0,i.jsx)(t.p,{children:"When we put all this together and push it up to GitHub, we see that tests run as part of the pull request:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Screenshot of the GitHub Action with passing tests",src:n(962).A+"",width:"921",height:"849",loading:"lazy"})}),"\n",(0,i.jsx)(t.p,{children:"This screenshot is taken directly from my own blog, and so includes things like Lighthouse that are excluded from this post. But what you can see is that tests are indeed running; and we can see the test report as an artifact:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Screenshot of the test report",src:n(49366).A+"",width:"996",height:"784",loading:"lazy"})}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"So there you have it; a simple way to run Playwright tests against your Static Web App. I hope you found this useful, and if you have any questions, please feel free to reach out to me."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},29333:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-3374754db55f364cd0bce20c5ff1c2c4.png"},962:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/screenshot-github-action-7af9b984dec3f0c523afc6f657b1a3fc.webp"},49366:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/screenshot-playwright-test-results-78f3fe2fb01270d10997e1994849d8a9.png"},12962:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-3374754db55f364cd0bce20c5ff1c2c4.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);