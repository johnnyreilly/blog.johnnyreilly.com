"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[53272],{21031:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var o=n(85893),i=n(11151);const r={slug:"migrating-azure-functions-node-js-v4-typescript",title:"Migrating to v4 Azure Functions Node.js with TypeScript",authors:"johnnyreilly",image:"./title-image.png",tags:["typescript","azure","azure functions","azure static web apps"],description:"Learn how to migrate a TypeScript Azure Functions app to the v4 Node.js programming model.",hide_table_of_contents:!1},s=void 0,a={permalink:"/migrating-azure-functions-node-js-v4-typescript",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-10-24-migrating-azure-functions-node-js-v4-typescript/index.md",source:"@site/blog/2023-10-24-migrating-azure-functions-node-js-v4-typescript/index.md",title:"Migrating to v4 Azure Functions Node.js with TypeScript",description:"Learn how to migrate a TypeScript Azure Functions app to the v4 Node.js programming model.",date:"2023-10-24T00:00:00.000Z",formattedDate:"October 24, 2023",tags:[{label:"typescript",permalink:"/tags/typescript"},{label:"azure",permalink:"/tags/azure"},{label:"azure functions",permalink:"/tags/azure-functions"},{label:"azure static web apps",permalink:"/tags/azure-static-web-apps"}],readingTime:7.555,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"migrating-azure-functions-node-js-v4-typescript",title:"Migrating to v4 Azure Functions Node.js with TypeScript",authors:"johnnyreilly",image:"./title-image.png",tags:["typescript","azure","azure functions","azure static web apps"],description:"Learn how to migrate a TypeScript Azure Functions app to the v4 Node.js programming model.",hide_table_of_contents:!1},unlisted:!1,nextItem:{title:"Bicep: Link Azure Application Insights to Static Web Apps",permalink:"/bicep-link-azure-application-insights-to-static-web-apps"}},c={image:n(99207).Z,authorsImageUrls:[void 0]},l=[{value:"1. Changes to make to the <code>package.json</code>",id:"1-changes-to-make-to-the-packagejson",level:2},{value:"2. Migrating a Function",id:"2-migrating-a-function",level:2},{value:"<code>import</code>s used",id:"imports-used",level:3},{value:"Hello <code>app</code>, goodbye <code>function.json</code>",id:"hello-app-goodbye-functionjson",level:3},{value:"Signature and types of our <code>function</code>",id:"signature-and-types-of-our-function",level:3},{value:"From <code>context.res</code> to <code>Promise&lt;HttpResponseInit&gt;</code>",id:"from-contextres-to-promisehttpresponseinit",level:3},{value:"<code>body -&gt; jsonBody</code>",id:"body---jsonbody",level:3},{value:"Runtime APIs",id:"runtime-apis",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["There's a new programming model available for Node.js Azure Functions known as v4. There's documentation out there for ",(0,o.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-node-upgrade-v4?tabs=v4",children:"how to migrate JavaScript Azure Functions from v3 to v4"}),", but at the time of writing, TypeScript wasn't covered."]}),"\n",(0,o.jsxs)(t.p,{children:["This post fills in the gaps for a TypeScript Azure Function. It's probably worth mentioning that ",(0,o.jsx)(t.a,{href:"https://johnnyreilly.com",children:"my blog"})," is an ",(0,o.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/static-web-apps/overview",children:"Azure Static Web App"})," with a TypeScript Node.js Azure Functions back end. So, this post is based on my experience migrating my blog to v4."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"title image reading &quot;Link Azure Application Insights to Static Web Apps with Bicep&quot; with the Bicep and Azure Static Web App logos",src:n(22982).Z+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,o.jsxs)(t.p,{children:["I'm going to walk through the migration of my blog from v3 to v4. This takes place in ",(0,o.jsx)(t.a,{href:"https://github.com/johnnyreilly/blog.johnnyreilly.com/pull/728/files",children:"this pull request"}),". I'll probably cover some of the ground of the offical JavaScript upgrade docs, but I'll also cover some of the TypeScript specific stuff."]}),"\n",(0,o.jsx)(t.p,{children:"There will be two main parts to this post:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Changes to make to ",(0,o.jsx)(t.code,{children:"package.json"})]}),"\n",(0,o.jsx)(t.li,{children:"Migrating a Function"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The second part will be the bulk of the post, but the first part is important too."}),"\n",(0,o.jsxs)(t.h2,{id:"1-changes-to-make-to-the-packagejson",children:["1. Changes to make to the ",(0,o.jsx)(t.code,{children:"package.json"})]}),"\n",(0,o.jsxs)(t.p,{children:["So, starting with the first part, there are three changes to make to the ",(0,o.jsx)(t.code,{children:"package.json"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:'  "dependencies": {\n+    "@azure/functions": "^4.0.1",\n  },\n  "devDependencies": {\n-    "@azure/functions": "^3.5.0",\n  },\n+  "main": "dist/src/functions/*/index.js"\n'})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Update the ",(0,o.jsx)(t.code,{children:"@azure/functions"})," dependency to ",(0,o.jsx)(t.code,{children:"^4.0.1"})," (or later)"]}),"\n",(0,o.jsxs)(t.li,{children:["The ",(0,o.jsx)(t.code,{children:"@azure/functions"})," dev dependency becomes a regular dependency - this is because we'll be using the package at runtime now - previously we just used it to get the types at build time"]}),"\n",(0,o.jsxs)(t.li,{children:["Add a ",(0,o.jsx)(t.code,{children:"main"})," property to the ",(0,o.jsx)(t.code,{children:"package.json"})," with a glob that matches the functions in your project; in my case ",(0,o.jsx)(t.code,{children:"dist/src/functions/*/index.js"})," - which will be our output from the TypeScript build"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["As I took care of ",(0,o.jsx)(t.strong,{children:"3."}),", I found myself changing the folder structure of my functions. Actually, this isn't mandatory, but it was tricky for me to come up with a glob for my current structure. So I moved things around - you may not need to. All that matters is that your glob matches the output of your build."]}),"\n",(0,o.jsx)(t.h2,{id:"2-migrating-a-function",children:"2. Migrating a Function"}),"\n",(0,o.jsxs)(t.p,{children:["In order that we can understand what migration looks like, we must first take a look at the v3 version of a function. Here's the ",(0,o.jsx)(t.code,{children:"fallback"})," function from my blog:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"import type { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\nimport { redirect } from './redirect';\nimport { saveToDatabase } from './saveToDatabase';\n\nconst httpTrigger: AzureFunction = async function (\n  context: Context,\n  req: HttpRequest,\n): Promise<void> {\n  try {\n    const originalUrl = req.headers['x-ms-original-url'];\n\n    const { status, location } = redirect(originalUrl, context.log);\n\n    await saveToDatabase(originalUrl, { status, location }, context.log);\n\n    context.res = {\n      status,\n      headers: {\n        location,\n      },\n    };\n  } catch (error) {\n    context.log.error(\n      'Problem with fallback',\n      error,\n      req.headers['x-ms-original-url'],\n    );\n  }\n};\n\nexport default httpTrigger;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The above is the code I use to power ",(0,o.jsx)(t.a,{href:"/azure-static-web-apps-dynamic-redirects-azure-functions",children:"dynamic redirects in my Azure Static Web App with the Azure Function back-end"}),". It's a TypeScript Azure Function that takes a request, redirects to a new location and saves metadata about the redirect to a database."]}),"\n",(0,o.jsxs)(t.p,{children:["Looking at the code now, I rather think I should have called the function ",(0,o.jsx)(t.code,{children:"redirect"})," rather than ",(0,o.jsx)(t.code,{children:"fallback"}),". I'll leave it as is for now, but I'll probably change it in the future."]}),"\n",(0,o.jsxs)(t.p,{children:["What the ",(0,o.jsx)(t.code,{children:"fallback"})," function does isn't significant for this post, but the structure is. Now let's look at the migrated version:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"import type {\n  HttpRequest,\n  HttpResponseInit,\n  InvocationContext,\n} from '@azure/functions';\nimport { app } from '@azure/functions';\n\nimport { redirect } from './redirect';\nimport { saveToDatabase } from './saveToDatabase';\n\nexport async function fallback(\n  request: HttpRequest,\n  context: InvocationContext,\n): Promise<HttpResponseInit> {\n  try {\n    const originalUrl = request.headers.get('x-ms-original-url') || '';\n\n    const { status, location } = redirect(originalUrl, context);\n\n    await saveToDatabase(originalUrl, { status, location }, context);\n\n    return {\n      status,\n      headers: {\n        location,\n      },\n    };\n  } catch (error) {\n    context.error(\n      'Problem with fallback',\n      error,\n      request.headers.get('x-ms-original-url'),\n    );\n    return {\n      status: 500,\n      body: 'something went wrong',\n    };\n  }\n}\n\napp.http('fallback', {\n  methods: ['GET'],\n  handler: fallback,\n});\n"})}),"\n",(0,o.jsx)(t.p,{children:"As we can see, the logic looks pretty much the same. But a lot has changed. What's different? We'll go through the changes one by one."}),"\n",(0,o.jsxs)(t.h3,{id:"imports-used",children:[(0,o.jsx)(t.code,{children:"import"}),"s used"]}),"\n",(0,o.jsxs)(t.p,{children:["Starting at the top, the ",(0,o.jsx)(t.code,{children:"import"}),"s we use are different:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:"-import type { AzureFunction, Context, HttpRequest } from '@azure/functions';\n+import type {\n+  HttpRequest,\n+  HttpResponseInit,\n+  InvocationContext,\n+} from '@azure/functions';\n+import { app } from '@azure/functions';\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We're no longer just importing types, we're importing the ",(0,o.jsx)(t.code,{children:"app"})," function from ",(0,o.jsx)(t.code,{children:"@azure/functions"})," also. The types that are being imported are different too. We're no longer importing ",(0,o.jsx)(t.code,{children:"AzureFunction, Context, HttpRequest"})," - instead we're importing ",(0,o.jsx)(t.code,{children:"HttpRequest, HttpResponseInit,  InvocationContext"}),"."]}),"\n",(0,o.jsxs)(t.h3,{id:"hello-app-goodbye-functionjson",children:["Hello ",(0,o.jsx)(t.code,{children:"app"}),", goodbye ",(0,o.jsx)(t.code,{children:"function.json"})]}),"\n",(0,o.jsxs)(t.p,{children:["As we saw, we're making use of the ",(0,o.jsx)(t.code,{children:"app"})," function from ",(0,o.jsx)(t.code,{children:"@azure/functions"}),". This is a new function that we use to register our Azure Functions. We no longer use ",(0,o.jsx)(t.code,{children:"function.json"}),". Instead we use ",(0,o.jsx)(t.code,{children:"app"}),". In the case of my ",(0,o.jsx)(t.code,{children:"fallback"})," Azure Functions, we register it like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"app.http('fallback', {\n  methods: ['GET'],\n  handler: fallback,\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We're registering an HTTP trigger called ",(0,o.jsx)(t.code,{children:"fallback"})," that responds to ",(0,o.jsx)(t.code,{children:"GET"})," requests. The ",(0,o.jsx)(t.code,{children:"handler"})," is the function that will be called when the trigger is invoked. There's more options available, but this is the minimum we need to register our function."]}),"\n",(0,o.jsxs)(t.p,{children:["This minimal TypeScript/JavaScript replaces the more verbose ",(0,o.jsx)(t.code,{children:"function.json"})," that used to sit alongside:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'{\n  "bindings": [\n    {\n      "authLevel": "anonymous",\n      "type": "httpTrigger",\n      "direction": "in",\n      "name": "req",\n      "methods": ["get", "post"]\n    },\n    {\n      "type": "http",\n      "direction": "out",\n      "name": "res"\n    }\n  ],\n  "scriptFile": "../dist/fallback/index.js"\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["All of this is gone, replaced by the ",(0,o.jsx)(t.code,{children:"app"})," function usage. There's one part of the ",(0,o.jsx)(t.code,{children:"function.json"})," that isn't covered by the ",(0,o.jsx)(t.code,{children:"app"})," function, and that's the ",(0,o.jsx)(t.code,{children:"scriptFile"})," property. This is covered by the ",(0,o.jsx)(t.code,{children:"main"})," property we added to the ",(0,o.jsx)(t.code,{children:"package.json"})," earlier."]}),"\n",(0,o.jsxs)(t.p,{children:["The rest of the ",(0,o.jsx)(t.code,{children:"function.json"})," is covered by the ",(0,o.jsx)(t.code,{children:"app.http"})," call. Much terser."]}),"\n",(0,o.jsxs)(t.h3,{id:"signature-and-types-of-our-function",children:["Signature and types of our ",(0,o.jsx)(t.code,{children:"function"})]}),"\n",(0,o.jsx)(t.p,{children:"The signature of our function has changed too:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:"-const httpTrigger: AzureFunction = async function (\n-  context: Context,\n-  req: HttpRequest\n-): Promise<void> {\n+export async function fallback(\n+  request: HttpRequest,\n+  context: InvocationContext,\n+): Promise<HttpResponseInit> {\n"})}),"\n",(0,o.jsxs)(t.p,{children:["You'll see here that we're using a function declaration rather than a function expression. Our new function takes our new types, the subtly different ",(0,o.jsx)(t.code,{children:"HttpRequest"})," and ",(0,o.jsx)(t.code,{children:"InvocationContext"}),", which are similar to, but different from, the previous ",(0,o.jsx)(t.code,{children:"Context"})," and ",(0,o.jsx)(t.code,{children:"HttpRequest"})," types. The order of these parameters has changed also."]}),"\n",(0,o.jsxs)(t.p,{children:["The return type of the function is now ",(0,o.jsx)(t.code,{children:"Promise<HttpResponseInit>"})," rather than ",(0,o.jsx)(t.code,{children:"Promise<void>"}),". What this means is, we're going to return values from our function, which we didn't do previously. Let's look at the implications of this."]}),"\n",(0,o.jsxs)(t.h3,{id:"from-contextres-to-promisehttpresponseinit",children:["From ",(0,o.jsx)(t.code,{children:"context.res"})," to ",(0,o.jsx)(t.code,{children:"Promise<HttpResponseInit>"})]}),"\n",(0,o.jsxs)(t.p,{children:["With a v3 function, we'd set the ",(0,o.jsx)(t.code,{children:"context.res"})," property to return values from our function. With a v4 function, we return values from our function directly. What does this look like?"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:"-    context.res = {\n-      status,\n-      headers: {\n-        location,\n-      },\n-    };\n+    return {\n+      status,\n+      headers: {\n+        location,\n+      },\n+    };\n"})}),"\n",(0,o.jsxs)(t.p,{children:["I rather like this change. My reasoning is that, in the event that there is subsequent code that would otherwise run after ",(0,o.jsx)(t.code,{children:"context.res"})," was set, we no longer need to remember to subsequently ",(0,o.jsx)(t.code,{children:"return"})," to prevent that running. (And yes, I have made that mistake on multiple occasions.) All we need do is return the value we want to return from our function."]}),"\n",(0,o.jsx)(t.h3,{id:"body---jsonbody",children:(0,o.jsx)(t.code,{children:"body -> jsonBody"})}),"\n",(0,o.jsxs)(t.p,{children:["Another difference is that we no longer set the ",(0,o.jsx)(t.code,{children:"body"})," property of the ",(0,o.jsx)(t.code,{children:"context.res"}),". Instead we return an object with a ",(0,o.jsx)(t.code,{children:"jsonBody"})," property, assuming we're returning JSON from our API. (And that's the most common case, right?)"]}),"\n",(0,o.jsxs)(t.p,{children:["This wasn't illustrated in the ",(0,o.jsx)(t.code,{children:"fallback"})," function above, but here's an example of migrating a function that returns JavaScript object literal named ",(0,o.jsx)(t.code,{children:"redirectSummary"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:"-    context.res = {\n-      status: 200,\n-      body: redirectSummary,\n-    };\n+    return {\n+      status: 200,\n+      jsonBody: redirectSummary,\n+    };\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"body"})," property still exists, but it's for returning strings and other things, rather than JSON. If you're returning JSON, the easiest approach is to use the ",(0,o.jsx)(t.code,{children:"jsonBody"})," property."]}),"\n",(0,o.jsx)(t.h3,{id:"runtime-apis",children:"Runtime APIs"}),"\n",(0,o.jsxs)(t.p,{children:["Finally, the APIs offered by the ",(0,o.jsx)(t.code,{children:"request"})," and ",(0,o.jsx)(t.code,{children:"context"})," objects are different. I shan't go into detail here as it's ",(0,o.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-node-upgrade-v4?tabs=v4#review-your-usage-of-http-types",children:"well covered in the official documentation"}),". But I will show you one of the changes I made to my ",(0,o.jsx)(t.code,{children:"fallback"})," function:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-diff",children:"-    const originalUrl = req.headers['x-ms-original-url'];\n+    const originalUrl = request.headers.get('x-ms-original-url') || '';\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Not too significant a tweak, but there's a number of slight changes like this to make. (Related to this, the logging API on the ",(0,o.jsx)(t.code,{children:"context"})," object is also different - but not significantly.)"]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"Migrating an Azure Function from v3 to v4 with TypeScript is a little more involved than I'd expected. But I do like that this moves us to a code style that feels more \"Node-y\". The official documentation is good, but it's not complete right now."}),"\n",(0,o.jsx)(t.p,{children:"Hopefully this post will help you migrate your TypeScript Azure Functions to v4."})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},99207:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/title-image-e16bb3c85ded7aa934b9ef8a41a2541a.png"},22982:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/title-image-e16bb3c85ded7aa934b9ef8a41a2541a.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>s});var o=n(67294);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);