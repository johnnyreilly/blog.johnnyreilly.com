"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[4942],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var i=n(96540);const a={},r=i.createContext(a);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:t},e.children)}},59310:e=>{e.exports=JSON.parse('{"permalink":"/web-workers-comlink-vite-tanstack-query","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2024-06-23-web-workers-comlink-vite-tanstack-query/index.md","source":"@site/blog/2024-06-23-web-workers-comlink-vite-tanstack-query/index.md","title":"Web Workers, Comlink, Vite and TanStack Query","description":"Web Workers are a great way to offload work from the main thread. Comlink is a delightful way to communicate with Web Workers. TanStack Query is an awesome way to bring them together.","date":"2024-06-23T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/tags/typescript","description":"The TypeScript programming language."},{"inline":false,"label":"React","permalink":"/tags/react","description":"The React library."}],"readingTime":5.79,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"web-workers-comlink-vite-tanstack-query","title":"Web Workers, Comlink, Vite and TanStack Query","authors":"johnnyreilly","tags":["typescript","react"],"image":"./title-image.png","description":"Web Workers are a great way to offload work from the main thread. Comlink is a delightful way to communicate with Web Workers. TanStack Query is an awesome way to bring them together.","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"MUI React Tree View: pass data to TreeItem","permalink":"/mui-react-tree-view-pass-data-to-treeitem"},"nextItem":{"title":"Static Web Apps CLI: improve performance with Vite server proxy","permalink":"/static-web-apps-cli-improve-performance-with-vite-server-proxy"}}')},62121:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-734455bc3d473a791221ef8db78f23ac.png"},78981:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var i=n(59310),a=n(74848),r=n(28453);const o={slug:"web-workers-comlink-vite-tanstack-query",title:"Web Workers, Comlink, Vite and TanStack Query",authors:"johnnyreilly",tags:["typescript","react"],image:"./title-image.png",description:"Web Workers are a great way to offload work from the main thread. Comlink is a delightful way to communicate with Web Workers. TanStack Query is an awesome way to bring them together.",hide_table_of_contents:!1},s=void 0,l={image:n(62121).A,authorsImageUrls:[void 0]},c=[{value:"A use case for Web Workers",id:"a-use-case-for-web-workers",level:2},{value:"Vite Comlink setup with <code>vite-plugin-comlink</code>",id:"vite-comlink-setup-with-vite-plugin-comlink",level:2},{value:"Migrating our expensive calculations to Comlink",id:"migrating-our-expensive-calculations-to-comlink",level:2},{value:"Using TanStack Query to interact with the Comlink Web Worker",id:"using-tanstack-query-to-interact-with-the-comlink-web-worker",level:2},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["I've written previously about combining ",(0,a.jsx)(t.a,{href:"/web-workers-comlink-typescript-and-react",children:"Web Workers and Comlink"}),". I recently found myself needing to use Web Workers again. As I picked them up this time I found myself making some different choices, now I was working in a codebase that used Vite to build. I ended up using ",(0,a.jsx)(t.a,{href:"https://github.com/tanstack/query",children:"TanStack Query"})," in combination with my ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"Web Workers"})," and ",(0,a.jsx)(t.a,{href:"https://github.com/GoogleChromeLabs/comlink",children:"Comlink"}),". It was a really good fit and this post will show you how to use Web Workers with Comlink and TanStack Query."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"title image reading &quot;Web Workers, Comlink, Vite and TanStack Query&quot; with logos",src:n(82596).A+"",width:"800",height:"450",loading:"lazy"})}),"\n",(0,a.jsx)(t.h2,{id:"a-use-case-for-web-workers",children:"A use case for Web Workers"}),"\n",(0,a.jsx)(t.p,{children:"Web Workers are a great way to offload work from the main thread. This can be particularly useful if you have a long running task that you don't want to block the UI thread. In my case, I was working on a feature that required a lot of computation. I wanted to keep the UI responsive whilst the numbers got crunched."}),"\n",(0,a.jsxs)(t.p,{children:["Imagine the following function in our ",(0,a.jsx)(t.code,{children:"calculations.ts"})," file:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"export function expensiveCalculation(\n  data: BigLumpOfData,\n  from: Date,\n  to: Date,\n): number {\n  // SUPER EXPENSIVE COMPUTATION CODE HERE...\n  return importantNumber;\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This function is doing some very expensive computation. We don't want to block the main thread with it. We want to use a Web Worker to offload this work. But the naked Web Worker API is a bit of a pain to work with. Instead then, we can use Comlink to make it easier."}),"\n",(0,a.jsxs)(t.h2,{id:"vite-comlink-setup-with-vite-plugin-comlink",children:["Vite Comlink setup with ",(0,a.jsx)(t.code,{children:"vite-plugin-comlink"})]}),"\n",(0,a.jsxs)(t.p,{children:["As I've mentioned, we're working with Vite in this codebase. To get Comlink working with Vite, we can use the dedicated plugin named ",(0,a.jsx)(t.a,{href:"https://github.com/mathe42/vite-plugin-comlink",children:(0,a.jsx)(t.code,{children:"vite-plugin-comlink"})}),". It is a wrapper around Comlink that simplifies using it with Vite."]}),"\n",(0,a.jsx)(t.p,{children:"To get started, we need to install the plugin and Comlink:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"npm i --save-dev vite-plugin-comlink\nnpm i --save comlink\n"})}),"\n",(0,a.jsx)(t.p,{children:"We need the plugin at build time and Comlink at runtime. We can then add the plugin to our Vite config:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"import react from '@vitejs/plugin-react';\nimport { defineConfig } from 'vite';\nimport { comlink } from 'vite-plugin-comlink';\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [comlink(), react()],\n  worker: {\n    plugins: () => [comlink()],\n  },\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that we're adding the ",(0,a.jsx)(t.code,{children:"comlink"})," plugin to both the main Vite config and the worker config. This is because we want to use Comlink in both places. The order of the plugins is important. We want to make sure that ",(0,a.jsx)(t.code,{children:"comlink"})," is added right at the start."]}),"\n",(0,a.jsxs)(t.p,{children:["This is a TypeScript project, so we update our ",(0,a.jsx)(t.code,{children:"vite-env.d.ts"})," file to include the Comlink types:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'/// <reference types="vite/client" />\n/// <reference types="vite-plugin-comlink/client" />\n'})}),"\n",(0,a.jsx)(t.h2,{id:"migrating-our-expensive-calculations-to-comlink",children:"Migrating our expensive calculations to Comlink"}),"\n",(0,a.jsx)(t.p,{children:"Now we have Comlink set up, we can move our expensive calculations to a Web Worker. This is very easily achieved; we just need to create a variable that points to our Web Worker file:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"const calculationsWorker = new ComlinkWorker<\n  typeof import('./calculations.js')\n>(new URL('./calculations.js', import.meta.url), {\n  name: 'calculationsComlink',\n  type: 'module',\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["There's not much code above, but it's doing a lot. We're creating a new Web Worker with Comlink using the ",(0,a.jsx)(t.code,{children:"ComlinkWorker"}),". This is an affordance provided by ",(0,a.jsx)(t.code,{children:"vite-plugin-comlink"})," and it creates a Web Worker with Comlink. We're pointing it at our ",(0,a.jsx)(t.code,{children:"calculations.js"})," file (",(0,a.jsx)(t.code,{children:".js"})," as this is an ESM import representing the ",(0,a.jsx)(t.code,{children:"calculations.ts"})," file). We're also giving the Web Worker a name, ",(0,a.jsx)(t.code,{children:"calculationsComlink"})," - this will be handy when debugging. Finally, we're telling the Web Worker that it's a module. So we can use ESM imports in our Web Worker. Actually, we're not do that right now, but we could."]}),"\n",(0,a.jsxs)(t.p,{children:["Note also that the types will be inferred from the ",(0,a.jsx)(t.code,{children:"calculations.js"})," file thanks to the ",(0,a.jsx)(t.code,{children:"typeof import('./calculations.js')"}),". This is a really nice feature of TypeScript."]}),"\n",(0,a.jsxs)(t.p,{children:["The API of the ",(0,a.jsx)(t.code,{children:"calculationsWorker"})," is the same as the ",(0,a.jsx)(t.code,{children:"calculations.ts"})," file, with one subtle difference. All sync functions will move to being ",(0,a.jsx)(t.code,{children:"Promise"})," based. So the API of the ",(0,a.jsx)(t.code,{children:"calculationsWorker"})," is"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"expensiveCalculation: (data: BigLumpOfData, from: Date, to: Date) =>\n  Promise<number>;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Which is pretty much the same as the original function in ",(0,a.jsx)(t.code,{children:"calculations.ts"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"expensiveCalculation: (data: BigLumpOfData, from: Date, to: Date) => number;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The only difference is that the return type is now a ",(0,a.jsx)(t.code,{children:"Promise<number>"})," rather than a ",(0,a.jsx)(t.code,{children:"number"}),". If your function was ",(0,a.jsx)(t.code,{children:"async"})," / ",(0,a.jsx)(t.code,{children:"Promise"}),"-based originally, then the API remains identical."]}),"\n",(0,a.jsx)(t.p,{children:"Incidentally; this is terrific. The journey from a standard codebase to a Web Worker enabled codebase is really smooth."}),"\n",(0,a.jsx)(t.h2,{id:"using-tanstack-query-to-interact-with-the-comlink-web-worker",children:"Using TanStack Query to interact with the Comlink Web Worker"}),"\n",(0,a.jsx)(t.p,{children:"The final piece of the puzzle is to use TanStack Query (AKA React Query) to interact with our Web Worker. TanStack Query is a fantastic library for managing data in applications. It's a great fit for working with our Web Worker because it's designed to work with async data. We can use TanStack Query to manage interactions with our Web Worker."}),"\n",(0,a.jsx)(t.p,{children:"To install it we run:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"npm i @tanstack/react-query\n"})}),"\n",(0,a.jsx)(t.p,{children:"We can then use it in our component like so:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"const expensiveCalculationResult = useQuery({\n  queryKey: ['expensiveCalculation', data, from, to],\n  queryFn: () =>\n    calculationsWorker.expensiveCalculation(data, new Date(from), new Date(to)),\n  staleTime: Infinity,\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is a pretty standard use of TanStack Query. We're using the ",(0,a.jsx)(t.code,{children:"useQuery"})," hook to fetch data. We're passing in a ",(0,a.jsx)(t.code,{children:"queryKey"})," that represents the data we're fetching. We're passing in a ",(0,a.jsx)(t.code,{children:"queryFn"})," that fetches the data. In this case, it's calling our Web Worker. We're also setting ",(0,a.jsx)(t.code,{children:"staleTime"})," to ",(0,a.jsx)(t.code,{children:"Infinity"})," so that the data never goes stale. This is an optimisation, because we're not going to be refetching the data unless the dependencies change. (If you'd like to understand more about ",(0,a.jsx)(t.code,{children:"staleTime"})," read ",(0,a.jsx)(t.a,{href:"https://tkdodo.eu/blog/practical-react-query#the-defaults-explained",children:"TkDodo's excellent post"}),")."]}),"\n",(0,a.jsx)(t.p,{children:"This is a really nice way to interact with our Web Worker. We're using TanStack Query to manage the data fetching and Comlink to interact with the Web Worker. It's a really nice fit."}),"\n",(0,a.jsx)(t.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,a.jsx)(t.p,{children:"Here's the full component that uses the Web Worker, Comlink and TanStack Query:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"import { useQuery } from '@tanstack/react-query';\n\nconst calculationsWorker = new ComlinkWorker<\n  typeof import('./calculations.js')\n>(new URL('./calculations.js', import.meta.url), {\n  name: 'calculationsComlink',\n  type: 'module',\n});\n\nexport function WorkerDemo({\n  data,\n  from,\n  to,\n}: {\n  data: BigLumpOfData;\n  from: string;\n  to: string;\n}) {\n  const expensiveCalculationResult = useQuery({\n    queryKey: ['expensiveCalculation', data, from, to],\n    queryFn: () =>\n      calculationsWorker.expensiveCalculation(\n        data,\n        new Date(from),\n        new Date(to),\n      ),\n    staleTime: Infinity,\n  });\n\n  return (\n    <div>\n      <h1>Web Workers, Comlink and Tanstack Query in action!</h1>\n\n      {expensiveCalculationResult.data ? (\n        <p>Calculation result: {expensiveCalculationResult.data}</p>\n      ) : expensiveCalculationResult.isPending ? (\n        <p>Calculating...</p>\n      ) : expensiveCalculationResult.error ? (\n        <p>Error: {expensiveCalculationResult.error}</p>\n      ) : (\n        <p>...</p>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This is a really nice way to use Web Workers with TanStack Query. We're using Comlink to interact with the Web Worker and TanStack Query to manage the data fetching. It's a really nice fit. I hope this helps you to use Web Workers in your Vite projects. Enjoy!"})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},82596:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/title-image-734455bc3d473a791221ef8db78f23ac.png"}}]);