"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[91663],{16561:e=>{e.exports=JSON.parse('{"permalink":"/serialising-aspnet-method-calls-for-later-execution","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2024-05-12-serialising-aspnet-method-calls-for-later-execution/index.md","source":"@site/blog/2024-05-12-serialising-aspnet-method-calls-for-later-execution/index.md","title":"Serialising ASP.NET method calls for later execution","description":"How can we take a method call, serialise it, perhaps store it in a database, and then later rehydrate and execute?","date":"2024-05-12T00:00:00.000Z","tags":[{"inline":false,"label":"Azure","permalink":"/tags/azure","description":"The Microsoft cloud platform."},{"inline":false,"label":"C#","permalink":"/tags/csharp","description":"The C# programming language."}],"readingTime":5.63,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"serialising-aspnet-method-calls-for-later-execution","title":"Serialising ASP.NET method calls for later execution","authors":"johnnyreilly","image":"./title-image.png","tags":["azure","c#"],"description":"How can we take a method call, serialise it, perhaps store it in a database, and then later rehydrate and execute?","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"MUI React Tree View: check children, uncheck parents","permalink":"/mui-react-tree-view-check-children-uncheck-parents"},"nextItem":{"title":"Large Language Models, Open API, View Models and the Backend for Frontend Pattern","permalink":"/large-language-models-view-models-backend-for-frontend"}}')},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(96540);const o={},r=a.createContext(o);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}},47092:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/title-image-0c2344bb797a565a0d579f3ef0c011c3.png"},58981:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/title-image-0c2344bb797a565a0d579f3ef0c011c3.png"},71558:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var a=n(16561),o=n(74848),r=n(28453);const i={slug:"serialising-aspnet-method-calls-for-later-execution",title:"Serialising ASP.NET method calls for later execution",authors:"johnnyreilly",image:"./title-image.png",tags:["azure","c#"],description:"How can we take a method call, serialise it, perhaps store it in a database, and then later rehydrate and execute?",hide_table_of_contents:!1},s=void 0,l={image:n(47092).A,authorsImageUrls:[void 0]},d=[{value:"What does serialising our method call require?",id:"what-does-serialising-our-method-call-require",level:2},{value:"How do we serialise our method call?",id:"how-do-we-serialise-our-method-call",level:2},{value:"How do we deserialise our method call and execute it?",id:"how-do-we-deserialise-our-method-call-and-execute-it",level:2},{value:"How do we use the <code>MethodCallInvoker</code>?",id:"how-do-we-use-the-methodcallinvoker",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Let's start with \"why\". Imagine you have an operation that you'd like to perform, but before that operation is performed, some other things need to take place first. Maybe it needs to be approved by someone, maybe you need an explicit record of what method is to be executed."}),"\n",(0,o.jsx)(t.p,{children:"Now you could build a mechanism to manually cater for each scenario that triggered a method call. But that's a lot of boilerplate code for each implementation, and given we might want to cater for many scenarios, it wouldn't scale particularly well as an approach."}),"\n",(0,o.jsx)(t.p,{children:"So how can we take a method call, serialise it, perhaps store it in a database, and then later rehydrate and execute?"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"title image reading &quot;Serialising ASP.NET method calls for later execution&quot; with the C# logo",src:n(58981).A+"",width:"800",height:"450",loading:"lazy"})}),"\n",(0,o.jsx)(t.h2,{id:"what-does-serialising-our-method-call-require",children:"What does serialising our method call require?"}),"\n",(0,o.jsx)(t.p,{children:"To serialise a method call, what do we need to store? Three things:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"The type of object that contains the method we want to subsequently invoke"}),"\n",(0,o.jsx)(t.li,{children:"The method on that object"}),"\n",(0,o.jsx)(t.li,{children:"The parameter values that will be passed to the method when it is called"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Pretty simple, right? It's worth highlighting that there is an underlying assumption for this approach:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"The method call does not depend on the object being in a specific state for the operation to succeed."})}),"\n",(0,o.jsxs)(t.p,{children:["So if, before calling a method on that object, you need to call another method called ",(0,o.jsx)(t.code,{children:"OpenConnection"})," (for example) then this approach would not work. Likewise if subsequent cleanup is required after a method is called, this approach would not work."]}),"\n",(0,o.jsx)(t.p,{children:"The analogy may not be entirely accurate, but think of each method call as needing to be an atomic operation and you're probably heading in the right direction."}),"\n",(0,o.jsx)(t.h2,{id:"how-do-we-serialise-our-method-call",children:"How do we serialise our method call?"}),"\n",(0,o.jsxs)(t.p,{children:["First of all, we need a data structure to store the information we need. We could use a ",(0,o.jsx)(t.code,{children:"record"})," like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"public record MethodCall(string ServiceName, string MethodName, object[] Parameters);\n"})}),"\n",(0,o.jsx)(t.p,{children:"This record will store the name of the service, the name of the method, and the parameters that will be passed to the method when it is called."}),"\n",(0,o.jsx)(t.p,{children:"Next we need an example service that we can call. For instance:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:"public interface IOurService\n{\n    Task<bool> DoAThing(string name, decimal amount, bool isApproved);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"An implementation of this service would be registered with the DI container when the application starts up. We don't need to know anything about the implementation of the service, just that it exists and that we can call methods on it."}),"\n",(0,o.jsx)(t.p,{children:"If we consider a call to this method, it might look like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:'IOurService.DoAThing("the name", 100m, true);\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The above can be represented as a ",(0,o.jsx)(t.code,{children:"MethodCall"})," like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:'MethodCall methodCall = new (\n    ServiceName: typeof(IOurService).FullName ?? throw new InvalidOperationException("Service name cannot be null"),\n    MethodName: nameof(IOurService.DoAThing),\n    Parameters: [ "the name", 100m, true]\n);\n'})}),"\n",(0,o.jsxs)(t.p,{children:["I'm not going to do so in this post, but the ",(0,o.jsx)(t.code,{children:"MethodCall"})," could be stored in a database. This is powerful because it means that we can store the method call, and then later rehydrate it and execute it."]}),"\n",(0,o.jsx)(t.h2,{id:"how-do-we-deserialise-our-method-call-and-execute-it",children:"How do we deserialise our method call and execute it?"}),"\n",(0,o.jsxs)(t.p,{children:["Now that we've looked at how to serialise a method call, let's look at how we can deserialise and execute it. We need a class that can take a ",(0,o.jsx)(t.code,{children:"MethodCall"})," and execute it. Herewith the ",(0,o.jsx)(t.code,{children:"MethodCallInvoker"})," class that does just that:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:'public class MethodCallInvoker(\n    IServiceProvider serviceProvider,\n    MethodCall operation\n)\n{\n    public async Task<object?> InvokeAsync()\n    {\n        Type? serviceType = Type.GetType(operation.ServiceName ?? throw new InvalidOperationException("Service name cannot be null"));\n        object? service = serviceProvider.GetService(serviceType ?? throw new InvalidOperationException("Service type cannot be null"));\n        MethodInfo? serviceMethod = serviceType.GetMethod(operation.MethodName) ?? throw new InvalidOperationException("Method info cannot be null");\n\n        List<object> parameters = [];\n        ParameterInfo[] requiredParameters = serviceMethod.GetParameters();\n        for (int i = 0; i < requiredParameters.Length; i++)\n        {\n            ParameterInfo requiredParameter = requiredParameters[i];\n            object? suppliedParameter = operation.Parameters[i];\n\n            bool suppliedValueIsOfCorrectType = requiredParameter.ParameterType == suppliedParameter.GetType();\n\n            if (suppliedValueIsOfCorrectType)\n                parameters.Add(operation.Parameters[i]);\n            else\n                // Convert.ChangeType is used to convert the supplied parameter to the required type eg from double to decimal\n                parameters.Add(Convert.ChangeType(suppliedParameter, requiredParameter.ParameterType, CultureInfo.InvariantCulture));\n        }\n\n        Task? task = (Task?)serviceMethod.Invoke(service, [..parameters]) ?? throw new InvalidOperationException($"Method {operation.MethodName} did not return a task");\n\n        await task;\n\n        object? result = null;\n        if (task.GetType().IsGenericType && task.GetType().GetGenericTypeDefinition() == typeof(Task<>))\n        {\n            // Get the result using reflection\n            PropertyInfo? resultProperty = task.GetType().GetProperty("Result");\n            result = resultProperty?.GetValue(task);\n        }\n\n        return result;\n    }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"MethodCallInvoker"})," class takes an ",(0,o.jsx)(t.code,{children:"IServiceProvider"})," and a ",(0,o.jsx)(t.code,{children:"MethodCall"})," in its constructor. Remember that the ",(0,o.jsx)(t.code,{children:"IServiceProvider"})," can be used to get a service that has been registered with the DI container. By giving the ",(0,o.jsx)(t.code,{children:"MethodCallInvoker"})," the ",(0,o.jsx)(t.code,{children:"IServiceProvider"}),", we can get the service that we need to call the method on. The ",(0,o.jsx)(t.code,{children:"InvokeAsync"})," method uses reflection to get the service, and the method that needs to be called."]}),"\n",(0,o.jsxs)(t.p,{children:["We then do some more reflection gymnastics to ensure that the parameters that are passed to the method are of the correct type. When it deserialises the parameters, the converter will make a best guess on the types of the parameters. If a parameter is not of the correct type, it uses ",(0,o.jsx)(t.code,{children:"Convert.ChangeType"})," to convert the parameter to the correct type. The canonical example of this is converting a ",(0,o.jsx)(t.code,{children:"double"})," to a ",(0,o.jsx)(t.code,{children:"decimal"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["With all this done, the ",(0,o.jsx)(t.code,{children:"MethodCallInvoker"})," is ready to call the method. Because it's likely that the method being invoked will be an ",(0,o.jsx)(t.code,{children:"async"})," method, we expect them to return a ",(0,o.jsx)(t.code,{children:"Task"}),". It's possible there may be a value returned as well, and if there is we unwrap it from the ",(0,o.jsx)(t.code,{children:"Task"})," and return it."]}),"\n",(0,o.jsxs)(t.h2,{id:"how-do-we-use-the-methodcallinvoker",children:["How do we use the ",(0,o.jsx)(t.code,{children:"MethodCallInvoker"}),"?"]}),"\n",(0,o.jsx)(t.p,{children:"Let's do an end to end demonstration of how to serialise a method call, deserialise it and execute it. Here's how you can do it:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cs",children:'MethodCall methodCall = new (\n    ServiceName: typeof(IOurService).FullName ?? throw new InvalidOperationException("Service name cannot be null"),\n    MethodName: nameof(IOurService.DoAThing),\n    Parameters: [ "the name", 100m, true]\n);\nstring json = Newtonsoft.Json.JsonConvert.SerializeObject(methodCall);\nMethodCall deserialized = Newtonsoft.Json.JsonConvert.DeserializeObject<MethodCall>(json) ?? throw new Exception("Problem deserializing");\nobject? result = await new MethodCallInvoker(_serviceProvider, deserialized).InvokeAsync();\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The above code serialises the ",(0,o.jsx)(t.code,{children:"MethodCall"})," to a JSON string, deserialises it back to a ",(0,o.jsx)(t.code,{children:"MethodCall"}),", and then uses the ",(0,o.jsx)(t.code,{children:"MethodCallInvoker"})," to execute the method."]}),"\n",(0,o.jsxs)(t.p,{children:["Why are we using ",(0,o.jsx)(t.code,{children:"Newtonsoft.Json"})," for our serialisation / deserialisation in this example? We don't have to, but let's say we're persisting this method call to a Cosmos DB, Cosmos uses JSON.NET for JSON handling. So this somewhat simulates what would happen during a potential persistence to a Cosmos container / subsequent loading from a Cosmos container. Otherwise I'd likely use ",(0,o.jsx)(t.code,{children:"System.Text.Json"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"In this post, we've looked at how we can serialise a method call (which could be stored in a database), and then later rehydrate and execute it. We've seen how we can use reflection to get the service and method that we need to call, and how we can convert the parameters to the correct type."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);