"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([["50770"],{71084:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return a},metadata:function(){return i},toc:function(){return u}});var i=t(54169),r=t(85893),o=t(50065);let a={slug:"the-mysterious-case-of-webpack-angular-and-jquery",title:"The Mysterious Case of webpack, AngularJS and jQuery",authors:"johnnyreilly",tags:["angularjs","webpack","jquery"],hide_table_of_contents:!1,description:"Angular can use jQuery instead of jQLite, but this becomes complicated when using webpack. We need to use the ProvidePlugin function in webpack.config.js."},s=void 0,l={authorsImageUrls:[void 0]},u=[{value:"But wait! I&#39;m using webpack",id:"but-wait-im-using-webpack",level:2},{value:"You need the <code>ProvidePlugin</code>",id:"you-need-the-provideplugin",level:2}];function c(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["You may know that ",(0,r.jsx)(n.a,{href:"https://docs.angularjs.org/api/ng/function/angular.element",children:"Angular ships with a cutdown version of jQuery called jQLite"}),". It's still possible to use the full-fat jQuery; to quote the docs:"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["To use ",(0,r.jsx)(n.code,{children:"jQuery"}),", simply ensure it is loaded before the ",(0,r.jsx)(n.code,{children:"angular.js"})," file."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Now the wording rather implies that you're not using any module loader / bundler. Rather that all files are being loaded via ",(0,r.jsx)(n.code,{children:"script"})," tags and relies on the global variables that result from that. True enough, if you take a look at the ",(0,r.jsx)(n.a,{href:"https://github.com/angular/angular.js/blob/eaa1119d4252bed08dfa42f984ef9502d0f02775/src/Angular.js#L1791",children:"Angular source"})," you can see how this works:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// bind to jQuery if present;\nvar jqName = jq();\njQuery = isUndefined(jqName)\n  ? window.jQuery // use jQuery (if present)\n  : !jqName\n  ? undefined // use jqLite\n  : window[jqName]; // use jQuery specified by `ngJq`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Amongst other things it looks for a ",(0,r.jsx)(n.code,{children:"jQuery"})," variable which has been placed onto the ",(0,r.jsx)(n.code,{children:"window"})," object. If it is found then jQuery is used; if it is not then it's ",(0,r.jsx)(n.code,{children:"jqLite"})," all the way."]}),"\n",(0,r.jsx)(n.h2,{id:"but-wait-im-using-webpack",children:"But wait! I'm using webpack"}),"\n",(0,r.jsxs)(n.p,{children:["Me too! And one of the reasons is that we get to move away from reliance upon the global scope and towards proper modularisation. So how do we get Angular to use jQuery given the code we've seen above? Well, your first thought might be to ",(0,r.jsx)(n.code,{children:"npm install"})," yourself some ",(0,r.jsx)(n.code,{children:"jQuery"})," and then make sure you've got something like this in your entry file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import 'jquery'; // This'll fix it... Right?\nimport * as angular from 'angular';\n"})}),"\n",(0,r.jsx)(n.p,{children:"Wrong."}),"\n",(0,r.jsxs)(n.h2,{id:"you-need-the-provideplugin",children:["You need the ",(0,r.jsx)(n.code,{children:"ProvidePlugin"})]}),"\n",(0,r.jsxs)(n.p,{children:["In your ",(0,r.jsx)(n.code,{children:"webpack.config.js"})," you need to add the following entry to your plugins:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'new webpack.ProvidePlugin({\n          "window.jQuery": "jquery"\n      }),\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This uses the webpack ",(0,r.jsx)(n.a,{href:"https://github.com/webpack/docs/wiki/list-of-plugins#provideplugin",children:(0,r.jsx)(n.code,{children:"ProvidePlugin"})})," and, at the point of webpackification (\xa9 2016 John Reilly) all references in the code to ",(0,r.jsx)(n.code,{children:"window.jQuery"})," will be replaced with a reference to the webpack module that contains jQuery. So when you look at the bundled file you'll see that the code that checks the ",(0,r.jsx)(n.code,{children:"window"})," object for ",(0,r.jsx)(n.code,{children:"jQuery"})," has become this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"jQuery = isUndefined(jqName)\n  ? __webpack_provided_window_dot_jQuery // use jQuery (if present)\n  : !jqName\n  ? undefined // use jqLite\n  : window[jqName]; // use jQuery specified by `ngJq`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["That's right; webpack is providing Angular with jQuery whilst still ",(0,r.jsx)(n.em,{children:"not"})," placing a ",(0,r.jsx)(n.code,{children:"jQuery"})," variable onto the ",(0,r.jsx)(n.code,{children:"window"}),". Neat huh?"]})]})}function d(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},50065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return a}});var i=t(67294);let r={},o=i.createContext(r);function a(e){let n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},54169:function(e){e.exports=JSON.parse('{"permalink":"/the-mysterious-case-of-webpack-angular-and-jquery","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2016-05-24-the-mysterious-case-of-webpack-angular-and-jquery/index.md","source":"@site/blog/2016-05-24-the-mysterious-case-of-webpack-angular-and-jquery/index.md","title":"The Mysterious Case of webpack, AngularJS and jQuery","description":"Angular can use jQuery instead of jQLite, but this becomes complicated when using webpack. We need to use the ProvidePlugin function in webpack.config.js.","date":"2016-05-24T00:00:00.000Z","tags":[{"inline":false,"label":"Angular JS","permalink":"/tags/angularjs","description":"The original Angular JS framework."},{"inline":false,"label":"webpack","permalink":"/tags/webpack","description":"The webpack module bundler."},{"inline":false,"label":"jQuery","permalink":"/tags/jquery","description":"The jQuery library."}],"readingTime":1.895,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"the-mysterious-case-of-webpack-angular-and-jquery","title":"The Mysterious Case of webpack, AngularJS and jQuery","authors":"johnnyreilly","tags":["angularjs","webpack","jquery"],"hide_table_of_contents":false,"description":"Angular can use jQuery instead of jQLite, but this becomes complicated when using webpack. We need to use the ProvidePlugin function in webpack.config.js."},"unlisted":false,"prevItem":{"title":"Creating an ES2015 Map from an Array in TypeScript","permalink":"/create-es2015-map-from-array-in-typescript"},"nextItem":{"title":"Inlining Angular Templates with WebPack and TypeScript","permalink":"/inlining-angular-templates-with-webpack"}}')}}]);