"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[34643],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},g=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),g=i,h=p["".concat(l,".").concat(g)]||p[g]||d[g]||r;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}g.displayName="MDXCreateElement"},71120:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>p});n(67294);var o=n(3905);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function a(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const s={slug:"publishing-docusaurus-to-devto-with-devto-api",title:"Publishing Docusaurus to dev.to with the dev.to API",authors:"johnnyreilly",tags:["docusaurus","github actions"],image:"./title-image.png",description:"The dev.to API provides a way to cross post your Docusaurus blogs to dev.to. This post describes how to do that with TypeScript, Node.js and the dev.to API.",hide_table_of_contents:!1},l=void 0,c={permalink:"/publishing-docusaurus-to-devto-with-devto-api",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2022-12-11-publishing-docusaurus-to-devto-with-devto-api/index.md",source:"@site/blog/2022-12-11-publishing-docusaurus-to-devto-with-devto-api/index.md",title:"Publishing Docusaurus to dev.to with the dev.to API",description:"The dev.to API provides a way to cross post your Docusaurus blogs to dev.to. This post describes how to do that with TypeScript, Node.js and the dev.to API.",date:"2022-12-11T00:00:00.000Z",formattedDate:"December 11, 2022",tags:[{label:"docusaurus",permalink:"/tags/docusaurus"},{label:"github actions",permalink:"/tags/github-actions"}],readingTime:9.18,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"publishing-docusaurus-to-devto-with-devto-api",title:"Publishing Docusaurus to dev.to with the dev.to API",authors:"johnnyreilly",tags:["docusaurus","github actions"],image:"./title-image.png",description:"The dev.to API provides a way to cross post your Docusaurus blogs to dev.to. This post describes how to do that with TypeScript, Node.js and the dev.to API.",hide_table_of_contents:!1},prevItem:{title:"Azure Static Web Apps: build app externally",permalink:"/azure-static-web-apps-build-app-externally"},nextItem:{title:"Deep linking with Azure Static Web Apps and Easy Auth",permalink:"/azure-static-web-apps-easyauth-deeplink"}},u={image:n(3422).Z,authorsImageUrls:[void 0]},p=[{value:"Why not use &quot;Publishing to DEV Community \ud83d\udc69\u200d\ud83d\udcbb\ud83d\udc68\u200d\ud83d\udcbb from RSS&quot;?",id:"why-not-use-publishing-to-dev-community--from-rss",level:2},{value:"The dev.to API",id:"the-devto-api",level:2},{value:"TypeScript console app",id:"typescript-console-app",level:2},{value:"TypeScript dev.to API client",id:"typescript-devto-api-client",level:2},{value:"From blog post markdown to published blog posts",id:"from-blog-post-markdown-to-published-blog-posts",level:2},{value:"Running the script from GitHub Actions",id:"running-the-script-from-github-actions",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p},g="wrapper";function h(e){var{components:t}=e,s=a(e,["components"]);return(0,o.kt)(g,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){i(e,t,n[t])}))}return e}({},d,s),{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The dev.to API provides a way to cross post your Docusaurus blogs to dev.to. This post describes how to do that with TypeScript, Node.js and the dev.to API."),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"eager",fetchpriority:"high",alt:"title image reading &quot;Deep linking with Azure Static Web Apps and Easy Auth&quot; with Azure AD and Static Web App logos",src:n(3422).Z,width:"800",height:"450"})),(0,o.kt)("h2",{id:"why-not-use-publishing-to-dev-community--from-rss"},'Why not use "Publishing to DEV Community \ud83d\udc69\u200d\ud83d\udcbb\ud83d\udc68\u200d\ud83d\udcbb from RSS"?'),(0,o.kt)("p",null,"If you take a look at the ",(0,o.kt)("a",{parentName:"p",href:"https://dev.to/settings/extensions"},"dev.to settings (under extensions)")," you'll see that you can post to dev.to using an RSS feed:"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",alt:"Screenshot of the &quot;Publishing to DEV Community \ud83d\udc69\u200d\ud83d\udcbb\ud83d\udc68\u200d\ud83d\udcbb from RSS&quot; section of dev.to",src:n(24831).Z,width:"1347",height:"1350"})),(0,o.kt)("p",null,"This is great, but it has a number of downsides:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"every post published to your blog will be published to dev.to - there's no fine grained control"),(0,o.kt)("li",{parentName:"ul"},'every post published arrives as "draft" - you have to manually push it "live".'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"most significantly")," - it handles code snippets poorly. Everything ends up as a single line of text. This is a real shame because code snippets are a key part of a blog post.")),(0,o.kt)("p",null,"So after initially setting this up, I decided to look for a better way."),(0,o.kt)("h2",{id:"the-devto-api"},"The dev.to API"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://developers.forem.com/api"},"It turns out that dev.to have an API."),". The API is pretty well documented and it's pretty easy to use. The docs mention version 0 and version 1 of the API. Version 0 is officially deprecated, but version 1 appears to be incomplete - certainly the docs are. I ended up using version 0 for this post despite attempting to use version 1; I'll update this post when v1 gets there."),(0,o.kt)("p",null,"The only thing you need to do to use the API is ",(0,o.kt)("a",{parentName:"p",href:"https://dev.to/settings/extensions"},"generate an API key"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",alt:"Screenshot of the &quot;DEV Community \ud83d\udc69\u200d\ud83d\udcbb\ud83d\udc68\u200d\ud83d\udcbb API Keys&quot; screen",src:n(10293).Z,width:"1347",height:"835"})),(0,o.kt)("h2",{id:"typescript-console-app"},"TypeScript console app"),(0,o.kt)("p",null,"I'm going to use a TypeScript console app to do the work. Let's scaffold up an example project alongside our Docusaurus site:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir from-docusaurus-to-devto\ncd from-docusaurus-to-devto\nnpx typescript --init\nyarn init\nyarn add @types/node ts-node typescript @docusaurus/utils\n")),(0,o.kt)("p",null,"And in the ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," file add a ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "scripts": {\n    "start": "ts-node index.ts"\n  }\n}\n')),(0,o.kt)("p",null,"Finally, create an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts")," file. We'll fill this in shortly."),(0,o.kt)("h2",{id:"typescript-devto-api-client"},"TypeScript dev.to API client"),(0,o.kt)("p",null,"Before we do that, we're going to need a dev.to API client. Let's create a ",(0,o.kt)("inlineCode",{parentName:"p"},"devtoApiClient.ts")," file and add the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface User {\n  name: string;\n  username: string;\n  twitter_username: string;\n  github_username: string;\n  user_id: number;\n  website_url: string;\n  profile_image: string;\n  profile_image_90: string;\n}\n\nexport interface ArticleToPublish {\n  title: string;\n  body_markdown: string;\n  published: boolean;\n  main_image: string | undefined;\n  canonical_url: string;\n  description?: string;\n  tags: string[];\n}\n\nexport interface Article {\n  type_of: string;\n  id: number;\n  title: string;\n  description: string;\n  published: boolean;\n  published_at: string;\n  slug: string;\n  path: string;\n  url: string;\n  comments_count: number;\n  public_reactions_count: number;\n  page_views_count: number;\n  positive_reactions_count: number;\n  cover_image: string | null;\n  canonical_url: string;\n  published_timestamp: string;\n  tag_list: string[];\n  user: User;\n  body_markdown: string;\n  body_html: string;\n  reading_time_minutes: number;\n}\n\nexport interface DevToApiClient {\n  getArticles: () => Promise<Article[]>;\n  createArticle: (article: ArticleToPublish) => Promise<void>;\n  updateArticle: (id: number, article: ArticleToPublish) => Promise<void>;\n}\n\nexport function devtoApiClientFactory(apiKey: string): DevToApiClient {\n  const baseUrl = 'https://dev.to/api';\n\n  return {\n    getArticles: async () => {\n      try {\n        const articles: Article[] = [];\n        let page = 1;\n        const pageSize = 100;\n        while (true) {\n          const url = `${baseUrl}/articles/me/published?page=${page}&page_size=${pageSize}`;\n          const res = await fetch(url, {\n            headers: {\n              'api-key': apiKey,\n              accept: 'application/vnd.forem.api-v1+json',\n            },\n          });\n          if (!res.ok) {\n            console.error(res);\n            throw new Error(`Failed to get articles ${url}`);\n          }\n          const data = (await res.json()) as Article[];\n          if (data.length === 0) break;\n\n          page += 1;\n          articles.push(...data);\n        }\n        return articles;\n      } catch (e) {\n        console.error('Failed to get articles', e);\n        throw new Error('Failed to get articles');\n      }\n    },\n\n    createArticle: async (article: ArticleToPublish) => {\n      try {\n        const url = `${baseUrl}/articles`;\n        const res = await fetch(url, {\n          headers: {\n            'api-key': apiKey,\n            'Content-Type': 'application/json',\n          },\n          method: 'POST',\n          body: JSON.stringify({\n            article,\n          }),\n        });\n        if (!res.ok) {\n          console.error(res);\n          console.error(await res.json());\n          throw new Error(`Failed to create article ${article.canonical_url}`);\n        }\n        const data = (await res.json()) as Article;\n        const { body_html, body_markdown, ...rest } = data;\n        console.log(`Created article ${article.canonical_url}`, rest);\n      } catch (e) {\n        console.error('Failed to create article', e);\n        throw new Error('Failed to create article');\n      }\n    },\n\n    updateArticle: async (id: number, article: ArticleToPublish) => {\n      try {\n        const url = `${baseUrl}/articles/${id}`;\n        const res = await fetch(url, {\n          headers: {\n            'api-key': apiKey,\n            'Content-Type': 'application/json',\n          },\n          method: 'PUT',\n          body: JSON.stringify({\n            article,\n          }),\n        });\n        if (!res.ok) {\n          console.error(res);\n          console.error(await res.json());\n          throw new Error(`Failed to update article ${article.canonical_url}`);\n        }\n        const data = (await res.json()) as Article;\n        const { body_html, body_markdown, ...rest } = data;\n        console.log(`Updated article ${article.canonical_url}`, rest);\n      } catch (e) {\n        console.error('Failed to update article', e);\n        throw new Error('Failed to update article');\n      }\n    },\n  };\n}\n")),(0,o.kt)("p",null,"This is a simple API client that uses the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"},"Fetch API")," to make requests to the dev.to API. It's not a complete implementation of the API, but we only need a few article related endpoints to do the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Get all the articles that have been published to dev.to"),(0,o.kt)("li",{parentName:"ul"},"Create a new article"),(0,o.kt)("li",{parentName:"ul"},"Update an existing article")),(0,o.kt)("h2",{id:"from-blog-post-markdown-to-published-blog-posts"},"From blog post markdown to published blog posts"),(0,o.kt)("p",null,"Now we can use the API client in our ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import fs from 'fs';\nimport path from 'path';\nimport { parseFrontMatter } from '@docusaurus/utils';\nimport {\n  Article,\n  DevToApiClient,\n  devtoApiClientFactory,\n} from './devtoApiClient';\n\nconst rootUrl = 'https://johnnyreilly.com';\nconst rootGitHubUrl =\n  'https://raw.githubusercontent.com/johnnyreilly/blog.johnnyreilly.com/main/blog-website/blog/';\nconst docusaurusBlogDirectory = '../blog-website/blog';\n\nconst markdownImageRexEx = /!\\[.*\\]\\((.*)\\)/g;\nconst markdownRelativeBlogUrlRegex = /\\[.*\\]\\(\\.\\.\\/(.*)\\/index.md\\)/g;\n\nasync function getLastXBlogPostsToPublish({\n  numberOfPosts,\n}: {\n  numberOfPosts: number;\n}) {\n  const blogPosts = await fs.promises.readdir(docusaurusBlogDirectory, {\n    withFileTypes: true,\n  });\n  const blogPostDirectoryNames = blogPosts\n    .slice(0)\n    .reverse()\n    .filter((post) => post.isDirectory())\n    .map((post) => post.name)\n    .slice(0, numberOfPosts);\n\n  return blogPostDirectoryNames;\n}\n\nasync function publishBlogPostToDevTo({\n  blogFilePathRelative,\n  articlesByCanonicalUrl,\n  devtoApiClient,\n}: {\n  blogFilePathRelative: string;\n  articlesByCanonicalUrl: Map<string, Article>;\n  devtoApiClient: DevToApiClient;\n}) {\n  const blogFilePath = path.join(\n    docusaurusBlogDirectory,\n    blogFilePathRelative,\n    'index.md',\n  );\n  console.log(`Processing ${blogFilePath}`);\n\n  const blogFileContent = await fs.promises.readFile(blogFilePath, 'utf8');\n  const { frontMatter, content } = parseFrontMatter(blogFileContent);\n\n  const canonicalUrl = makeCanonicalUrl(\n    blogFilePathRelative,\n    frontMatter['slug'] as string | undefined,\n  );\n  const contentWithCanonicalUrls = enrichMarkdownWithCanonicalUrls(content);\n  const contentWithGitHubImages = enrichMarkdownWithImagesFromGitHub(\n    contentWithCanonicalUrls,\n    blogFilePathRelative,\n  );\n  const tags = frontMatter['tags'] as string[];\n  const title = frontMatter['title'] as string;\n  const published = true;\n  const main_image = makeMainImage(frontMatter, blogFilePathRelative);\n  const trimmedTags = tags.slice(0, 4).map((tag) => tag.replace(/\\W/g, ''));\n\n  const body_markdown = `---\ntitle: ${title}\npublished: ${published}\ntags: ${trimmedTags.join(',')}\ncanonical_url: ${canonicalUrl}\n---\n${contentWithGitHubImages}`;\n\n  const article = {\n    title,\n    body_markdown,\n    published,\n    main_image,\n    canonical_url: canonicalUrl,\n    tags: trimmedTags,\n  };\n\n  console.log(`\\n---------------------------------------------------\\n\\n`);\n  const existingArticle = articlesByCanonicalUrl.get(canonicalUrl);\n\n  if (existingArticle) {\n    console.log(`Updating article ${canonicalUrl}`);\n    await devtoApiClient.updateArticle(existingArticle.id, article);\n  } else {\n    console.log(`Creating article ${canonicalUrl}`);\n    await devtoApiClient.createArticle(article);\n  }\n}\n\nfunction makeMainImage(\n  frontMatter: { [key: string]: unknown },\n  blogFilePathRelative: string,\n) {\n  const image =\n    typeof frontMatter['image'] === 'string'\n      ? (frontMatter['image'] as string)\n      : '';\n  const main_image = image\n    ? rootGitHubUrl +\n      blogFilePathRelative +\n      '/' +\n      image.substring(image.indexOf('/') + 1)\n    : undefined;\n  return main_image;\n}\n\nfunction makeCanonicalUrl(\n  blogFilePathRelative: string,\n  frontMatterSlug?: string,\n) {\n  const parsedBlogFileName = `${rootUrl}/${blogFilePathRelative\n    .substring(0, 10)\n    .split('-')\n    .join('/')}/${blogFilePathRelative.substring(11)}`;\n\n  const canonicalUrl = frontMatterSlug\n    ? `${rootUrl}/${frontMatterSlug}`\n    : parsedBlogFileName;\n  return canonicalUrl;\n}\n\nfunction enrichMarkdownWithImagesFromGitHub(\n  content: string,\n  blogFilePathRelative: string,\n) {\n  return Array.from(content.matchAll(markdownImageRexEx))\n    .map((matches) => {\n      const [completeMatch, url] = matches;\n      const withGitHubUrl = completeMatch.replace(\n        url,\n        rootGitHubUrl + blogFilePathRelative + '/' + url,\n      );\n      console.log(`Replacing ${completeMatch} with ${withGitHubUrl}`);\n      return { oldImage: completeMatch, newImage: withGitHubUrl };\n    })\n    .reduce(\n      (contentInProgress, { oldImage, newImage }) =>\n        contentInProgress.replace(oldImage, newImage),\n      content,\n    );\n}\n\nfunction enrichMarkdownWithCanonicalUrls(content: string) {\n  return Array.from(content.matchAll(markdownRelativeBlogUrlRegex))\n    .map((matches) => {\n      const [\n        /* eg [I wanted to add the last modified date to my blog posts.](../2022-11-25-adding-lastmod-to-sitemap-git-commit-date/index.md) */\n        completeMatch,\n        /* eg 2022-11-25-adding-lastmod-to-sitemap-git-commit-date */\n        relativeBlogPath,\n      ] = matches;\n\n      const withCanonicalUrl = completeMatch.replace(\n        `../${relativeBlogPath}/index.md`,\n        makeCanonicalUrl(relativeBlogPath),\n      );\n      console.log(`Replacing ${completeMatch} with ${withCanonicalUrl}`);\n      return { oldImage: completeMatch, newImage: withCanonicalUrl };\n    })\n    .reduce(\n      (contentInProgress, { oldImage, newImage }) =>\n        contentInProgress.replace(oldImage, newImage),\n      content,\n    );\n}\n\nfunction makeDevtoApiClient() {\n  const devToApiKey = process.env.DEVTO_APIKEY;\n\n  if (!devToApiKey) {\n    console.log('No dev.to API key specified!');\n    process.exit(1);\n  }\n\n  return devtoApiClientFactory(devToApiKey);\n}\n\nconst sleep = async ({ seconds }: { seconds: number }) =>\n  new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n\nasync function run() {\n  const devtoApiClient = makeDevtoApiClient();\n  const articles = await devtoApiClient.getArticles();\n  const articlesByCanonicalUrl = new Map<string, Article>(\n    Array.from(articles).map((article) => [article.canonical_url, article]),\n  );\n  const blogPostsToPublish = await getLastXBlogPostsToPublish({\n    numberOfPosts: 5,\n  });\n\n  for (const blogFilePathRelative of blogPostsToPublish) {\n    await publishBlogPostToDevTo({\n      blogFilePathRelative,\n      articlesByCanonicalUrl,\n      devtoApiClient,\n    });\n\n    console.log('Sleeping for 5 seconds because rate limiting...');\n    await sleep({ seconds: 5 });\n  }\n}\n\n// do it!\nrun();\n")),(0,o.kt)("p",null,"There's a lot happening here, let me summarise it:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Grab the last 5 blog posts from the Docusaurus blog directory; this is the number of posts I want to publish to dev.to on each run"),(0,o.kt)("li",{parentName:"ul"},"For each blog post, parse the front matter and the content"),(0,o.kt)("li",{parentName:"ul"},"Build up the article object to send to dev.to. We do a few tricks here to make the article look nice:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"To make the URL we'll use the ",(0,o.kt)("inlineCode",{parentName:"li"},"slug")," front matter if it exists, otherwise use the date and title"),(0,o.kt)("li",{parentName:"ul"},"Enrich the images in the content with the GitHub URLs so we can use images from the blog post"),(0,o.kt)("li",{parentName:"ul"},"Use the first 4 tags from the front matter - dev.to only allows 4 tags. Also we'll strip those tags of any non-word characters"),(0,o.kt)("li",{parentName:"ul"},"Default to ",(0,o.kt)("inlineCode",{parentName:"li"},"published")," immediately"))),(0,o.kt)("li",{parentName:"ul"},"If the article already exists on dev.to, update it, otherwise create it")),(0,o.kt)("p",null,"Because dev.to practise rate limiting on their API, I've added a 5 second sleep between each article to ensure we don't get blocked. It's a little arbitrary, but it works well enough."),(0,o.kt)("p",null,"Does it work? Let's find out!"),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",alt:"Screenshot of dev.to dashboard showing published posts",src:n(66231).Z,width:"1822",height:"1008"})),(0,o.kt)("p",null,"It works! I've published 5 posts to dev.to from my blog. ",(0,o.kt)("a",{parentName:"p",href:"https://dev.to/johnnyreilly"},"I can now go to dev.to and see them.")),(0,o.kt)("h2",{id:"running-the-script-from-github-actions"},"Running the script from GitHub Actions"),(0,o.kt)("p",null,"Now that we have the script, we need to run it. I'm going to use GitHub Actions to do this, but you could use any CI/CD tool you like."),(0,o.kt)("p",null,"I add a new ",(0,o.kt)("inlineCode",{parentName:"p"},"deploy_to_devto_job")," to my existing workflow and I set it to run on every push to the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," branch. I don't want to publish to dev.to on every pull request; I want to publish once a blog post is published. So I add an ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," condition to the job to check that the event is not a pull request."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"deploy_to_devto_job:\n  name: Publish to dev.to \ud83d\uddde\ufe0f\n  needs: build_and_deploy_swa_job\n  if: github.event_name != 'pull_request'\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Node.js \ud83d\udd27\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n        cache: 'yarn'\n\n    - name: Publish to dev.to \ud83d\uddde\ufe0f\n      run: |\n        cd from-docusaurus-to-devto\n        yarn install --frozen-lockfile\n        DEVTO_APIKEY=${{ secrets.DEVTO_APIKEY }} yarn start\n")),(0,o.kt)("p",null,"If you'd like to use this you'll need to add a ",(0,o.kt)("inlineCode",{parentName:"p"},"DEVTO_APIKEY")," secret to your repository secrets. You can get this from your dev.to account settings. Remember to keep it secret!"),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"This is all a bit of an experiment to see what happens if I start to cross publish my blog posts to dev.to. I'm not sure if I'll keep doing it, but I'm going to trial it and see how it goes."),(0,o.kt)("p",null,"You can use this approach with your own blog site - you'll need to do a little path and URL fiddling, but everything else should be just as you need."))}h.isMDXComponent=!0},10293:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/screenshot-devto-apikey-cacee8316051553f62a90adaca79a6f6.png"},66231:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/screenshot-devto-published-posts-275f85e2536b3c9e2ac8fc85e3ae9f67.png"},24831:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/screenshot-devto-publishing-rss-ad0658517234e6610941cdda10a43489.png"},3422:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/title-image-6d961844b168cc54d38548ca0fff8a93.png"}}]);