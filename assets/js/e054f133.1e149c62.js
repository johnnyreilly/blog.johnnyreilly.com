"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[91550],{11985:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/title-image-af67d61370c2d04c19f5f6065b7d64c7.png"},14769:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/screenshot-azure-pipelines-tests-no-unused-vars-9ca250203edc598ea166d326ad6675d6.webp"},21482:e=>{e.exports=JSON.parse('{"permalink":"/bicep-lint-azure-pipelines-github-actions","editUrl":"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2024-01-30-bicep-lint-azure-pipelines-github-actions/index.md","source":"@site/blog/2024-01-30-bicep-lint-azure-pipelines-github-actions/index.md","title":"Bicep lint with Azure Pipelines and GitHub Actions","description":"Bicep lint allows you to lint bicep files to ensure they conform to best practices. In this post we\'ll look at how to run bicep lint in Azure Pipelines and GitHub Actions.","date":"2024-01-30T00:00:00.000Z","tags":[{"inline":false,"label":"Bicep","permalink":"/tags/bicep","description":"The Bicep language for Azure Resource Manager templates."},{"inline":false,"label":"GitHub Actions","permalink":"/tags/github-actions","description":"The GitHub Actions CI / CD service."},{"inline":false,"label":"Azure Pipelines","permalink":"/tags/azure-pipelines","description":"The Azure Pipelines CI / CD service."},{"inline":false,"label":"Azure DevOps","permalink":"/tags/azure-devops","description":"The Azure DevOps suite of tools."}],"readingTime":10.22,"hasTruncateMarker":true,"authors":[{"name":"John Reilly","title":"OSS Engineer - TypeScript, Azure, React, Node.js, .NET","url":"https://johnnyreilly.com/about","imageURL":"https://johnnyreilly.com/img/profile-2025.jpg","key":"johnnyreilly","page":null}],"frontMatter":{"slug":"bicep-lint-azure-pipelines-github-actions","title":"Bicep lint with Azure Pipelines and GitHub Actions","authors":"johnnyreilly","tags":["bicep","github actions","azure pipelines","azure devops"],"image":"./title-image.png","description":"Bicep lint allows you to lint bicep files to ensure they conform to best practices. In this post we\'ll look at how to run bicep lint in Azure Pipelines and GitHub Actions.","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Using Bun in Azure Pipelines","permalink":"/using-bun-in-azure-pipelines"},"nextItem":{"title":"Schemar: a GitHub Action to validate structured data","permalink":"/schemar-github-action-to-validate-structured-data"}}')},28453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>o});var t=n(96540);const s={},a=t.createContext(s);function r(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:i},e.children)}},47277:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/screenshot-github-actions-no-unused-vars-9c962eb6271f0d866be70b2de97a9928.webp"},73784:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/screenshot-azure-pipelines-scans-no-unused-vars-02bddbe30ec71064cded5894dbbc70e2.webp"},77581:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var t=n(21482),s=n(74848),a=n(28453);const r={slug:"bicep-lint-azure-pipelines-github-actions",title:"Bicep lint with Azure Pipelines and GitHub Actions",authors:"johnnyreilly",tags:["bicep","github actions","azure pipelines","azure devops"],image:"./title-image.png",description:"Bicep lint allows you to lint bicep files to ensure they conform to best practices. In this post we'll look at how to run bicep lint in Azure Pipelines and GitHub Actions.",hide_table_of_contents:!1},o=void 0,l={image:n(11985).A,authorsImageUrls:[void 0]},c=[{value:"The general approach",id:"the-general-approach",level:2},{value:"Linting Bicep in GitHub Actions with the Azure CLI",id:"linting-bicep-in-github-actions-with-the-azure-cli",level:2},{value:"Linting Bicep in GitHub Actions with the Bicep CLI",id:"linting-bicep-in-github-actions-with-the-bicep-cli",level:2},{value:"Linting Bicep in Azure Pipelines with the Azure CLI",id:"linting-bicep-in-azure-pipelines-with-the-azure-cli",level:2},{value:"Surface the results in Scans",id:"surface-the-results-in-scans",level:3},{value:"Surface the results in Tests",id:"surface-the-results-in-tests",level:3},{value:"Summary",id:"summary",level:2}];function h(e){const i={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.p,{children:["Bicep has had linting ",(0,s.jsx)(i.a,{href:"https://github.com/Azure/bicep/releases/tag/v0.4.1",children:"since version 0.4.1"}),". It's a great way to ensure that your bicep files conform to best practices. Interestingly, when the linting feature first shipped, there wasn't an explicit lint command as part of the CLI. Instead, you had to run ",(0,s.jsx)(i.code,{children:"bicep build"})," and it would run the linter as part of the build process. This was a little confusing as it was not obvious that the linter was running."]}),"\n",(0,s.jsxs)(i.p,{children:["As of ",(0,s.jsx)(i.a,{href:"https://github.com/Azure/bicep/releases/tag/v0.21.1",children:"version 0.21.1"})," there is a dedicated ",(0,s.jsx)(i.a,{href:"https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/linter",children:(0,s.jsx)(i.code,{children:"bicep lint"})})," command. This is a nice step forwards; it allows you to explicitly lint your your code, rather than have it happen as a side effect of build. And it is useful if you want to run the linter as part of a CI/CD pipeline. What's more the ",(0,s.jsx)(i.code,{children:"bicep lint"})," command is now available in the Azure CLI as well. You can run ",(0,s.jsx)(i.a,{href:"https://docs.microsoft.com/en-us/cli/azure/bicep?view=azure-cli-latest#az-bicep-lint",children:(0,s.jsx)(i.code,{children:"az bicep lint"})})," to lint your bicep files."]}),"\n",(0,s.jsx)(i.p,{children:"In this post we'll look at how to run lint Bicep in Azure Pipelines and GitHub Actions, and surface the output in the UI."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"title image reading &quot;Bicep lint with Azure Pipelines and GitHub Actions&quot; with the Bicep logo",src:n(93928).A+"",width:"800",height:"450",loading:"lazy"})}),"\n",(0,s.jsx)(i.h2,{id:"the-general-approach",children:"The general approach"}),"\n",(0,s.jsxs)(i.p,{children:["The general approach is the same for both Azure Pipelines and GitHub Actions. One way or another, we'll run the Bicep ",(0,s.jsx)(i.code,{children:"lint"})," command to lint our Bicep files and capture the output. As yet, there is no option to export the results of the lint command as a file. This may come, and ",(0,s.jsx)(i.a,{href:"https://github.com/Azure/bicep/issues/11960",children:"there is a discussion about it"}),". However, there is a way to achieve our goal, which came out in discussion with ",(0,s.jsx)(i.a,{href:"https://github.com/anthony-c-martin",children:"Anthony Martin"})," of the Bicep team. We can write the output of the ",(0,s.jsx)(i.code,{children:"lint"})," command to a file like so:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"bicep lint main.bicep --diagnostics-format sarif > lint.sarif\n"})}),"\n",(0,s.jsxs)(i.p,{children:["This will write the output of the ",(0,s.jsx)(i.code,{children:"lint"})," command to a file called ",(0,s.jsx)(i.code,{children:"lint.sarif"}),". This is a ",(0,s.jsx)(i.a,{href:"https://sarifweb.azurewebsites.net/",children:"SARIF"})," file. SARIF stands for Static Analysis Results Interchange Format. It's a standard for representing the results of static analysis tools. It's a JSON file, easy to parse and has integrations with GitHub Actions / Azure Pipelines. An example SARIF output is below:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-json",children:'{\n  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",\n  "version": "2.1.0",\n  "runs": [\n    {\n      "tool": {\n        "driver": {\n          "name": "bicep"\n        }\n      },\n      "results": [\n        {\n          "ruleId": "no-unused-vars",\n          "message": {\n            "text": "Variable \\"unusedVar\\" is declared but never used. [https://aka.ms/bicep/linter/no-unused-vars]"\n          },\n          "locations": [\n            {\n              "physicalLocation": {\n                "artifactLocation": {\n                  "uri": "file:///home/runner/work/blog.johnnyreilly.com/blog.johnnyreilly.com/./infra/main.bicep"\n                },\n                "region": {\n                  "startLine": 19,\n                  "charOffset": 5\n                }\n              }\n            }\n          ]\n        }\n      ],\n      "columnKind": "utf16CodeUnits"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:["In the example above we directly used the ",(0,s.jsx)(i.code,{children:"bicep lint"})," command. An alternative approach is to use the Azure CLI like so:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"az bicep lint --file main.bicep --diagnostics-format sarif > lint.sarif\n"})}),"\n",(0,s.jsx)(i.p,{children:"This is a little more verbose, but it does mean that you don't need to install the Bicep CLI on your build agent. You can use the Azure CLI instead; and this is already a first class citizen of Azure Pipelines and GitHub Actions, with dedicated support. (That said, there is a slight issue with this approach at the time of writing, which we'll come to later.)"}),"\n",(0,s.jsx)(i.p,{children:"However we generate it, we can take the SARIF file and use it to surface the results of the linting process in Azure Pipelines and GitHub Actions."}),"\n",(0,s.jsx)(i.h2,{id:"linting-bicep-in-github-actions-with-the-azure-cli",children:"Linting Bicep in GitHub Actions with the Azure CLI"}),"\n",(0,s.jsxs)(i.p,{children:["We'll start off by looking at how to lint Bicep in GitHub Actions with the Azure CLI. But before we do that, we need something to lint. Within your ",(0,s.jsx)(i.code,{children:"main.bicep"})," file you should have something like this:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bicep",children:"var unusedVar = 1 // unused variable\n"})}),"\n",(0,s.jsxs)(i.p,{children:["As it suggests, this is an unused variable. We're just using this to demonstrate the linting process. And alongside that, we want a ",(0,s.jsx)(i.a,{href:"https://aka.ms/bicep/config",children:(0,s.jsx)(i.code,{children:"bicepconfig.json"})})," file that looks like this:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-json",children:'{\n  "analyzers": {\n    "core": {\n      "rules": {\n        "no-unused-vars": {\n          "level": "warning"\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:["This explicitly enables the ",(0,s.jsx)(i.a,{href:"https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/linter-rule-no-unused-variables",children:(0,s.jsx)(i.code,{children:"no-unused-vars"})})," rule, and sets it to ",(0,s.jsx)(i.code,{children:"warning"})," level. This means that the linter will warn us about unused variables, but it won't fail the build. We could set it to ",(0,s.jsx)(i.code,{children:"error"})," level, and then the build would fail if there were any unused variables. We'll come back to this later."]}),"\n",(0,s.jsx)(i.p,{children:"In a GitHub workflow in your repository you should have steps like these:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"- name: Lint Bicep\n  uses: azure/CLI@v2\n  with:\n    inlineScript: |\n      az bicep install\n      az bicep lint --file ./infra/main.bicep --diagnostics-format sarif > bicep.sarif\n\n- name: Upload SARIF\n  if: (success() || failure())\n  uses: github/codeql-action/upload-sarif@v3\n  with:\n    category: bicep\n    sarif_file: bicep.sarif\n"})}),"\n",(0,s.jsx)(i.p,{children:"The above:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Installs Bicep to the Azure CLI"}),"\n",(0,s.jsxs)(i.li,{children:["Runs the ",(0,s.jsx)(i.code,{children:"lint"})," command and writes the results to a file called ",(0,s.jsx)(i.code,{children:"bicep.sarif"})]}),"\n",(0,s.jsx)(i.li,{children:"Uploads the SARIF file to GitHub"}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"upload-sarif"})," action is provided by GitHub. ",(0,s.jsx)(i.a,{href:"https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/uploading-a-sarif-file-to-github",children:"It allows surfacing the results of static analysis tools in GitHub"}),". Doing this will show the results of the linting process in the GitHub UI, and it will also show them in the GitHub Security / Code Scanning UI, like so:"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"screenshot of the no-unused-vars rule in GitHub UI",src:n(47277).A+"",width:"1922",height:"726",loading:"lazy"})}),"\n",(0,s.jsx)(i.h2,{id:"linting-bicep-in-github-actions-with-the-bicep-cli",children:"Linting Bicep in GitHub Actions with the Bicep CLI"}),"\n",(0,s.jsxs)(i.p,{children:["We can also lint Bicep in GitHub Actions with the Bicep CLI. At the time of writing, there's a reason you might want to favour this approach over the Azure CLI approach. I won't drill into it in depth, but at present if ",(0,s.jsx)(i.code,{children:"az bicep lint"})," fails / returns a non-0 exit code then no output is produced. We could make this happen by updating the ",(0,s.jsx)(i.code,{children:"bicepconfig.json"})," to dial up the ",(0,s.jsx)(i.code,{children:"no-unused-vars"})," rule to ",(0,s.jsx)(i.code,{children:"error"})," level, like so:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-json",children:'{\n  "analyzers": {\n    "core": {\n      "rules": {\n        "no-unused-vars": {\n          "level": "error"\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:["Now an unused variable will cause the build to fail. But the output of the ",(0,s.jsx)(i.code,{children:"lint"})," command will not be surfaced in the GitHub UI. This is because the Azure CLI is not surfacing the output of the ",(0,s.jsx)(i.code,{children:"lint"})," command when it fails."]}),"\n",(0,s.jsxs)(i.p,{children:["The issue with the Azure CLI will hopefully be remedied; ",(0,s.jsx)(i.a,{href:"https://github.com/Azure/azure-cli/issues/28259",children:"you can track that here"}),". For now you can use the Bicep CLI directly, where this isn't an issue. We'll do that now."]}),"\n",(0,s.jsxs)(i.p,{children:["I'm basing this approach on Anthony Martin's example of ",(0,s.jsx)(i.a,{href:"https://github.com/anthony-c-martin/bicep-on-k8s/blob/e6dfa61fe7eae6fd6b148670f940041f3e294b20/.github/workflows/ci.yml#L36-L50",children:"Bicep linting with GitHub Actions"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yml",children:"- name: Setup Bicep\n  uses: anthony-c-martin/setup-bicep@v0.3\n\n- name: Lint Bicep\n  run: |\n    bicep lint ./infra/main.bicep --diagnostics-format sarif > bicep.sarif\n\n- name: Upload SARIF\n  if: always()\n  uses: github/codeql-action/upload-sarif@v3\n  with:\n    category: bicep\n    sarif_file: bicep.sarif\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The above does the same as the Azure CLI approach, but it uses the Bicep CLI directly. The ",(0,s.jsxs)(i.a,{href:"https://github.com/marketplace/actions/setup-bicep",children:[(0,s.jsx)(i.code,{children:"setup-bicep"})," action"]})," is provided by Anthony Martin and installs the Bicep CLI on your build agent."]}),"\n",(0,s.jsx)(i.p,{children:"As I say, right now you may want to favour this approach over the Azure CLI approach to cover both surfacing warnings and errors. But hopefully that will change soon."}),"\n",(0,s.jsx)(i.h2,{id:"linting-bicep-in-azure-pipelines-with-the-azure-cli",children:"Linting Bicep in Azure Pipelines with the Azure CLI"}),"\n",(0,s.jsxs)(i.p,{children:["We've now seen how to lint Bicep in GitHub Actions with both the Azure CLI and the Bicep CLI. We can do the same in Azure Pipelines; but only the Azure CLI approach (as I'm not sure if there's a ",(0,s.jsx)(i.code,{children:"setup-bicep"})," equivalent for Azure Pipelines)."]}),"\n",(0,s.jsx)(i.p,{children:'How you want to surface the results in Azure Pipelines is up to you. You could surface into the "Scans" portion of Azure Pipelines UI or into "Tests". I\'ll show you how to do both.'}),"\n",(0,s.jsx)(i.h3,{id:"surface-the-results-in-scans",children:"Surface the results in Scans"}),"\n",(0,s.jsx)(i.p,{children:"To surface the results in the scans part of Azure Pipelines you need to publish the SARIF file as a build artifact. You can do that like so:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yml",children:"jobs:\n  - job: LintInfra\n    displayName: Lint Infra\n    dependsOn: []\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - task: AzureCLI@2\n        displayName: Lint main.bicep\n        inputs:\n          azureSubscription: service-connection-with-access-to-registry # you may not need this\n          scriptType: bash\n          scriptLocation: inlineScript\n          inlineScript: |\n            az bicep install\n            az bicep lint --file infra/main.bicep --diagnostics-format sarif > $(System.DefaultWorkingDirectory)/bicep.sarif\n\n      - task: PublishBuildArtifacts@1\n        condition: always()\n        inputs:\n          pathToPublish: $(System.DefaultWorkingDirectory)/bicep.sarif\n          artifactName: CodeAnalysisLogs # required to show up in the scans tab\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The above is essentially the same as the GitHub Actions example, but it uses the Azure CLI instead of the Bicep CLI. The ",(0,s.jsx)(i.code,{children:"PublishBuildArtifacts"})," task is provided by Azure Pipelines. It allows you to publish build artifacts, which will show up in the Scans part of Azure Pipelines. You can see the results of the linting process in Scans, like so:"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"screenshot of the no-unused-vars rule in Azure Pipelines scans",src:n(73784).A+"",width:"2944",height:"842",loading:"lazy"})}),"\n",(0,s.jsxs)(i.p,{children:["You'll notice that the path above has a ",(0,s.jsx)(i.code,{children:"file:///home/vsts/work/1/s"})," prefix before the bicep path report of ",(0,s.jsx)(i.code,{children:"infra/main.bicep"}),". This is unfortunate and breaks \"clickability\". You cannot click on this and be taken to the file. It's possible to remedy this behaviour by doing a little find and replace magic on the SARIF file. You don't need to do this, but it does add to the developer experience."]}),"\n",(0,s.jsxs)(i.p,{children:["Below is the same portion of the Azure Pipelines yaml file but with some additional bash that will use ",(0,s.jsx)(i.code,{children:"sed"})," to replace all instances of the ",(0,s.jsx)(i.code,{children:"file:///home/vsts/work/1/s"})," prefix with an empty string:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yml",children:'jobs:\n  - job: LintInfra\n    displayName: Lint Infra\n    dependsOn: []\n    pool:\n      vmImage: \'ubuntu-latest\'\n    steps:\n      - task: AzureCLI@2\n        displayName: Lint main.bicep\n        inputs:\n          azureSubscription: service-connection-with-access-to-registry # you may not need this\n          scriptType: bash\n          scriptLocation: inlineScript\n          inlineScript: |\n            az bicep install\n            az bicep lint --file infra/main.bicep --diagnostics-format sarif > $(System.DefaultWorkingDirectory)/bicep.sarif\n\n            STRING_TO_REPLACE=\'file://$(Build.SourcesDirectory)/\'\n            echo "##[group]Bicep linting results before $STRING_TO_REPLACE replace:"\n            cat $(System.DefaultWorkingDirectory)/bicep.sarif\n            echo "##[endgroup]"\n\n            sed -i "s|$STRING_TO_REPLACE||g" $(System.DefaultWorkingDirectory)/bicep.sarif\n\n            echo "##[group]Bicep linting results after $STRING_TO_REPLACE replace:"\n            cat $(System.DefaultWorkingDirectory)/bicep.sarif\n            echo "##[endgroup]"\n\n      - task: PublishBuildArtifacts@1\n        condition: always()\n        inputs:\n          pathToPublish: $(System.DefaultWorkingDirectory)/bicep.sarif\n          artifactName: CodeAnalysisLogs # required to show up in the scans tab\n'})}),"\n",(0,s.jsx)(i.p,{children:"And hey presto! Clickability restored."}),"\n",(0,s.jsx)(i.h3,{id:"surface-the-results-in-tests",children:"Surface the results in Tests"}),"\n",(0,s.jsxs)(i.p,{children:["You can also surface the results in the tests part of Azure Pipelines. To do that we're going to borrow a ",(0,s.jsx)(i.a,{href:"https://github.com/Azure/bicep/issues/11960#issuecomment-1737226501",children:"suggestion from Anthony Martin"})," and use the ",(0,s.jsx)(i.a,{href:"https://www.npmjs.com/package/sarif-junit",children:(0,s.jsx)(i.code,{children:"sarif-junit"})})," package. This package allows us to convert a SARIF file to a JUnit file. JUnit is a standard for representing test results and can be used with the ",(0,s.jsx)(i.code,{children:"PublishTestResults"})," task."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yml",children:"jobs:\n  - job: LintInfra\n    displayName: Lint Infra\n    dependsOn: []\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - task: NodeTool@0\n        displayName: 'Install Node.js'\n        inputs:\n          versionSpec: '18.x'\n\n      - task: AzureCLI@2\n        displayName: Lint main.bicep\n        inputs:\n          azureSubscription: service-connection-with-access-to-registry # you may not need this\n          scriptType: bash\n          scriptLocation: inlineScript\n          inlineScript: |\n            az bicep install\n            az bicep lint --file infra/main.bicep --diagnostics-format sarif > $(System.DefaultWorkingDirectory)/bicep.sarif\n            npx -y sarif-junit -i $(System.DefaultWorkingDirectory)/bicep.sarif -o $(System.DefaultWorkingDirectory)/bicep.xml\n\n      - task: PublishTestResults@2\n        condition: always()\n        inputs:\n          testResultsFormat: 'JUnit'\n          testResultsFiles: '$(System.DefaultWorkingDirectory)/bicep.xml'\n"})}),"\n",(0,s.jsx)(i.p,{children:"So the above is the same approach again but requires Node.js to be installed, and the results end up in the Tests part of Azure Pipelines. You can see the results of the linting process in Tests, like so:"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"screenshot of the no-unused-vars rule in Azure Pipelines tests",src:n(14769).A+"",width:"2944",height:"1042",loading:"lazy"})}),"\n",(0,s.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(i.p,{children:"That's it! We've seen how to lint Bicep in Azure Pipelines and GitHub Actions. We've seen how to surface the results in the scans and tests parts of Azure Pipelines and in GitHub. We've seen how to do it with the Azure CLI and the Bicep CLI. And we've seen how to do it with warnings and errors. Hopefully this will help you to ensure that your Bicep files conform to best practices."}),"\n",(0,s.jsx)(i.p,{children:"Many thanks to Anthony Martin for his help, which laid the groundwork for much of what we explored in this post."})]})}function u(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},93928:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/title-image-af67d61370c2d04c19f5f6065b7d64c7.png"}}]);