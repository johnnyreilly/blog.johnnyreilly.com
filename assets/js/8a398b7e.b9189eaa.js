"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[41200],{2306:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var o=t(74848),i=t(28453);const s={slug:"migrating-azure-functions-node-js-v4-typescript",title:"Migrating to v4 Azure Functions Node.js with TypeScript",authors:"johnnyreilly",image:"./title-image.png",tags:["typescript","azure","azure functions","azure static web apps"],description:"Learn how to migrate a TypeScript Azure Functions app to the v4 Node.js programming model.",hide_table_of_contents:!1},r=void 0,a={permalink:"/migrating-azure-functions-node-js-v4-typescript",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2023-10-24-migrating-azure-functions-node-js-v4-typescript/index.md",source:"@site/blog/2023-10-24-migrating-azure-functions-node-js-v4-typescript/index.md",title:"Migrating to v4 Azure Functions Node.js with TypeScript",description:"Learn how to migrate a TypeScript Azure Functions app to the v4 Node.js programming model.",date:"2023-10-24T00:00:00.000Z",tags:[{inline:!1,label:"TypeScript",permalink:"/tags/typescript",description:"The TypeScript programming language."},{inline:!1,label:"Azure",permalink:"/tags/azure",description:"The Microsoft cloud platform."},{inline:!1,label:"Azure Functions",permalink:"/tags/azure-functions",description:"The Azure Functions service."},{inline:!1,label:"Azure Static Web Apps",permalink:"/tags/azure-static-web-apps",description:"The Azure Static Web Apps service."}],readingTime:8.26,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"migrating-azure-functions-node-js-v4-typescript",title:"Migrating to v4 Azure Functions Node.js with TypeScript",authors:"johnnyreilly",image:"./title-image.png",tags:["typescript","azure","azure functions","azure static web apps"],description:"Learn how to migrate a TypeScript Azure Functions app to the v4 Node.js programming model.",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Graph API: getting users Active Directory group names and ids with the C# SDK",permalink:"/graph-api-ad-users-group-name-ids-csharp-sdk"},nextItem:{title:"Bicep: Link Azure Application Insights to Static Web Apps",permalink:"/bicep-link-azure-application-insights-to-static-web-apps"}},c={image:t(76416).A,authorsImageUrls:[void 0]},l=[{value:"1. Changes to make to the <code>package.json</code>",id:"1-changes-to-make-to-the-packagejson",level:2},{value:"2. Migrating a Function",id:"2-migrating-a-function",level:2},{value:"<code>import</code>s used",id:"imports-used",level:3},{value:"Hello <code>app</code>, goodbye <code>function.json</code>",id:"hello-app-goodbye-functionjson",level:3},{value:"Signature and types of our <code>function</code>",id:"signature-and-types-of-our-function",level:3},{value:"From <code>context.res</code> to <code>Promise&lt;HttpResponseInit&gt;</code>",id:"from-contextres-to-promisehttpresponseinit",level:3},{value:"<code>body -&gt; jsonBody</code>",id:"body---jsonbody",level:3},{value:"Runtime APIs",id:"runtime-apis",level:3},{value:"3. Running locally",id:"3-running-locally",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",del:"del",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["There's a new programming model available for Node.js Azure Functions known as v4. There's documentation out there for ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-node-upgrade-v4?tabs=v4",children:"how to migrate JavaScript Azure Functions from v3 to v4"}),", but at the time of writing, TypeScript wasn't covered."]}),"\n",(0,o.jsxs)(n.p,{children:["This post fills in the gaps for a TypeScript Azure Function. It's probably worth mentioning that ",(0,o.jsx)(n.a,{href:"https://johnnyreilly.com",children:"my blog"})," is an ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/static-web-apps/overview",children:"Azure Static Web App"})," with a TypeScript Node.js Azure Functions back end. So, this post is based on my experience migrating my blog to v4."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"title image reading &quot;Link Azure Application Insights to Static Web Apps with Bicep&quot; with the Bicep and Azure Static Web App logos",src:t(57557).A+"",width:"800",height:"450",loading:"eager",fetchpriority:"high"})}),"\n",(0,o.jsxs)(n.p,{children:["I'm going to walk through the migration of my blog from v3 to v4. This takes place in ",(0,o.jsx)(n.a,{href:"https://github.com/johnnyreilly/blog.johnnyreilly.com/pull/728/files",children:"this pull request"}),". I'll probably cover some of the ground of the offical JavaScript upgrade docs, but I'll also cover some of the TypeScript specific stuff."]}),"\n",(0,o.jsx)(n.p,{children:"There will be two main parts to this post:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Changes to make to ",(0,o.jsx)(n.code,{children:"package.json"})]}),"\n",(0,o.jsx)(n.li,{children:"Migrating a Function"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The second part will be the bulk of the post, but the first part is important too."}),"\n",(0,o.jsxs)(n.h2,{id:"1-changes-to-make-to-the-packagejson",children:["1. Changes to make to the ",(0,o.jsx)(n.code,{children:"package.json"})]}),"\n",(0,o.jsxs)(n.p,{children:["So, starting with the first part, there are three changes to make to the ",(0,o.jsx)(n.code,{children:"package.json"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'  "dependencies": {\n+    "@azure/functions": "^4.0.1",\n  },\n  "devDependencies": {\n-    "@azure/functions": "^3.5.0",\n  },\n+  "main": "dist/src/functions/*/index.js"\n'})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Update the ",(0,o.jsx)(n.code,{children:"@azure/functions"})," dependency to ",(0,o.jsx)(n.code,{children:"^4.0.1"})," (or later)"]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"@azure/functions"})," dev dependency becomes a regular dependency - this is because we'll be using the package at runtime now - previously we just used it to get the types at build time"]}),"\n",(0,o.jsxs)(n.li,{children:["Add a ",(0,o.jsx)(n.code,{children:"main"})," property to the ",(0,o.jsx)(n.code,{children:"package.json"})," with a glob that matches the functions in your project; in my case ",(0,o.jsx)(n.code,{children:"dist/src/functions/*/index.js"})," - which will be our output from the TypeScript build"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["As I took care of ",(0,o.jsx)(n.strong,{children:"3."}),", I found myself changing the folder structure of my functions. Actually, this isn't mandatory, but it was tricky for me to come up with a glob for my current structure. So I moved things around - you may not need to. All that matters is that your glob matches the output of your build."]}),"\n",(0,o.jsx)(n.h2,{id:"2-migrating-a-function",children:"2. Migrating a Function"}),"\n",(0,o.jsxs)(n.p,{children:["In order that we can understand what migration looks like, we must first take a look at the v3 version of a function. Here's the ",(0,o.jsx)(n.code,{children:"fallback"})," function from my blog:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\nimport { redirect } from './redirect';\nimport { saveToDatabase } from './saveToDatabase';\n\nconst httpTrigger: AzureFunction = async function (\n  context: Context,\n  req: HttpRequest,\n): Promise<void> {\n  try {\n    const originalUrl = req.headers['x-ms-original-url'];\n\n    const { status, location } = redirect(originalUrl, context.log);\n\n    await saveToDatabase(originalUrl, { status, location }, context.log);\n\n    context.res = {\n      status,\n      headers: {\n        location,\n      },\n    };\n  } catch (error) {\n    context.log.error(\n      'Problem with fallback',\n      error,\n      req.headers['x-ms-original-url'],\n    );\n  }\n};\n\nexport default httpTrigger;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The above is the code I use to power ",(0,o.jsx)(n.a,{href:"/azure-static-web-apps-dynamic-redirects-azure-functions",children:"dynamic redirects in my Azure Static Web App with the Azure Function back-end"}),". It's a TypeScript Azure Function that takes a request, redirects to a new location and saves metadata about the redirect to a database."]}),"\n",(0,o.jsxs)(n.p,{children:["Looking at the code now, I rather think I should have called the function ",(0,o.jsx)(n.code,{children:"redirect"})," rather than ",(0,o.jsx)(n.code,{children:"fallback"}),". I'll leave it as is for now, but I'll probably change it in the future."]}),"\n",(0,o.jsxs)(n.p,{children:["What the ",(0,o.jsx)(n.code,{children:"fallback"})," function does isn't significant for this post, but the structure is. Now let's look at the migrated version:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type {\n  HttpRequest,\n  HttpResponseInit,\n  InvocationContext,\n} from '@azure/functions';\nimport { app } from '@azure/functions';\n\nimport { redirect } from './redirect';\nimport { saveToDatabase } from './saveToDatabase';\n\nexport async function fallback(\n  request: HttpRequest,\n  context: InvocationContext,\n): Promise<HttpResponseInit> {\n  try {\n    const originalUrl = request.headers.get('x-ms-original-url') || '';\n\n    const { status, location } = redirect(originalUrl, context);\n\n    await saveToDatabase(originalUrl, { status, location }, context);\n\n    return {\n      status,\n      headers: {\n        location,\n      },\n    };\n  } catch (error) {\n    context.error(\n      'Problem with fallback',\n      error,\n      request.headers.get('x-ms-original-url'),\n    );\n    return {\n      status: 500,\n      body: 'something went wrong',\n    };\n  }\n}\n\napp.http('fallback', {\n  methods: ['GET'],\n  handler: fallback,\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"As we can see, the logic looks pretty much the same. But a lot has changed. What's different? We'll go through the changes one by one."}),"\n",(0,o.jsxs)(n.h3,{id:"imports-used",children:[(0,o.jsx)(n.code,{children:"import"}),"s used"]}),"\n",(0,o.jsxs)(n.p,{children:["Starting at the top, the ",(0,o.jsx)(n.code,{children:"import"}),"s we use are different:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"-import type { AzureFunction, Context, HttpRequest } from '@azure/functions';\n+import type {\n+  HttpRequest,\n+  HttpResponseInit,\n+  InvocationContext,\n+} from '@azure/functions';\n+import { app } from '@azure/functions';\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We're no longer just importing types, we're importing the ",(0,o.jsx)(n.code,{children:"app"})," function from ",(0,o.jsx)(n.code,{children:"@azure/functions"})," also. The types that are being imported are different too. We're no longer importing ",(0,o.jsx)(n.code,{children:"AzureFunction, Context, HttpRequest"})," - instead we're importing ",(0,o.jsx)(n.code,{children:"HttpRequest, HttpResponseInit,  InvocationContext"}),"."]}),"\n",(0,o.jsxs)(n.h3,{id:"hello-app-goodbye-functionjson",children:["Hello ",(0,o.jsx)(n.code,{children:"app"}),", goodbye ",(0,o.jsx)(n.code,{children:"function.json"})]}),"\n",(0,o.jsxs)(n.p,{children:["As we saw, we're making use of the ",(0,o.jsx)(n.code,{children:"app"})," function from ",(0,o.jsx)(n.code,{children:"@azure/functions"}),". This is a new function that we use to register our Azure Functions. We no longer use ",(0,o.jsx)(n.code,{children:"function.json"}),". Instead we use ",(0,o.jsx)(n.code,{children:"app"}),". In the case of my ",(0,o.jsx)(n.code,{children:"fallback"})," Azure Functions, we register it like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"app.http('fallback', {\n  methods: ['GET'],\n  handler: fallback,\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We're registering an HTTP trigger called ",(0,o.jsx)(n.code,{children:"fallback"})," that responds to ",(0,o.jsx)(n.code,{children:"GET"})," requests. The ",(0,o.jsx)(n.code,{children:"handler"})," is the function that will be called when the trigger is invoked. There's more options available, but this is the minimum we need to register our function."]}),"\n",(0,o.jsxs)(n.p,{children:["This minimal TypeScript/JavaScript replaces the more verbose ",(0,o.jsx)(n.code,{children:"function.json"})," that used to sit alongside:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "bindings": [\n    {\n      "authLevel": "anonymous",\n      "type": "httpTrigger",\n      "direction": "in",\n      "name": "req",\n      "methods": ["get", "post"]\n    },\n    {\n      "type": "http",\n      "direction": "out",\n      "name": "res"\n    }\n  ],\n  "scriptFile": "../dist/fallback/index.js"\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["All of this is gone, replaced by the ",(0,o.jsx)(n.code,{children:"app"})," function usage. There's one part of the ",(0,o.jsx)(n.code,{children:"function.json"})," that isn't covered by the ",(0,o.jsx)(n.code,{children:"app"})," function, and that's the ",(0,o.jsx)(n.code,{children:"scriptFile"})," property. This is covered by the ",(0,o.jsx)(n.code,{children:"main"})," property we added to the ",(0,o.jsx)(n.code,{children:"package.json"})," earlier."]}),"\n",(0,o.jsxs)(n.p,{children:["The rest of the ",(0,o.jsx)(n.code,{children:"function.json"})," is covered by the ",(0,o.jsx)(n.code,{children:"app.http"})," call. Much terser."]}),"\n",(0,o.jsxs)(n.h3,{id:"signature-and-types-of-our-function",children:["Signature and types of our ",(0,o.jsx)(n.code,{children:"function"})]}),"\n",(0,o.jsx)(n.p,{children:"The signature of our function has changed too:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"-const httpTrigger: AzureFunction = async function (\n-  context: Context,\n-  req: HttpRequest\n-): Promise<void> {\n+export async function fallback(\n+  request: HttpRequest,\n+  context: InvocationContext,\n+): Promise<HttpResponseInit> {\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You'll see here that we're using a function declaration rather than a function expression. Our new function takes our new types, the subtly different ",(0,o.jsx)(n.code,{children:"HttpRequest"})," and ",(0,o.jsx)(n.code,{children:"InvocationContext"}),", which are similar to, but different from, the previous ",(0,o.jsx)(n.code,{children:"Context"})," and ",(0,o.jsx)(n.code,{children:"HttpRequest"})," types. The order of these parameters has changed also."]}),"\n",(0,o.jsxs)(n.p,{children:["The return type of the function is now ",(0,o.jsx)(n.code,{children:"Promise<HttpResponseInit>"})," rather than ",(0,o.jsx)(n.code,{children:"Promise<void>"}),". What this means is, we're going to return values from our function, which we didn't do previously. Let's look at the implications of this."]}),"\n",(0,o.jsxs)(n.h3,{id:"from-contextres-to-promisehttpresponseinit",children:["From ",(0,o.jsx)(n.code,{children:"context.res"})," to ",(0,o.jsx)(n.code,{children:"Promise<HttpResponseInit>"})]}),"\n",(0,o.jsxs)(n.p,{children:["With a v3 function, we'd set the ",(0,o.jsx)(n.code,{children:"context.res"})," property to return values from our function. With a v4 function, we return values from our function directly. What does this look like?"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"-    context.res = {\n-      status,\n-      headers: {\n-        location,\n-      },\n-    };\n+    return {\n+      status,\n+      headers: {\n+        location,\n+      },\n+    };\n"})}),"\n",(0,o.jsxs)(n.p,{children:["I rather like this change. My reasoning is that, in the event that there is subsequent code that would otherwise run after ",(0,o.jsx)(n.code,{children:"context.res"})," was set, we no longer need to remember to subsequently ",(0,o.jsx)(n.code,{children:"return"})," to prevent that running. (And yes, I have made that mistake on multiple occasions.) All we need do is return the value we want to return from our function."]}),"\n",(0,o.jsx)(n.h3,{id:"body---jsonbody",children:(0,o.jsx)(n.code,{children:"body -> jsonBody"})}),"\n",(0,o.jsxs)(n.p,{children:["Another difference is that we no longer set the ",(0,o.jsx)(n.code,{children:"body"})," property of the ",(0,o.jsx)(n.code,{children:"context.res"}),". Instead we return an object with a ",(0,o.jsx)(n.code,{children:"jsonBody"})," property, assuming we're returning JSON from our API. (And that's the most common case, right?)"]}),"\n",(0,o.jsxs)(n.p,{children:["This wasn't illustrated in the ",(0,o.jsx)(n.code,{children:"fallback"})," function above, but here's an example of migrating a function that returns JavaScript object literal named ",(0,o.jsx)(n.code,{children:"redirectSummary"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"-    context.res = {\n-      status: 200,\n-      body: redirectSummary,\n-    };\n+    return {\n+      status: 200,\n+      jsonBody: redirectSummary,\n+    };\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"body"})," property still exists, but it's for returning strings and other things, rather than JSON. If you're returning JSON, the easiest approach is to use the ",(0,o.jsx)(n.code,{children:"jsonBody"})," property."]}),"\n",(0,o.jsx)(n.h3,{id:"runtime-apis",children:"Runtime APIs"}),"\n",(0,o.jsxs)(n.p,{children:["Finally, the APIs offered by the ",(0,o.jsx)(n.code,{children:"request"})," and ",(0,o.jsx)(n.code,{children:"context"})," objects are different. I shan't go into detail here as it's ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-node-upgrade-v4?tabs=v4#review-your-usage-of-http-types",children:"well covered in the official documentation"}),". But I will show you one of the changes I made to my ",(0,o.jsx)(n.code,{children:"fallback"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"-    const originalUrl = req.headers['x-ms-original-url'];\n+    const originalUrl = request.headers.get('x-ms-original-url') || '';\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Not too significant a tweak, but there's a number of slight changes like this to make. (Related to this, the logging API on the ",(0,o.jsx)(n.code,{children:"context"})," object is also different - but not significantly.)"]}),"\n",(0,o.jsx)(n.h2,{id:"3-running-locally",children:"3. Running locally"}),"\n",(0,o.jsxs)(n.p,{children:["If you're a fan of running locally then you may need to make this tweak to your ",(0,o.jsx)(n.code,{children:"host.json"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'    "extensionBundle": {\n        "id": "Microsoft.Azure.Functions.ExtensionBundle",\n-        "version": "[3.*, 4.0.0)"\n+        "version": "[4.*, 5.0.0)"\n    }\n'})}),"\n",(0,o.jsxs)(n.p,{children:["A complete ",(0,o.jsx)(n.code,{children:"host.json"})," might look like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n    "version": "2.0",\n    "logging": {\n        "applicationInsights": {\n            "samplingSettings": {\n                "isEnabled": true,\n                "excludedTypes": "Request"\n            }\n        }\n    },\n    "extensionBundle": {\n        "id": "Microsoft.Azure.Functions.ExtensionBundle",\n        "version": "[4.*, 5.0.0)"\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["As discussed with ",(0,o.jsx)(n.a,{href:"https://github.com/ejizba",children:"Eric Jizba"})," on ",(0,o.jsx)(n.a,{href:"https://github.com/Azure/azure-functions-core-tools/issues/3508#issuecomment-1894356158",children:"this GitHub issue"}),", updating the ",(0,o.jsx)(n.code,{children:"host.json"})," may not actually be necessary.  For me it seemed to be the thing that turned a not working setup into a working setup; but it's possible I was mistaken. Certainly if I revert the change now I'm still able to run locally.  What I'm saying is: your mileage may vary."]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:['Migrating an Azure Function from v3 to v4 with TypeScript is a little more involved than I\'d expected. But I do like that this moves us to a code style that feels more "Node-y". ',(0,o.jsx)(n.del,{children:"The official documentation is good, but it's not complete right now."})," There's now a decent upgrade guide available: ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-node-upgrade-v4?tabs=v4",children:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-node-upgrade-v4?tabs=v4"})]}),"\n",(0,o.jsx)(n.p,{children:"Hopefully this post will help you migrate your TypeScript Azure Functions to v4."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},76416:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/title-image-e16bb3c85ded7aa934b9ef8a41a2541a.png"},57557:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/title-image-e16bb3c85ded7aa934b9ef8a41a2541a.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);