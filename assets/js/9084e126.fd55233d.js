"use strict";(self.webpackChunkjohnnyreilly_com=self.webpackChunkjohnnyreilly_com||[]).push([[54086],{63972:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var a=n(74848),s=n(28453);const r={slug:"iqueryable-ienumerable-hmmm",title:"IQueryable... IEnumerable... Hmmm...",authors:"johnnyreilly",tags:["c#"],hide_table_of_contents:!1,description:"The debate surrounding passing IQueryable<T> as IEnumerable<T> is discussed. Changing the method signature is proposed as a solution."},i=void 0,o={permalink:"/iqueryable-ienumerable-hmmm",editUrl:"https://github.com/johnnyreilly/blog.johnnyreilly.com/edit/main/blog-website/blog/2015-11-30-iqueryable-ienumerable-hmmm/index.md",source:"@site/blog/2015-11-30-iqueryable-ienumerable-hmmm/index.md",title:"IQueryable... IEnumerable... Hmmm...",description:"The debate surrounding passing IQueryable<T> as IEnumerable<T> is discussed. Changing the method signature is proposed as a solution.",date:"2015-11-30T00:00:00.000Z",tags:[{inline:!1,label:"C#",permalink:"/tags/csharp",description:"The C# programming language."}],readingTime:4.365,hasTruncateMarker:!0,authors:[{name:"John Reilly",title:"OSS Engineer - TypeScript, Azure, React, Node.js, .NET",url:"https://johnnyreilly.com/about",imageURL:"https://johnnyreilly.com/img/profile.jpg",key:"johnnyreilly"}],frontMatter:{slug:"iqueryable-ienumerable-hmmm",title:"IQueryable... IEnumerable... Hmmm...",authors:"johnnyreilly",tags:["c#"],hide_table_of_contents:!1,description:"The debate surrounding passing IQueryable<T> as IEnumerable<T> is discussed. Changing the method signature is proposed as a solution."},unlisted:!1,prevItem:{title:"ES6 + TypeScript + Babel + React + Flux + Karma: The Secret Recipe",permalink:"/es6-typescript-babel-react-flux-karma"},nextItem:{title:"The Names Have Been Changed...",permalink:"/the-names-have-been-changed"}},l={authorsImageUrls:[void 0]},h=[{value:"LINQ to Objects vs LINQ to ... ?",id:"linq-to-objects-vs-linq-to--",level:2},{value:"Fixing the Problem",id:"fixing-the-problem",level:2}];function d(e){const t={blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["So there I was, tip-tapping away at my keyboard when I became aware of the slowly loudening noise of a debate. It wasn't about poverty, war, civil rights or anything like that. No; this was far more contentious. It was about the behaviour of ",(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/bb351562(v=vs.100).aspx">IQueryable&lt;T&gt;</a>'})," when mixed with ",(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/9eekhta0(v=vs.100).aspx">IEnumerable&lt;T&gt;</a>'}),". I know, right, how could I not get involved?"]}),"\n",(0,a.jsx)(t.p,{children:"The code that was being debated was a database query that was being facilitated by Entity Framework. Now let me ask you a question: what is the problem with the methods below?"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cs",children:"private IEnumerable<Sage> GetSagesWithSayings()\n{\n    IQueryable<Sage> sageWithSayings =\n        from s in DbContext.Sages.Include(x => x.Sayings)\n        select s;\n\n    return sageWithSayings;\n}\n\npublic IEnumerable<Sage> GetSagesWithSayingsBornWithinTheLast100Years()\n{\n    var aHundredYearsAgo = DateTime.Now.AddYears(-100);\n    var sageWithSayings = GetSagesWithSayings().Where(x => x.DateOfBirth > aHundredYearsAgo);\n\n    return sageWithSayings;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["I've rather emphasised the problem by expressly declaring types in the ",(0,a.jsx)(t.code,{children:"GetSagesWithSayings"})," method. More typically the ",(0,a.jsx)(t.code,{children:"IQueryable&lt;Sage&gt;"})," would be hiding itself beneath a ",(0,a.jsx)(t.code,{children:"var"})," making the problem less obvious. But you get the point; it's something to do with an ",(0,a.jsx)(t.code,{children:"IQueryable&lt;Sage&gt;"})," being passed back as an ",(0,a.jsx)(t.code,{children:"IEnumerable&lt;Sage&gt;"}),"."]}),"\n",(0,a.jsx)(t.p,{children:'The debate was raging around what this piece of code (or one much like it) actually did. One side positing "it\'ll get every record from the database and then throw away what it doesn\'t need in C#-land..." The opposing view being "are you sure about that? Doesn\'t it just get the records from the last hundred years from the database?"'}),"\n",(0,a.jsx)(t.p,{children:"So it comes down the SQL that ends up being generated. On the one hand it's going to get everything from the Sages table..."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"select ...\nfrom Sages ...\n"})}),"\n",(0,a.jsx)(t.p,{children:"Or does it include a filter clause as well?"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"select ...\nfrom Sages ...\nwhere DateOfBirth > '1915-11-30'\n"})}),"\n",(0,a.jsx)(t.p,{children:"You probably know the answer... It gets everything. Every record is brought back from the database and those that are older than 100 years are then casually thrown away. So kinda wasteful. That's the problem. But why? And what does that tell us?"}),"\n",(0,a.jsx)(t.h2,{id:"linq-to-objects-vs-linq-to--",children:"LINQ to Objects vs LINQ to ... ?"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['The term "LINQ to Objects" refers to the use of LINQ queries with any ',(0,a.jsx)(t.code,{children:"IEnumerable"})," or ",(0,a.jsx)(t.code,{children:"IEnumerable&lt;T&gt;"})," collection directly, without the use of an intermediate LINQ provider or API such as LINQ to SQL or LINQ to XML."]}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/bb351562(v=vs.100).aspx">IQueryable&lt;T&gt;</a>'})," interface is intended for implementation by query providers."]}),"\n",(0,a.jsxs)(t.p,{children:["This interface inherits the ",(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/9eekhta0(v=vs.100).aspx">IEnumerable&lt;T&gt;</a>'})," interface so that if it represents a query, the results of that query can be enumerated. Enumeration forces the expression tree associated with an ",(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/bb351562(v=vs.100).aspx">IQueryable&lt;T&gt;</a>'})," object to be executed. Queries that do not return enumerable results are executed when the ",(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/bb549414(v=vs.100).aspx">Execute&lt;TResult&gt;(Expression)</a>'})," method is called."]}),"\n",(0,a.jsx)(t.p,{children:'The definition of "executing an expression tree" is specific to a query provider. For example, it may involve translating the expression tree to a query language appropriate for an underlying data source.'}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'I know - check me out with my "quotes".'}),"\n",(0,a.jsxs)(t.p,{children:["Now, ",(0,a.jsx)(t.code,{children:"IEnumerable"})," and ",(0,a.jsx)(t.code,{children:"IQueryable"}),' are similar; for instance they are both considered "lazy" as they offer deferred execution. But there is an important difference between ',(0,a.jsx)(t.code,{children:"IEnumerable"})," and ",(0,a.jsx)(t.code,{children:"IQueryable"}),"; namely that ",(0,a.jsx)(t.code,{children:"IQueryable"})," hands off information about a query to another provider in order that they may decide how to do the necessary work. ",(0,a.jsx)(t.code,{children:"IEnumerable"})," does not; its work is done in memory by operating on the data it has."]}),"\n",(0,a.jsxs)(t.p,{children:["So let's apply this to our issue. We have an ",(0,a.jsx)(t.code,{children:"IQueryable&lt;Sage&gt;"})," and we return it as an ",(0,a.jsx)(t.code,{children:"IEnumerable&lt;Sage&gt;"}),". By doing this we haven't changed the underlying type; it's still an ",(0,a.jsx)(t.code,{children:"IQueryable&lt;Sage&gt;"}),". But by upcasting to ",(0,a.jsx)(t.code,{children:"IEnumerable&lt;Sage&gt;"})," we have told the compiler that we don't have an ",(0,a.jsx)(t.code,{children:"IQueryable&lt;Sage&gt;"}),". We've lied. I trust you're feeling guilty."]}),"\n",(0,a.jsxs)(t.p,{children:["No doubt whoever raised you told you not to tell lies. This was probably the very situation they had in mind. The implications of our dirty little fib come back to haunt us when we start to chain on subsequent filters. So when we perform our filter of ",(0,a.jsx)(t.code,{children:".Where(x =&gt; x.DateOfBirth &gt; aHundredYearsAgo)"})," the compiler isn't going to get LINQ to Entities's extension methods in on this. No, it's going to get the LINQ to object extension methods instead."]}),"\n",(0,a.jsxs)(t.p,{children:["This is the cause of our problem. When it comes to execution we're not getting the database to do the heavy lifting because we've moved away from using ",(0,a.jsx)(t.code,{children:"IQueryable"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"fixing-the-problem",children:"Fixing the Problem"}),"\n",(0,a.jsx)(t.p,{children:"There are 2 courses of action open to you. The obvious course of action (and 99% of the time what you'd look to do) is change the signature of the `` method to return an IQueryable like so:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cs",children:"private IQueryable<Sage> GetSagesWithSayings()\n    var sageWithSayings = // I prefer 'var', don't you?\n        from s in DbContext.Sages.Include(x => x.Sayings)\n        select s;\n\n    return sageWithSayings;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:['The other alternative is what I like to think of as "the escape hatch": ',(0,a.jsx)(t.code,{children:'<a href="https://msdn.microsoft.com/en-gb/library/bb353734(v=vs.100).aspx">AsQueryable</a>'}),". This takes an ",(0,a.jsx)(t.code,{children:"IEnumerable"}),", checks if it's actually an ",(0,a.jsx)(t.code,{children:"IQueryable"})," slumming it and casts back to that if it is. You might use this in a situation where you didn't have control over the data access code. Using it looks like this: (and would work whether ",(0,a.jsx)(t.code,{children:"GetSagesWithSayings"})," was returning ",(0,a.jsx)(t.code,{children:"IEnumerable"}),(0,a.jsx)(t.em,{children:"or"}),(0,a.jsx)(t.code,{children:"IQueryable"}),")"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cs",children:"public IEnumerable<Sage> GetSagesWithSayingsBornWithinTheLast100Years()\n{\n    var aHundredYearsAgo = DateTime.Now.AddYears(-100);\n    var sageWithSayings =GetSagesWithSayings().AsQueryable().Where(x => x.DateOfBirth > aHundredYearsAgo);\n\n    return sageWithSayings;\n}\n"})})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(96540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);